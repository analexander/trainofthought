{"ast":null,"code":"import _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * deeplearn.js backend.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { onesLike as coreOnesLike, scalar, tensor1d, tidy, where, zerosLike as coreZerosLike } from '@tensorflow/tfjs-core';\nimport { checkDataFormat } from '../common';\nimport { NotImplementedError, ValueError } from '../errors';\nimport * as math_utils from '../utils/math_utils';\nimport { imageDataFormat } from './common'; // tslint:enable\n\n/* Setting and getting backend from deeplearn.js. */\n// Default deeplearn.js backend is WebGL (GPU).\n\nvar backend = 'webgl';\nexport function setBackend(requestedBackend) {\n  tfc.setBackend(requestedBackend);\n  backend = requestedBackend;\n}\nexport function getBackend() {\n  return backend;\n}\n/**\n * Indicates whether the backend is operating symbolically.\n *\n * This function will be used to determine how to interpret user code. If\n * it returns true, calls to the backend construct a symbolic graph; if\n * it returns false, calls to the backend execute immediately.\n */\n\nexport function isBackendSymbolic() {\n  return false;\n}\n/**\n * Get the number of elements in a Tensor.\n * @param x The Tensor.\n * @return Number of elements in `x`.\n */\n\nexport function countParams(x) {\n  var shape = x.shape;\n\n  if (shape.length > 0) {\n    return shape.reduce(function (a, b) {\n      return a * b;\n    });\n  } else {\n    // Scalar.\n    return 1;\n  }\n}\n/**\n * Casts a tensor to a different dtype and returns it.\n * @param x Input tensor.\n * @param dtype String: 'float32'|'int32'|'bool'.\n * @returns Tensor of the specified `dtype`.\n */\n\nexport function cast(x, dtype) {\n  return x.asType(dtype);\n}\n/**\n * Adds a 1-sized dimension at index \"axis\".\n * @param x Input tensor.\n * @param axis Position where to add the new axis.\n * @returns Result of the dimension expansion.\n */\n\nexport function expandDims(x) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n  var outShape = x.shape.slice();\n\n  if (axis < 0) {\n    axis = outShape.length + axis + 1;\n  }\n\n  outShape.splice(axis, 0, 1);\n  return x.reshape(outShape);\n}\n/**\n * Repeats a 2D tensor.\n *\n * If `x` has shape `[samples, dim]` and `n` is 2, for example, the output\n * will have shape `[samples, 2, dim]`.\n *\n * @param x Input tensor.\n * @param n Integer, number of times to repeat.\n * @returns The result of the repeat operation.\n * @throws ValueError: If input tensor is not 2D.\n */\n\nexport function repeat(x, n) {\n  return tidy(function () {\n    if (x.shape.length !== 2) {\n      throw new ValueError(\"repeat() expects a rank-2 tensor, but received a \" + \"rank-\".concat(x.shape.length, \" tensor.\"));\n    }\n\n    var y = expandDims(x, 1);\n    return tile(y, [1, n, 1]);\n  });\n}\n/**\n * Flatten a Tensor into 1D.\n * @param x Input tensor.\n * @return The result of the flattening `x`.\n */\n\nexport function flatten(x) {\n  var newShape = [math_utils.arrayProd(x.shape)];\n  return x.reshape(newShape);\n}\n/**\n * Turn a nD tensor into a 2D tensor with same 0th dimension.\n * In other words, it flattens each data samples of a batch.\n *\n * @param x The tensor to flatten. The rank of this tensor is required to be 2\n *   or higher.\n * @return The result of the flattening.\n */\n\nexport function batchFlatten(x) {\n  if (x.rank <= 1) {\n    throw new ValueError(\"batchFlatten requires a minimum rank of 2. Got rank: \".concat(x.rank, \".\"));\n  }\n\n  var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];\n  return x.reshape(newShape);\n}\n/**\n * Do slicing along the first axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the first axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\n\nexport function sliceAlongFirstAxis(array, start, size) {\n  return tidy(function () {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array, start, size);\n\n      case 2:\n        return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);\n\n      case 3:\n        return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);\n\n      case 4:\n        return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);\n\n      case 5:\n        return tfc.slice(array, [start, 0, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3], array.shape[4]]);\n\n      case 6:\n        return tfc.slice(array, [start, 0, 0, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3], array.shape[4], array.shape[5]]);\n\n      default:\n        throw new ValueError(\"sliceAlongFirstAxis() received an unsupported tensor rank: \" + \"\".concat(array.rank));\n    }\n  });\n}\n/**\n * Do slicing along the last axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the last axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\n\nexport function sliceAlongLastAxis(array, start, size) {\n  return tidy(function () {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array, start, size);\n\n      case 2:\n        return tfc.slice2d(array, [0, start], [array.shape[0], size]);\n\n      case 3:\n        return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);\n\n      case 4:\n        return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);\n\n      default:\n        throw new ValueError(\"sliceAlongLastAxis() received an unsupported tensor rank: \" + \"\".concat(array.rank));\n    }\n  });\n}\n/**\n * Do slicing along the sepcified axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size of the slice along the chosen axis.\n * @param choose an axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\n\nexport function sliceAlongAxis(array, start, size, axis) {\n  return tidy(function () {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array, start, size);\n\n      case 2:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n\n          case 2:\n            return sliceAlongLastAxis(array, start, size);\n\n          default:\n            throw new ValueError(\"The axis is not within the rank of the tensor \" + \"\".concat(axis));\n        }\n\n      case 3:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n\n          case 2:\n            return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);\n\n          case 3:\n            return sliceAlongLastAxis(array, start, size);\n\n          default:\n            throw new ValueError(\"The axis is not within the rank of the tensor \" + \"\".concat(axis));\n        }\n\n      case 4:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n\n          case 2:\n            return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);\n\n          case 3:\n            return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);\n\n          case 4:\n            return sliceAlongLastAxis(array, start, size);\n\n          default:\n            throw new ValueError(\"The axis is not within the rank of the tensor \" + \"\".concat(axis));\n        }\n\n      default:\n        throw new ValueError(\"sliceAlongLastAxis() received an unsupported tensor rank: \" + \"\".concat(array.rank));\n    }\n  });\n}\n/**\n * Concatenates a list of tensors alongside the specified axis.\n * @param tensors `Array` of tensors to concatenate.\n * @param axis Concatenation axis.\n * @returns The result of the concatenation.\n */\n\nexport function concatenate(tensors) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n  var rank;\n\n  if (axis < 0) {\n    rank = tensors[0].rank;\n\n    if (rank !== 0) {\n      axis = rank;\n    } else {\n      axis = 0;\n    }\n  }\n\n  if (axis === tensors[0].rank) {\n    // Porting Note: This is necessary because tfc.concat() requires axis to be\n    //   in the interval [-rank, rank).\n    axis = -1;\n  } // Porting Note: Sparse concat is not supported yet.\n\n\n  return tfc.concat(tensors, axis);\n}\n/**\n * Concatenate two arrays along the first dimension.\n * @param a The 1st `tf.Tensor` to concatenate.\n * @param b The 2nd `tf.Tensor` to concatenate.\n * @returns Result of the concatenation.\n * @throws ValueError: If `a` is of an unsupported subtype of `tf.Tensor`.\n */\n\nexport function concatAlongFirstAxis(a, b) {\n  switch (a.rank) {\n    case 1:\n      return tfc.concat1d([a, b]);\n\n    case 2:\n      return tfc.concat2d([a, b], 0);\n\n    case 3:\n      return tfc.concat3d([a, b], 0);\n\n    case 4:\n      return tfc.concat4d([a, b], 0);\n\n    default:\n      throw new ValueError(\"concatAlongFirstAxis() received an unsupported \" + \"tensor rank: \".concat(a.rank));\n  }\n}\n/**\n * Creates a tensor by tiling `x` by `n`.\n * @param x A tensor.\n * @param n An Array of integers or a single integer. If an Array, the length\n *   must be the same as the number of dimensions in `x`. If a single integer,\n *   it will be treated as an Array of length 1.\n */\n\nexport function tile(x, n) {\n  if (!Array.isArray(n)) {\n    n = [n];\n  }\n\n  if (x.rank !== n.length) {\n    throw new ValueError(\"The length of input n (\".concat(n.length, \") does not match \") + \"the number of dimensions in input x (\".concat(x.rank, \")\"));\n  }\n\n  return tfc.tile(x, n);\n}\n/* Creation of random tensors. */\n\n/**\n * Get a tensor with normal distribution of values.\n *\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @return The normal tensor.\n */\n\nexport function randomNormal(shape) {\n  var mean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n  var stddev = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;\n  var dtype = arguments.length > 3 ? arguments[3] : undefined;\n  var seed = arguments.length > 4 ? arguments[4] : undefined;\n  return tfc.randomNormal(shape, mean, stddev, dtype, seed);\n}\n/* Linear Algebra */\n\n/**\n * Multiply two tensors and returns the result as a tensor.\n *\n * For 2D tensors, this is equivalent to matrix multiplication (matMul).\n * For tensors of higher ranks, it follows the Theano behavior,\n * (e.g. `(2, 3) * (4, 3, 5) -> (2, 4, 5)`).  From the Theano documentation:\n *\n * For N dimensions it is a sum product over the last axis of x and the\n * second-to-last of y:\n *\n * @param a A tensor of at least rank 2.\n * @param b A tensor of at least rank 2.\n * @param activation (optional) A string identifying the activation\n *   function.\n * @return Result of the dot operation.\n */\n\nexport function dot(a, b, activation, bias) {\n  if (a.rank < 2 || b.rank < 2) {\n    throw new NotImplementedError(\"dot requires both inputs to be rank >= 2\" + \" but got x shape = \".concat(a.shape, \" and y shape = \").concat(b.shape));\n  }\n\n  if (b.rank >= 3) {\n    var xLastDim = a.shape.slice(-1)[0];\n    var ySecondLastDim = b.shape.slice(-2)[0];\n\n    if (xLastDim !== ySecondLastDim) {\n      throw new NotImplementedError(\"If rank y >= 3, then the second last dim\" + \" of y must equal the last dim of x but got x shape = \".concat(a.shape, \" and \") + \" y shape = \".concat(b.shape));\n    }\n  } // Handle basic 2D x 2D case.\n\n\n  if (a.rank === 2 && b.rank === 2) {\n    var transposeA = false;\n    var transposeB = false; // tfc.fused.matMul only fuses certain activation functions. Unsupported\n    // activation functions are treated as 'linear' activations, which is\n    // equivalent to a no-op.\n\n    return tfc.fused.matMul({\n      a: a,\n      b: b,\n      transposeA: transposeA,\n      transposeB: transposeB,\n      bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n      activation: activation\n    });\n  } else {\n    // Reshape x into the analogous 2D Tensor.\n    var aFirstDims = a.shape.slice(); // Holds all but the last dim of x.\n\n    var aLastDim = aFirstDims.pop();\n    a = a.reshape([-1, aLastDim]); // Reshape y into the analogous 2D Tensor, and keep track of the\n    // required dimensions to reproduce the output shape.\n\n    var bShape = b.shape.slice();\n    var bLastDim = bShape.pop();\n\n    var _ySecondLastDim = bShape.pop();\n\n    var yOtherDims = [].concat(_toConsumableArray(bShape), [bLastDim]); // permutation should be like [r-2, 0, 1, 2, ... r-4, r-3, r-1]\n    // where r is the rank of y.\n\n    var perm = Array.from({\n      length: b.rank\n    }, function (_, i) {\n      if (i === 0) {\n        return b.rank - 2;\n      } else if (i <= b.rank - 2) {\n        return i - 1;\n      }\n\n      return i;\n    });\n    b = b.transpose(perm).reshape([_ySecondLastDim, -1]); // Multiply x and y as 2D Tensors, and then reshape back to original.\n\n    var outputShape = [].concat(_toConsumableArray(aFirstDims), _toConsumableArray(yOtherDims));\n    var _transposeA = false;\n    var _transposeB = false;\n    return tfc.fused.matMul({\n      a: a,\n      b: b,\n      transposeA: _transposeA,\n      transposeB: _transposeB,\n      bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n      activation: activation\n    }).reshape(outputShape);\n  }\n}\n/**\n * Compute the sign Tensor of an input Tensor.\n *\n * Elements of the input `tf.Tensor` that are === 0 are mapped to 0.\n * Elements of the input `tf.Tensor` that are > 0 are mapped to 1.\n * Elements of the input `tf.Tensor` that are < 0 are mapped to -1.\n *\n * @param x Input `tf.Tensor`.\n * @return The sign `tf.Tensor`.\n */\n\nexport function sign(x) {\n  // TODO(cais): Move to the core.\n  return tidy(function () {\n    var zerosLikeX = coreZerosLike(x);\n    var onesLikeX = coreOnesLike(x);\n    return where(tfc.equal(x, zerosLikeX), zerosLikeX, where(tfc.greater(x, coreZerosLike(x)), onesLikeX, tfc.mul(-1, onesLikeX)));\n  });\n}\n/**\n * Computes the one-hot representation of an integer tensor.\n * @param indices nD integer tensor of shape\n *   `(batch_size, dim1, dim2, ... dim(n-1))`\n * @param numClasses Integer, number of classes to consider.\n * @returns (n + 1)D one hot representation of the input\n *   with shape `(batch_size, dim1, dim2, ... dim(n-1), num_classes)`\n */\n\nexport function oneHot(indices, numClasses) {\n  return tidy(function () {\n    if (indices.rank !== 1) {\n      throw new Error('Only 1D one-hot tensors are supported in the ' + 'deeplearn backend, at present.');\n    }\n\n    indices = indices.toInt();\n    return tfc.oneHot(indices, numClasses).toFloat();\n  });\n}\n/* Elementary math functions. */\n\n/**\n * Retrieves the elements of indices `indices` in the tensor `reference`.\n * @param reference A tensor.\n * @param indices An integer tensor of indices or an `Array` of integers.\n * @param axis Axis along which to perform the gather operation.\n * @returns The result of the gathering as a tensor.\n */\n\nexport function gather(reference, indices, axis) {\n  return tidy(function () {\n    if (Array.isArray(indices)) {\n      indices = tensor1d(indices, 'int32');\n    } else {\n      indices = indices.toInt();\n    }\n\n    return tfc.gather(reference, indices, axis);\n  });\n}\n/**\n * Element-wise square.\n * @param x Input tensor.\n * @return element-wise x^2\n */\n\nexport function square(x) {\n  return tfc.mul(x, x);\n}\n/**\n * Element-wise exponentiation.\n *\n * Porting Note: In PyKeras, `a` (the exponent) is a Python integer, which\n *   takes advatnage of the backend's (e.g., TensorFlow's) automatic\n * conversion to tensor. Here we allow `a` to be either a number or a tensor.\n *\n * @param x The base tensor.\n * @param a The exponent, tensor or number. If a number, it is rounded to the\n *   nearest integer and converted to a tensor.\n * @returns A tensor of the same shape as `x`.\n */\n\nexport function pow(x, a) {\n  return tidy(function () {\n    if (typeof a === 'number') {\n      a = scalar(Math.round(a), 'int32');\n    }\n\n    if (a.dtype !== 'int32') {\n      throw new NotImplementedError(\"Non-int32 dtype (\".concat(a.dtype, \") is not supported by pow() yet\"));\n    }\n\n    return tfc.pow(x, a);\n  });\n}\n/**\n * Reshapes bias tensor according to rank of x.\n */\n\nfunction reshapeBias(xRank, bias, dataFormat) {\n  var biasShape = bias.shape;\n\n  if (bias.rank !== 1 && bias.rank !== xRank) {\n    throw new ValueError(\"Unexpected bias dimensions: \".concat(bias.rank) + \"; expected it to be 1 or \".concat(xRank));\n  }\n\n  if (xRank === 5) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1, 1, 1]);\n      } else {\n        return bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, 1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank === 4) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1, 1]);\n      } else {\n        return bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank === 3) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1]);\n      } else {\n        return bias.reshape([1, biasShape[1], biasShape[0]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank < 3) {\n    return bias;\n  }\n\n  throw new ValueError(\"Unsupported input rank by biasAdd: \".concat(bias.rank));\n}\n/* Neural-network operations. */\n\n/**\n * Add a bias to a tensor.\n *\n * @param x The tensor to add the bias to.\n * @param bias The bias to add to `x`. Must be 1D or the same rank as `x`.\n * @return Result of the bias adding.\n * @throws ValueError: If the rank of `bias` is incorrect.\n */\n\n\nexport function biasAdd(x, bias, dataFormat) {\n  return tidy(function () {\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    checkDataFormat(dataFormat);\n    return x.add(reshapeBias(x.rank, bias, dataFormat));\n  });\n}\n/**\n * Exponential linear unit (ELU).\n * @param x A tensor or variable to compute the activation function for.\n * @param alpha: A scalar, a scaling factor for the negative section.\n * @return Output of the ELU operation.\n */\n\nexport function elu(x) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  // TODO(cais): Add support for alpha values other than 1.\n  if (alpha !== 1) {\n    throw new NotImplementedError(\"Support for alpha values other than 1 (\".concat(alpha, \") is not implemented \") + \"yet.\");\n  }\n\n  return tfc.elu(x);\n}\n/**\n * Softsign of a tensor.\n *\n * Defined as x / (abs(x) + 1), element-wise.\n *\n * @param x: Input.\n * @returns Output.\n */\n\nexport function softsign(x) {\n  return tidy(function () {\n    return tfc.div(x, tfc.abs(x).add(1));\n  });\n}\n/**\n * Sets entries in `x` to zero at random, while scaling the entire tensor.\n *\n * @param x input tensor.\n * @param level fraction of the entries in the tensor that will be set to 0.\n * @param noiseShape shape of randomly generated keep/drop flags, must be\n *   broadcastable to the shape of `x`. Optional.\n * @param seed random seed to ensure determinism. Optional.\n * @returns Result of the dropout operation.\n */\n\nexport function dropout(x, level, noiseShape, seed) {\n  return tidy(function () {\n    return tfc.dropout(x, level, noiseShape, seed);\n  });\n}\n/**\n * Element-wise, segment-wise linear approximation of sigmoid.\n *\n * Returns `0.` if `x < -2.5`, `1.` if `x > 2.5`.\n * In `-2.5 <= x <= 2.5`, returns `0.2 * x + 0.5`.\n *\n * @param x Input tensor.\n * @returns Output tensor.\n */\n\nexport function hardSigmoid(x) {\n  return tidy(function () {\n    var y = tfc.add(.5, tfc.mul(.2, x));\n    return tfc.clipByValue(y, 0, 1);\n  });\n}\n/**\n * Invoke `x` in the training phase, and `alt` otherwise.\n *\n * Porting Note: We do not create placeholder tensors for the `training`\n * boolean flag here, because there is no such thing in the TF.js imperative\n * backend.\n *\n * @param x The function to invoke iff `training` is `true`.\n * @param alt The function to invoke iff `training` is `false`.\n * @param training Boolean flag for whether training phase is active.\n * @returns The return value of `x()` if `training` is `true`, or the return\n *   value of `alt()` if `training` is `false`.\n */\n\nexport function inTrainPhase(x, alt) {\n  var training = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return training ? x() : alt();\n}","map":null,"metadata":{},"sourceType":"module"}