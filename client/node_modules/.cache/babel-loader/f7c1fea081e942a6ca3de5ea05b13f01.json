{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { reverse } from '../reverse';\nimport { scalar } from '../scalar';\nimport { slice } from '../slice';\nimport { ifft } from './ifft';\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction irfft_(input) {\n  var innerDimensionSize = input.shape[input.shape.length - 1];\n  var batch = input.size / innerDimensionSize;\n  var ret;\n\n  if (innerDimensionSize <= 2) {\n    var complexInput = reshape(input, [batch, innerDimensionSize]);\n    ret = ifft(complexInput);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    var outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    var realInput = reshape(real(input), [batch, innerDimensionSize]);\n    var imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n    var realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n    var imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\n    var r = concat([realInput, realConjugate], 1);\n    var i = concat([imagInput, imagConjugate], 1);\n\n    var _complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n\n    ret = ifft(_complexInput);\n  }\n\n  ret = real(ret); // reshape the result if the input is 3D tensor.\n\n  if (input.rank === 3 && input.shape[0] !== 0) {\n    var temp = ret;\n    var _batch = input.shape[0];\n    ret = reshape(ret, [_batch, ret.shape[0] / _batch, ret.shape[1]]);\n    temp.dispose();\n  }\n\n  return ret;\n}\n\nexport var irfft = op({\n  irfft_: irfft_\n});","map":null,"metadata":{},"sourceType":"module"}