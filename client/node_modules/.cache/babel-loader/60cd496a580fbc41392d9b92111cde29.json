{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isTensor3D, isTensor4D } from '../utils';\n/**\r\n * Extracts the tensors of the image regions containing the detected faces.\r\n * Useful if you want to compute the face descriptors for the face images.\r\n * Using this method is faster then extracting a canvas for each face and\r\n * converting them to tensors individually.\r\n *\r\n * @param imageTensor The image tensor that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns Tensors of the corresponding image region for each detected face.\r\n */\n\nexport function extractFaceTensors(imageTensor, detections) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n        throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\n      }\n\n      if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n        throw new Error('extractFaceTensors - batchSize > 1 not supported');\n      }\n\n      return [2\n      /*return*/\n      , tf.tidy(function () {\n        var _a = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0),\n            imgHeight = _a[0],\n            imgWidth = _a[1],\n            numChannels = _a[2];\n\n        var boxes = detections.map(function (det) {\n          return det instanceof FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;\n        }).map(function (box) {\n          return box.clipAtImageBorders(imgWidth, imgHeight);\n        });\n        var faceTensors = boxes.map(function (_a) {\n          var x = _a.x,\n              y = _a.y,\n              width = _a.width,\n              height = _a.height;\n          return tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);\n        });\n        return faceTensors;\n      })];\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/dom/extractFaceTensors.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAZ,MAAoB,uBAApB;AAGA,SAAS,aAAT,QAA8B,0BAA9B;AACA,SAAS,UAAT,EAAqB,UAArB,QAAuC,UAAvC;AAEA;;;;;;;;;AASG;;AACH,OAAM,SAAgB,kBAAhB,CACJ,WADI,EAEJ,UAFI,EAEmC;;;AAGvC,UAAI,CAAC,UAAU,CAAC,WAAD,CAAX,IAA4B,CAAC,UAAU,CAAC,WAAD,CAA3C,EAA0D;AACxD,cAAM,IAAI,KAAJ,CAAU,2DAAV,CAAN;AACD;;AAED,UAAI,UAAU,CAAC,WAAD,CAAV,IAA2B,WAAW,CAAC,KAAZ,CAAkB,CAAlB,IAAuB,CAAtD,EAAyD;AACvD,cAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,aAAA,CAAA;AAAA;AAAA,QAAO,EAAE,CAAC,IAAH,CAAQ,YAAA;AACP,YAAA,EAAA,GAAA,WAAA,CAAA,KAAA,CAAA,KAAA,CAAA,UAAA,CAAA,WAAA,CAAA,GAAA,CAAA,GAAA,CAAA,CAAA;AAAA,YAAC,SAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,YAAY,QAAA,GAAA,EAAA,CAAA,CAAA,CAAZ;AAAA,YAAsB,WAAA,GAAA,EAAA,CAAA,CAAA,CAAtB;;AAEN,YAAM,KAAK,GAAG,UAAU,CAAC,GAAX,CACZ,UAAA,GAAA,EAAG;AAAI,iBAAA,GAAG,YAAY,aAAf,GACH,GAAG,CAAC,OAAJ,CAAY,QAAZ,EAAsB,SAAtB,EAAiC,GAD9B,GAAA,GAAA;AAEA,SAHK,EAKX,GALW,CAKP,UAAA,GAAA,EAAG;AAAI,iBAAA,GAAG,CAAC,kBAAJ,CAAuB,QAAvB,EAAA,SAAA,CAAA;AAA2C,SAL3C,CAAd;AAOA,YAAM,WAAW,GAAG,KAAK,CAAC,GAAN,CAAU,UAAC,EAAD,EAAwB;cAArB,CAAA,GAAA,EAAA,CAAA,C;cAAG,CAAA,GAAA,EAAA,CAAA,C;cAAG,KAAA,GAAA,EAAA,CAAA,K;cAAO,MAAA,GAAA,EAAA,CAAA,M;AAC5C,iBAAA,EAAE,CAAC,OAAH,CAAW,WAAW,CAAC,IAAZ,CAAiB,SAAjB,EAA4B,QAA5B,EAAsC,WAAtC,CAAX,EAA+D,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAA/D,EAA0E,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAhB,CAA1E,CAAA;AAAuG,SADrF,CAApB;AAIA,eAAO,WAAP;AACD,OAfM,CAAP,CAAA;;;AAgBD","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { isTensor3D, isTensor4D } from '../utils';\r\n/**\r\n * Extracts the tensors of the image regions containing the detected faces.\r\n * Useful if you want to compute the face descriptors for the face images.\r\n * Using this method is faster then extracting a canvas for each face and\r\n * converting them to tensors individually.\r\n *\r\n * @param imageTensor The image tensor that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns Tensors of the corresponding image region for each detected face.\r\n */\r\nexport function extractFaceTensors(imageTensor, detections) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\r\n                throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\r\n            }\r\n            if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\r\n                throw new Error('extractFaceTensors - batchSize > 1 not supported');\r\n            }\r\n            return [2 /*return*/, tf.tidy(function () {\r\n                    var _a = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0), imgHeight = _a[0], imgWidth = _a[1], numChannels = _a[2];\r\n                    var boxes = detections.map(function (det) { return det instanceof FaceDetection\r\n                        ? det.forSize(imgWidth, imgHeight).box\r\n                        : det; })\r\n                        .map(function (box) { return box.clipAtImageBorders(imgWidth, imgHeight); });\r\n                    var faceTensors = boxes.map(function (_a) {\r\n                        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n                        return tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);\r\n                    });\r\n                    return faceTensors;\r\n                })];\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=extractFaceTensors.js.map"]},"metadata":{},"sourceType":"module"}