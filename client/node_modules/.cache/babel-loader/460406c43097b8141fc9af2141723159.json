{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops';\nimport { convDown } from './convLayer';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { residual, residualDown } from './residualLayer';\n\nvar FaceRecognitionNet =\n/** @class */\nfunction (_super) {\n  __extends(FaceRecognitionNet, _super);\n\n  function FaceRecognitionNet() {\n    return _super.call(this, 'FaceRecognitionNet') || this;\n  }\n\n  FaceRecognitionNet.prototype.forwardInput = function (input) {\n    var params = this.params;\n\n    if (!params) {\n      throw new Error('FaceRecognitionNet - load model before inference');\n    }\n\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(150, true).toFloat();\n      var meanRgb = [122.782, 117.001, 104.298];\n      var normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256));\n      var out = convDown(normalized, params.conv32_down);\n      out = tf.maxPool(out, 3, 2, 'valid');\n      out = residual(out, params.conv32_1);\n      out = residual(out, params.conv32_2);\n      out = residual(out, params.conv32_3);\n      out = residualDown(out, params.conv64_down);\n      out = residual(out, params.conv64_1);\n      out = residual(out, params.conv64_2);\n      out = residual(out, params.conv64_3);\n      out = residualDown(out, params.conv128_down);\n      out = residual(out, params.conv128_1);\n      out = residual(out, params.conv128_2);\n      out = residualDown(out, params.conv256_down);\n      out = residual(out, params.conv256_1);\n      out = residual(out, params.conv256_2);\n      out = residualDown(out, params.conv256_down_out);\n      var globalAvg = out.mean([1, 2]);\n      var fullyConnected = tf.matMul(globalAvg, params.fc);\n      return fullyConnected;\n    });\n  };\n\n  FaceRecognitionNet.prototype.forward = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var netInput, faceDescriptorTensors, faceDescriptorsForBatch;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _a.sent();\n            faceDescriptorTensors = tf.tidy(function () {\n              return tf.unstack(_this.forwardInput(netInput));\n            });\n            return [4\n            /*yield*/\n            , Promise.all(faceDescriptorTensors.map(function (t) {\n              return t.data();\n            }))];\n\n          case 2:\n            faceDescriptorsForBatch = _a.sent();\n            faceDescriptorTensors.forEach(function (t) {\n              return t.dispose();\n            });\n            return [2\n            /*return*/\n            , netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0]];\n        }\n      });\n    });\n  };\n\n  FaceRecognitionNet.prototype.getDefaultModelName = function () {\n    return 'face_recognition_model';\n  };\n\n  FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  };\n\n  FaceRecognitionNet.prototype.extractParams = function (weights) {\n    return extractParams(weights);\n  };\n\n  return FaceRecognitionNet;\n}(NeuralNetwork);\n\nexport { FaceRecognitionNet };","map":{"version":3,"sources":["../../../src/faceRecognitionNet/FaceRecognitionNet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { toNetInput } from '../dom';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { normalize } from '../ops';\r\nimport { convDown } from './convLayer';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\r\nimport { residual, residualDown } from './residualLayer';\r\nvar FaceRecognitionNet = /** @class */ (function (_super) {\r\n    __extends(FaceRecognitionNet, _super);\r\n    function FaceRecognitionNet() {\r\n        return _super.call(this, 'FaceRecognitionNet') || this;\r\n    }\r\n    FaceRecognitionNet.prototype.forwardInput = function (input) {\r\n        var params = this.params;\r\n        if (!params) {\r\n            throw new Error('FaceRecognitionNet - load model before inference');\r\n        }\r\n        return tf.tidy(function () {\r\n            var batchTensor = input.toBatchTensor(150, true).toFloat();\r\n            var meanRgb = [122.782, 117.001, 104.298];\r\n            var normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256));\r\n            var out = convDown(normalized, params.conv32_down);\r\n            out = tf.maxPool(out, 3, 2, 'valid');\r\n            out = residual(out, params.conv32_1);\r\n            out = residual(out, params.conv32_2);\r\n            out = residual(out, params.conv32_3);\r\n            out = residualDown(out, params.conv64_down);\r\n            out = residual(out, params.conv64_1);\r\n            out = residual(out, params.conv64_2);\r\n            out = residual(out, params.conv64_3);\r\n            out = residualDown(out, params.conv128_down);\r\n            out = residual(out, params.conv128_1);\r\n            out = residual(out, params.conv128_2);\r\n            out = residualDown(out, params.conv256_down);\r\n            out = residual(out, params.conv256_1);\r\n            out = residual(out, params.conv256_2);\r\n            out = residualDown(out, params.conv256_down_out);\r\n            var globalAvg = out.mean([1, 2]);\r\n            var fullyConnected = tf.matMul(globalAvg, params.fc);\r\n            return fullyConnected;\r\n        });\r\n    };\r\n    FaceRecognitionNet.prototype.forward = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var netInput, faceDescriptorTensors, faceDescriptorsForBatch;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _a.sent();\r\n                        faceDescriptorTensors = tf.tidy(function () { return tf.unstack(_this.forwardInput(netInput)); });\r\n                        return [4 /*yield*/, Promise.all(faceDescriptorTensors.map(function (t) { return t.data(); }))];\r\n                    case 2:\r\n                        faceDescriptorsForBatch = _a.sent();\r\n                        faceDescriptorTensors.forEach(function (t) { return t.dispose(); });\r\n                        return [2 /*return*/, netInput.isBatchInput\r\n                                ? faceDescriptorsForBatch\r\n                                : faceDescriptorsForBatch[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceRecognitionNet.prototype.getDefaultModelName = function () {\r\n        return 'face_recognition_model';\r\n    };\r\n    FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {\r\n        return extractParamsFromWeigthMap(weightMap);\r\n    };\r\n    FaceRecognitionNet.prototype.extractParams = function (weights) {\r\n        return extractParams(weights);\r\n    };\r\n    return FaceRecognitionNet;\r\n}(NeuralNetwork));\r\nexport { FaceRecognitionNet };\r\n//# sourceMappingURL=FaceRecognitionNet.js.map"]},"metadata":{},"sourceType":"module"}