{"ast":null,"code":"'use strict';\n\nvar Plumbing = require('./plumbing.js');\n\nvar hasUnicode = require('has-unicode');\n\nvar hasColor = require('./has-color.js');\n\nvar onExit = require('signal-exit');\n\nvar defaultThemes = require('./themes');\n\nvar setInterval = require('./set-interval.js');\n\nvar process = require('./process.js');\n\nvar setImmediate = require('./set-immediate');\n\nmodule.exports = Gauge;\n\nfunction callWith(obj, method) {\n  return function () {\n    return method.call(obj);\n  };\n}\n\nfunction Gauge(arg1, arg2) {\n  var options, writeTo;\n\n  if (arg1 && arg1.write) {\n    writeTo = arg1;\n    options = arg2 || {};\n  } else if (arg2 && arg2.write) {\n    writeTo = arg2;\n    options = arg1 || {};\n  } else {\n    writeTo = process.stderr;\n    options = arg1 || arg2 || {};\n  }\n\n  this._status = {\n    spun: 0,\n    section: '',\n    subsection: ''\n  };\n  this._paused = false; // are we paused for back pressure?\n\n  this._disabled = true; // are all progress bar updates disabled?\n\n  this._showing = false; // do we WANT the progress bar on screen\n\n  this._onScreen = false; // IS the progress bar on screen\n\n  this._needsRedraw = false; // should we print something at next tick?\n\n  this._hideCursor = options.hideCursor == null ? true : options.hideCursor;\n  this._fixedFramerate = options.fixedFramerate == null ? !/^v0\\.8\\./.test(process.version) : options.fixedFramerate;\n  this._lastUpdateAt = null;\n  this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval;\n  this._themes = options.themes || defaultThemes;\n  this._theme = options.theme;\n\n  var theme = this._computeTheme(options.theme);\n\n  var template = options.template || [{\n    type: 'progressbar',\n    length: 20\n  }, {\n    type: 'activityIndicator',\n    kerning: 1,\n    length: 1\n  }, {\n    type: 'section',\n    kerning: 1,\n    default: ''\n  }, {\n    type: 'subsection',\n    kerning: 1,\n    default: ''\n  }];\n  this.setWriteTo(writeTo, options.tty);\n  var PlumbingClass = options.Plumbing || Plumbing;\n  this._gauge = new PlumbingClass(theme, template, this.getWidth());\n  this._$$doRedraw = callWith(this, this._doRedraw);\n  this._$$handleSizeChange = callWith(this, this._handleSizeChange);\n  this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit;\n  this._removeOnExit = null;\n\n  if (options.enabled || options.enabled == null && this._tty && this._tty.isTTY) {\n    this.enable();\n  } else {\n    this.disable();\n  }\n}\n\nGauge.prototype = {};\n\nGauge.prototype.isEnabled = function () {\n  return !this._disabled;\n};\n\nGauge.prototype.setTemplate = function (template) {\n  this._gauge.setTemplate(template);\n\n  if (this._showing) this._requestRedraw();\n};\n\nGauge.prototype._computeTheme = function (theme) {\n  if (!theme) theme = {};\n\n  if (typeof theme === 'string') {\n    theme = this._themes.getTheme(theme);\n  } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {\n    var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;\n    var useColor = theme.hasColor == null ? hasColor : theme.hasColor;\n    theme = this._themes.getDefault({\n      hasUnicode: useUnicode,\n      hasColor: useColor,\n      platform: theme.platform\n    });\n  }\n\n  return theme;\n};\n\nGauge.prototype.setThemeset = function (themes) {\n  this._themes = themes;\n  this.setTheme(this._theme);\n};\n\nGauge.prototype.setTheme = function (theme) {\n  this._gauge.setTheme(this._computeTheme(theme));\n\n  if (this._showing) this._requestRedraw();\n  this._theme = theme;\n};\n\nGauge.prototype._requestRedraw = function () {\n  this._needsRedraw = true;\n  if (!this._fixedFramerate) this._doRedraw();\n};\n\nGauge.prototype.getWidth = function () {\n  return (this._tty && this._tty.columns || 80) - 1;\n};\n\nGauge.prototype.setWriteTo = function (writeTo, tty) {\n  var enabled = !this._disabled;\n  if (enabled) this.disable();\n  this._writeTo = writeTo;\n  this._tty = tty || writeTo === process.stderr && process.stdout.isTTY && process.stdout || writeTo.isTTY && writeTo || this._tty;\n  if (this._gauge) this._gauge.setWidth(this.getWidth());\n  if (enabled) this.enable();\n};\n\nGauge.prototype.enable = function () {\n  if (!this._disabled) return;\n  this._disabled = false;\n  if (this._tty) this._enableEvents();\n  if (this._showing) this.show();\n};\n\nGauge.prototype.disable = function () {\n  if (this._disabled) return;\n\n  if (this._showing) {\n    this._lastUpdateAt = null;\n    this._showing = false;\n\n    this._doRedraw();\n\n    this._showing = true;\n  }\n\n  this._disabled = true;\n  if (this._tty) this._disableEvents();\n};\n\nGauge.prototype._enableEvents = function () {\n  if (this._cleanupOnExit) {\n    this._removeOnExit = onExit(callWith(this, this.disable));\n  }\n\n  this._tty.on('resize', this._$$handleSizeChange);\n\n  if (this._fixedFramerate) {\n    this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval);\n    if (this.redrawTracker.unref) this.redrawTracker.unref();\n  }\n};\n\nGauge.prototype._disableEvents = function () {\n  this._tty.removeListener('resize', this._$$handleSizeChange);\n\n  if (this._fixedFramerate) clearInterval(this.redrawTracker);\n  if (this._removeOnExit) this._removeOnExit();\n};\n\nGauge.prototype.hide = function (cb) {\n  if (this._disabled) return cb && process.nextTick(cb);\n  if (!this._showing) return cb && process.nextTick(cb);\n  this._showing = false;\n\n  this._doRedraw();\n\n  cb && setImmediate(cb);\n};\n\nGauge.prototype.show = function (section, completed) {\n  this._showing = true;\n\n  if (typeof section === 'string') {\n    this._status.section = section;\n  } else if (typeof section === 'object') {\n    var sectionKeys = Object.keys(section);\n\n    for (var ii = 0; ii < sectionKeys.length; ++ii) {\n      var key = sectionKeys[ii];\n      this._status[key] = section[key];\n    }\n  }\n\n  if (completed != null) this._status.completed = completed;\n  if (this._disabled) return;\n\n  this._requestRedraw();\n};\n\nGauge.prototype.pulse = function (subsection) {\n  this._status.subsection = subsection || '';\n  this._status.spun++;\n  if (this._disabled) return;\n  if (!this._showing) return;\n\n  this._requestRedraw();\n};\n\nGauge.prototype._handleSizeChange = function () {\n  this._gauge.setWidth(this._tty.columns - 1);\n\n  this._requestRedraw();\n};\n\nGauge.prototype._doRedraw = function () {\n  if (this._disabled || this._paused) return;\n\n  if (!this._fixedFramerate) {\n    var now = Date.now();\n    if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return;\n    this._lastUpdateAt = now;\n  }\n\n  if (!this._showing && this._onScreen) {\n    this._onScreen = false;\n\n    var result = this._gauge.hide();\n\n    if (this._hideCursor) {\n      result += this._gauge.showCursor();\n    }\n\n    return this._writeTo.write(result);\n  }\n\n  if (!this._showing && !this._onScreen) return;\n\n  if (this._showing && !this._onScreen) {\n    this._onScreen = true;\n    this._needsRedraw = true;\n\n    if (this._hideCursor) {\n      this._writeTo.write(this._gauge.hideCursor());\n    }\n  }\n\n  if (!this._needsRedraw) return;\n\n  if (!this._writeTo.write(this._gauge.show(this._status))) {\n    this._paused = true;\n\n    this._writeTo.on('drain', callWith(this, function () {\n      this._paused = false;\n\n      this._doRedraw();\n    }));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}