{"ast":null,"code":"//////////////////////////////////////////\n// Defines mappings between content-type\n// and the appropriate parsers.\n//////////////////////////////////////////\nvar Transform = require('stream').Transform;\n\nvar sax = require('sax');\n\nfunction parseXML(str, cb) {\n  var obj,\n      current,\n      parser = sax.parser(true, {\n    trim: true,\n    lowercase: true\n  });\n  parser.onerror = parser.onend = done;\n\n  function done(err) {\n    parser.onerror = parser.onend = function () {};\n\n    cb(err, obj);\n  }\n\n  function newElement(name, attributes) {\n    return {\n      name: name || '',\n      value: '',\n      attributes: attributes || {},\n      children: []\n    };\n  }\n\n  parser.oncdata = parser.ontext = function (t) {\n    if (current) current.value += t;\n  };\n\n  parser.onopentag = function (node) {\n    var element = newElement(node.name, node.attributes);\n\n    if (current) {\n      element.parent = current;\n      current.children.push(element);\n    } else {\n      // root object\n      obj = element;\n    }\n\n    current = element;\n  };\n\n  parser.onclosetag = function () {\n    if (typeof current.parent !== 'undefined') {\n      var just_closed = current;\n      current = current.parent;\n      delete just_closed.parent;\n    }\n  };\n\n  parser.write(str).close();\n}\n\nfunction parserFactory(name, fn) {\n  function parser() {\n    var chunks = [],\n        stream = new Transform({\n      objectMode: true\n    }); // Buffer all our data\n\n    stream._transform = function (chunk, encoding, done) {\n      chunks.push(chunk);\n      done();\n    }; // And call the parser when all is there.\n\n\n    stream._flush = function (done) {\n      var self = this,\n          data = Buffer.concat(chunks);\n\n      try {\n        fn(data, function (err, result) {\n          if (err) throw err;\n          self.push(result);\n        });\n      } catch (err) {\n        self.push(data); // just pass the original data\n      } finally {\n        done();\n      }\n    };\n\n    return stream;\n  }\n\n  return {\n    fn: parser,\n    name: name\n  };\n}\n\nvar parsers = {};\n\nfunction buildParser(name, types, fn) {\n  var parser = parserFactory(name, fn);\n  types.forEach(function (type) {\n    parsers[type] = parser;\n  });\n}\n\nbuildParser('json', ['application/json', 'text/javascript'], function (buffer, cb) {\n  var err, data;\n\n  try {\n    data = JSON.parse(buffer);\n  } catch (e) {\n    err = e;\n  }\n\n  cb(err, data);\n});\nbuildParser('xml', ['text/xml', 'application/xml', 'application/rdf+xml', 'application/rss+xml', 'application/atom+xml'], function (buffer, cb) {\n  parseXML(buffer.toString(), function (err, obj) {\n    cb(err, obj);\n  });\n});\nmodule.exports = parsers;\nmodule.exports.use = buildParser;","map":null,"metadata":{},"sourceType":"script"}