{"ast":null,"code":"module.exports = exports = abbrev.abbrev = abbrev;\nabbrev.monkeyPatch = monkeyPatch;\n\nfunction monkeyPatch() {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function value() {\n      return abbrev(this);\n    },\n    enumerable: false,\n    configurable: true,\n    writable: true\n  });\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function value() {\n      return abbrev(Object.keys(this));\n    },\n    enumerable: false,\n    configurable: true,\n    writable: true\n  });\n}\n\nfunction abbrev(list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0);\n  }\n\n  for (var i = 0, l = list.length, args = []; i < l; i++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i]);\n  } // sort them lexicographically, so that they're next to their nearest kin\n\n\n  args = args.sort(lexSort); // walk through each, seeing how much it has in common with the next and previous\n\n  var abbrevs = {},\n      prev = \"\";\n\n  for (var i = 0, l = args.length; i < l; i++) {\n    var current = args[i],\n        next = args[i + 1] || \"\",\n        nextMatches = true,\n        prevMatches = true;\n    if (current === next) continue;\n\n    for (var j = 0, cl = current.length; j < cl; j++) {\n      var curChar = current.charAt(j);\n      nextMatches = nextMatches && curChar === next.charAt(j);\n      prevMatches = prevMatches && curChar === prev.charAt(j);\n\n      if (!nextMatches && !prevMatches) {\n        j++;\n        break;\n      }\n    }\n\n    prev = current;\n\n    if (j === cl) {\n      abbrevs[current] = current;\n      continue;\n    }\n\n    for (var a = current.substr(0, j); j <= cl; j++) {\n      abbrevs[a] = current;\n      a += current.charAt(j);\n    }\n  }\n\n  return abbrevs;\n}\n\nfunction lexSort(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}","map":null,"metadata":{},"sourceType":"script"}