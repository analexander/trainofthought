{"ast":null,"code":"import _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\n\nexport function printSummary(model, lineLength, positions) {\n  var printFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;\n  var sequentialLike = isModelSequentialLike(model); // Header names for different log elements.\n\n  var toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n\n  if (sequentialLike) {\n    lineLength = lineLength || 65;\n    positions = positions || [0.45, 0.85, 1];\n  } else {\n    lineLength = lineLength || 98;\n    positions = positions || [0.33, 0.55, 0.67, 1]; // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(function (p) {\n      return Math.floor(lineLength * p);\n    });\n  }\n\n  var relevantNodes;\n\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n\n    for (var depth in model.nodesByDepth) {\n      var _relevantNodes;\n\n      (_relevantNodes = relevantNodes).push.apply(_relevantNodes, _toConsumableArray(model.nodesByDepth[depth]));\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  var layers = model.layers;\n\n  for (var i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  } // tslint:disable-next-line:no-any\n\n\n  model.checkTrainableWeightsConsistency();\n  var trainableCount = countTrainableParams(model);\n  var nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(\"Total params: \".concat(trainableCount + nonTrainableCount));\n  printFn(\"Trainable params: \".concat(trainableCount));\n  printFn(\"Non-trainable params: \".concat(nonTrainableCount));\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model) {\n  var trainableCount; // tslint:disable:no-any\n\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  } // tslint:enable:no-any\n\n\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model) {\n  var sequentialLike = true;\n  var nodesByDepth = [];\n  var nodes = [];\n\n  for (var depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n\n  for (var _i = 0, _nodesByDepth = nodesByDepth; _i < _nodesByDepth.length; _i++) {\n    var depthNodes = _nodesByDepth[_i];\n\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n\n    nodes.push.apply(nodes, _toConsumableArray(depthNodes));\n  }\n\n  if (sequentialLike) {\n    // Search for shared layers.\n    var _iterator = _createForOfIteratorHelper(model.layers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var layer = _step.value;\n        var flag = false;\n\n        var _iterator2 = _createForOfIteratorHelper(layer.inboundNodes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var node = _step2.value;\n\n            if (nodes.indexOf(node) !== -1) {\n              if (flag) {\n                sequentialLike = false;\n                break;\n              } else {\n                flag = true;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!sequentialLike) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return sequentialLike;\n}\n\nfunction printRow(fields, positions) {\n  var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n  var line = '';\n\n  for (var i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n\n  printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\n\n\nfunction printLayerSummary(layer, positions, // tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  var name = layer.name;\n  var className = layer.getClassName();\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\n\n\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, // tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  var connections = [];\n\n  var _iterator3 = _createForOfIteratorHelper(layer.inboundNodes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var node = _step3.value;\n\n      if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n        continue;\n      }\n\n      for (var _i2 = 0; _i2 < node.inboundLayers.length; ++_i2) {\n        var inboundLayer = node.inboundLayers[_i2].name;\n        var inboundLayerIndex = node.nodeIndices[_i2];\n        var inboundTensorIndex = node.tensorIndices[_i2];\n        connections.push(\"\".concat(inboundLayer, \"[\").concat(inboundLayerIndex, \"][\").concat(inboundTensorIndex, \"]\"));\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var name = layer.name;\n  var className = layer.getClassName();\n  var firstConnection = connections.length === 0 ? '' : connections[0];\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n\n  for (var i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', connections[i]], positions, printFn);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}