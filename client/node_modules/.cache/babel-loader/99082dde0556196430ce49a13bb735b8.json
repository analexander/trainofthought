{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\n\nvar util_1 = require(\"util\");\n\nvar int64_tensors_1 = require(\"./int64_tensors\");\n\nvar NodeJSKernelBackend =\n/** @class */\nfunction (_super) {\n  __extends(NodeJSKernelBackend, _super);\n\n  function NodeJSKernelBackend(binding, packageName) {\n    var _this = _super.call(this) || this;\n\n    _this.binding = binding;\n    _this.isGPUPackage = packageName === '@tensorflow/tfjs-node-gpu';\n    _this.isUsingGpuDevice = _this.binding.isUsingGpuDevice();\n    _this.tensorMap = new tf.DataStorage(_this, tf.engine());\n    return _this;\n  }\n\n  NodeJSKernelBackend.prototype.getDTypeInteger = function (dtype) {\n    switch (dtype) {\n      case 'float32':\n        return this.binding.TF_FLOAT;\n\n      case 'int32':\n        return this.binding.TF_INT32;\n\n      case 'bool':\n        return this.binding.TF_BOOL;\n\n      case 'complex64':\n        return this.binding.TF_COMPLEX64;\n\n      case 'string':\n        return this.binding.TF_STRING;\n\n      default:\n        throw new Error(\"Unsupported DType: \" + dtype);\n    }\n  };\n\n  NodeJSKernelBackend.prototype.typeAttributeFromTensor = function (value) {\n    return this.getDTypeInteger(value.dtype);\n  }; // Creates a new Tensor and maps the dataId to the passed in ID.\n\n\n  NodeJSKernelBackend.prototype.createOutputTensor = function (metadata) {\n    var newId = {};\n    this.tensorMap.set(newId, {\n      shape: metadata.shape,\n      dtype: metadata.dtype,\n      id: metadata.id,\n      values: null\n    });\n    var dtype;\n\n    switch (metadata.dtype) {\n      case this.binding.TF_FLOAT:\n        dtype = 'float32';\n        break;\n\n      case this.binding.TF_INT32:\n        dtype = 'int32';\n        break;\n\n      case this.binding.TF_BOOL:\n        dtype = 'bool';\n        break;\n\n      case this.binding.TF_COMPLEX64:\n        dtype = 'complex64';\n        break;\n\n      case this.binding.TF_STRING:\n        dtype = 'string';\n        break;\n\n      case this.binding.TF_RESOURCE:\n        // NOTE(cais): We currently represent resource-type Tensors\n        // as string of ubytes.\n        dtype = 'string';\n        break;\n\n      case this.binding.TF_UINT8:\n        // TensorFlow uses UINT8 as dtype for image tensor. UINT8 is not\n        // supported in TFJS yet, cast it to int32.\n        dtype = 'int32';\n        break;\n\n      default:\n        throw new Error(\"Unknown dtype enum \" + metadata.dtype);\n    }\n\n    return tf.engine().makeTensorFromDataId(newId, metadata.shape, dtype);\n  }; // Prepares Tensor instances for Op execution.\n\n\n  NodeJSKernelBackend.prototype.getInputTensorIds = function (tensors) {\n    var ids = [];\n\n    for (var i = 0; i < tensors.length; i++) {\n      if (tensors[i] instanceof int64_tensors_1.Int64Scalar) {\n        // Then `tensors[i]` is a Int64Scalar, which we currently represent\n        // using an `Int32Array`.\n        var value = tensors[i].valueArray;\n        var id = this.binding.createTensor([], this.binding.TF_INT64, value);\n        ids.push(id);\n      } else {\n        var info = this.tensorMap.get(tensors[i].dataId); // TODO - what about ID in this case? Handle in write()??\n\n        if (info.values != null) {\n          // Values were delayed to write into the TensorHandle. Do that before\n          // Op execution and clear stored values.\n          info.id = this.binding.createTensor(info.shape, info.dtype, info.values);\n          info.values = null;\n        }\n\n        ids.push(info.id);\n      }\n    }\n\n    return ids;\n  };\n\n  NodeJSKernelBackend.prototype.createReductionOpAttrs = function (tensor, keepDims) {\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    return [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: keepDims\n    }, createTensorsTypeOpAttr('T', tensor.dtype), createTensorsTypeOpAttr('Tidx', 'int32')];\n  };\n\n  NodeJSKernelBackend.prototype.floatPrecision = function () {\n    return 32;\n  };\n\n  NodeJSKernelBackend.prototype.epsilon = function () {\n    return _super.prototype.epsilon.call(this);\n  };\n  /**\n   * Executes an op that has a single input and output.\n   *\n   * Helper function to wrap executeSingleOutput in a particular case.\n   * @param name The name of the Op to execute.\n   * @param input The input Tensor for the Op.\n   */\n\n\n  NodeJSKernelBackend.prototype.executeSingleInput = function (name, input) {\n    var opAttrs = [createTensorsTypeOpAttr('T', input.dtype)];\n    return this.executeSingleOutput(name, opAttrs, [input]);\n  };\n  /**\n   * Executes a TensorFlow Eager Op that provides one output Tensor.\n   * @param name The name of the Op to execute.\n   * @param opAttrs The list of Op attributes required to execute.\n   * @param inputs The list of input Tensors for the Op.\n   * @return A resulting Tensor from Op execution.\n   */\n\n\n  NodeJSKernelBackend.prototype.executeSingleOutput = function (name, opAttrs, inputs) {\n    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), 1);\n    return this.createOutputTensor(outputMetadata[0]);\n  };\n  /**\n   * Executes a TensorFlow Eager Op that provides multiple output Tensors.\n   * @param name The name of the Op to execute.\n   * @param opAttrs The list of Op attributes required to execute.\n   * @param inputs The list of input Tensors for the Op.\n   * @param numOutputs The number of output Tensors for Op execution.\n   * @return A resulting Tensor array from Op execution.\n   */\n\n\n  NodeJSKernelBackend.prototype.executeMultipleOutputs = function (name, opAttrs, inputs, numOutputs) {\n    var _this = this;\n\n    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), numOutputs);\n    return outputMetadata.map(function (m) {\n      return _this.createOutputTensor(m);\n    });\n  };\n\n  NodeJSKernelBackend.prototype.numDataIds = function () {\n    return this.tensorMap.numDataIds();\n  };\n\n  NodeJSKernelBackend.prototype.dispose = function () {};\n\n  NodeJSKernelBackend.prototype.read = function (dataId) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.readSync(dataId)];\n      });\n    });\n  };\n\n  NodeJSKernelBackend.prototype.readSync = function (dataId) {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(\"Tensor \" + dataId + \" was not registered!\");\n    }\n\n    var info = this.tensorMap.get(dataId);\n\n    if (info.values != null) {\n      return info.values;\n    } else {\n      return this.binding.tensorDataSync(info.id);\n    }\n  };\n\n  NodeJSKernelBackend.prototype.disposeData = function (dataId) {\n    // No-op if already disposed.\n    if (!this.tensorMap.has(dataId)) {\n      return;\n    }\n\n    var id = this.tensorMap.get(dataId).id;\n\n    if (id != null && id >= 0) {\n      this.binding.deleteTensor(id);\n    }\n\n    this.tensorMap.delete(dataId);\n  };\n\n  NodeJSKernelBackend.prototype.move = function (dataId, values, shape, dtype) {\n    this.tensorMap.set(dataId, {\n      shape: shape,\n      dtype: getTFDType(dtype),\n      values: values,\n      id: -1\n    });\n  };\n\n  NodeJSKernelBackend.prototype.write = function (values, shape, dtype) {\n    var dataId = {};\n    this.move(dataId, values, shape, dtype);\n    return dataId;\n  };\n\n  NodeJSKernelBackend.prototype.fill = function (shape, value, dtype) {\n    // TODO(cais, nkreeger): Investigate whether this can be made into\n    // a dtype helper method. The underlying op kernel doesn't accept undefined\n    // or null dtype.\n    if (dtype == null) {\n      if (typeof value === 'number') {\n        dtype = 'float32';\n      } else {\n        dtype = 'string';\n      }\n    }\n\n    var shapeTensor = tfjs_1.tensor1d(shape, 'int32');\n    var valueTensor = tfjs_1.scalar(value, dtype);\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(dtype)\n    }, {\n      name: 'index_type',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }];\n    return this.executeSingleOutput('Fill', opAttrs, [shapeTensor, valueTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.onesLike = function (x) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(x.dtype)\n    }];\n    return this.executeSingleOutput('OnesLike', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.zerosLike = function (x) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(x.dtype)\n    }];\n    return this.executeSingleOutput('ZerosLike', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.stridedSlice = function (x, begin, end, strides) {\n    var beginTensor = tfjs_1.tensor1d(begin, 'int32');\n\n    for (var axis = 0; axis < end.length; axis++) {\n      // Unlike Numpy, when the strides are negative, TF C uses -n-1 instead of\n      // -1 as the \"end\" in order to include the first element.\n      if (strides[axis] < 0 && end[axis] === -1) {\n        end[axis] -= x.shape[axis];\n      }\n    }\n\n    var endTensor = tfjs_1.tensor1d(end, 'int32');\n    var stridesTensor = tfjs_1.tensor1d(strides, 'int32'); // All of the masks have already been accounted for in the high level op,\n    // so the backend does NOT need to deal with masks.\n\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Index', 'int32'), {\n      name: 'begin_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: 0\n    }, {\n      name: 'end_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: 0\n    }, {\n      name: 'ellipsis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: 0\n    }, {\n      name: 'new_axis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: 0\n    }, {\n      name: 'shrink_axis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: 0\n    }];\n    return this.executeSingleOutput('StridedSlice', opAttrs, [x, beginTensor, endTensor, stridesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.unstack = function (x, axis) {\n    if (axis >= x.shape.length) {\n      throw new Error(\"Invalid axis supplied: \" + axis + \" shape length: \" + x.shape.length);\n    }\n\n    var num = x.shape[axis];\n    var opAttrs = [{\n      name: 'num',\n      type: this.binding.TF_ATTR_INT,\n      value: num\n    }, createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'axis',\n      type: this.binding.TF_ATTR_INT,\n      value: axis\n    }];\n    return this.executeMultipleOutputs('Unpack', opAttrs, [x], num);\n  };\n\n  NodeJSKernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {\n    var opAttrs = [createTensorsTypeOpAttr('T', a.dtype), {\n      name: 'adj_x',\n      type: this.binding.TF_ATTR_BOOL,\n      value: transposeA\n    }, {\n      name: 'adj_y',\n      type: this.binding.TF_ATTR_BOOL,\n      value: transposeB\n    }];\n    return this.executeSingleOutput('BatchMatMul', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.applyActivation = function (input, activation, preluActivationWeights) {\n    var result = input;\n\n    if (activation != null) {\n      if (activation === 'linear') {// No-op\n      } else if (activation === 'relu') {\n        result = this.relu(result);\n      } else if (activation === 'prelu') {\n        result = this.prelu(result, preluActivationWeights);\n      } else if (activation === 'elu') {\n        result = this.elu(result);\n      } else if (activation === 'relu6') {\n        result = this.relu6(result);\n      } else {\n        throw new Error(\"Activation: \" + activation + \" has not been implemented for the Node.js backend\");\n      }\n    }\n\n    return result;\n  };\n\n  NodeJSKernelBackend.prototype.fusedConv2d = function (_a) {\n    var input = _a.input,\n        filter = _a.filter,\n        convInfo = _a.convInfo,\n        bias = _a.bias,\n        activation = _a.activation,\n        preluActivationWeights = _a.preluActivationWeights;\n    var result = this.conv2d(input, filter, convInfo);\n\n    if (bias != null) {\n      result = tf.add(result, bias);\n    }\n\n    result = this.applyActivation(result, activation, preluActivationWeights);\n    return result;\n  };\n\n  NodeJSKernelBackend.prototype.fusedBatchMatMul = function (_a) {\n    var a = _a.a,\n        b = _a.b,\n        transposeA = _a.transposeA,\n        transposeB = _a.transposeB,\n        bias = _a.bias,\n        activation = _a.activation,\n        preluActivationWeights = _a.preluActivationWeights; // Core TensorFlow does not have a fused BatchMatMul op. Combine calls to\n    // achieve the same results:\n\n    var result = this.batchMatMul(a, b, transposeA, transposeB);\n\n    if (bias != null) {\n      result = tf.add(result, bias);\n    }\n\n    result = this.applyActivation(result, activation, preluActivationWeights);\n    return result;\n  };\n\n  NodeJSKernelBackend.prototype.slice = function (x, begin, size) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Index', 'int32')]; // Bind tensor values\n\n    var beginTensor = tfjs_1.tensor1d(begin, 'int32');\n    var sizeTensor = tfjs_1.tensor1d(size, 'int32');\n    return this.executeSingleOutput('Slice', opAttrs, [x, beginTensor, sizeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.reverse = function (a, axis) {\n    var opAttrs = [createTensorsTypeOpAttr('Tidx', 'int32'), createTensorsTypeOpAttr('T', a.dtype)];\n    var axisTensor = tfjs_1.tensor1d(axis, 'int32');\n    return this.executeSingleOutput('ReverseV2', opAttrs, [a, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.concat = function (tensors, axis) {\n    var opAttrs = [{\n      name: 'N',\n      type: this.binding.TF_ATTR_INT,\n      value: tensors.length\n    }, {\n      name: 'Tidx',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }, createTensorsTypeOpAttr('T', tensors)];\n    var inputs = Array.from(tensors);\n    inputs.push(tfjs_1.scalar(axis, 'int32'));\n    return this.executeSingleOutput('ConcatV2', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.neg = function (a) {\n    return this.executeSingleInput('Neg', a);\n  };\n\n  NodeJSKernelBackend.prototype.select = function (condition, a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', tfjs_1.backend_util.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Select', opAttrs, [condition, a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.subtract = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', tfjs_1.backend_util.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Sub', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.realDivide = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', tfjs_1.backend_util.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('RealDiv', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.divide = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', tfjs_1.backend_util.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Div', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.divNoNan = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', tfjs_1.backend_util.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('DivNoNan', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.where = function (condition) {\n    return this.executeSingleOutput('Where', [], [condition]);\n  };\n\n  NodeJSKernelBackend.prototype.topKValues = function (x, k) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.topKIndices = function (x, k) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.topk = function (x, k, sorted) {\n    var kCount = util_1.isNullOrUndefined(k) ? 1 : k;\n    var isSorted = util_1.isNullOrUndefined(sorted) ? true : sorted;\n    var opAttrs = [{\n      name: 'sorted',\n      type: this.binding.TF_ATTR_BOOL,\n      value: isSorted\n    }, createTensorsTypeOpAttr('T', x.dtype)];\n    var kTensor = tfjs_1.scalar(kCount, 'int32'); // 'TopKV2' has two-hard coded output attributes:\n\n    return this.executeMultipleOutputs('TopKV2', opAttrs, [x, kTensor], 2);\n  };\n\n  NodeJSKernelBackend.prototype.all = function (x, axes) {\n    var opAttrs = [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, createTensorsTypeOpAttr('Tidx', 'int32')];\n    var axesTensor = tfjs_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('All', opAttrs, [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.any = function (x, axes) {\n    var opAttrs = [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, createTensorsTypeOpAttr('Tidx', 'int32')];\n    var axesTensor = tfjs_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('Any', opAttrs, [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.ceil = function (x) {\n    return this.executeSingleInput('Ceil', x);\n  };\n\n  NodeJSKernelBackend.prototype.floor = function (x) {\n    return this.executeSingleInput('Floor', x);\n  };\n\n  NodeJSKernelBackend.prototype.pow = function (a, b) {\n    var dtype = tfjs_1.backend_util.upcastType(a.dtype, b.dtype);\n    var opAttrs = [createTensorsTypeOpAttr('T', dtype)];\n    return this.executeSingleOutput('Pow', opAttrs, [a.cast(dtype), b.cast(dtype)]);\n  };\n\n  NodeJSKernelBackend.prototype.exp = function (x) {\n    var xTensor = x.dtype === 'int32' ? x.toFloat() : x;\n    return this.executeSingleInput('Exp', xTensor);\n  };\n\n  NodeJSKernelBackend.prototype.log = function (x) {\n    return this.executeSingleInput('Log', x);\n  };\n\n  NodeJSKernelBackend.prototype.log1p = function (x) {\n    return this.executeSingleInput('Log1p', x);\n  };\n\n  NodeJSKernelBackend.prototype.sqrt = function (x) {\n    return this.executeSingleInput('Sqrt', x);\n  };\n\n  NodeJSKernelBackend.prototype.square = function (x) {\n    return this.executeSingleInput('Square', x);\n  };\n\n  NodeJSKernelBackend.prototype.relu = function (x) {\n    return this.executeSingleInput('Relu', x);\n  };\n\n  NodeJSKernelBackend.prototype.relu6 = function (x) {\n    return this.executeSingleInput('Relu6', x);\n  };\n\n  NodeJSKernelBackend.prototype.prelu = function (x, a) {\n    var pos = this.relu(x);\n    var neg = a.mul(x.sub(this.abs(x))).mul(0.5);\n    return pos.add(neg);\n  };\n\n  NodeJSKernelBackend.prototype.elu = function (x) {\n    return this.executeSingleInput('Elu', x);\n  };\n\n  NodeJSKernelBackend.prototype.eluDer = function (dy, y) {\n    var opAttrs = [createTensorsTypeOpAttr('T', y.dtype)];\n    return this.executeSingleOutput('EluGrad', opAttrs, [dy, y]);\n  };\n\n  NodeJSKernelBackend.prototype.selu = function (x) {\n    return this.executeSingleInput('Selu', x);\n  };\n\n  NodeJSKernelBackend.prototype.int = function (x) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.clip = function (x, min, max) {\n    var xMin = tf.minimum(x, tfjs_1.scalar(max, x.dtype));\n    return tf.maximum(xMin, tfjs_1.scalar(min, x.dtype));\n  };\n\n  NodeJSKernelBackend.prototype.abs = function (x) {\n    return this.executeSingleInput('Abs', x);\n  };\n\n  NodeJSKernelBackend.prototype.complexAbs = function (x) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tout', 'float32')];\n    return this.executeSingleOutput('ComplexAbs', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.sigmoid = function (x) {\n    return this.executeSingleInput('Sigmoid', x);\n  };\n\n  NodeJSKernelBackend.prototype.sin = function (x) {\n    return this.executeSingleInput('Sin', x);\n  };\n\n  NodeJSKernelBackend.prototype.cos = function (x) {\n    return this.executeSingleInput('Cos', x);\n  };\n\n  NodeJSKernelBackend.prototype.tan = function (x) {\n    return this.executeSingleInput('Tan', x);\n  };\n\n  NodeJSKernelBackend.prototype.asin = function (x) {\n    return this.executeSingleInput('Asin', x);\n  };\n\n  NodeJSKernelBackend.prototype.acos = function (x) {\n    return this.executeSingleInput('Acos', x);\n  };\n\n  NodeJSKernelBackend.prototype.atan = function (x) {\n    return this.executeSingleInput('Atan', x);\n  };\n\n  NodeJSKernelBackend.prototype.sinh = function (x) {\n    return this.executeSingleInput('Sinh', x);\n  };\n\n  NodeJSKernelBackend.prototype.cosh = function (x) {\n    return this.executeSingleInput('Cosh', x);\n  };\n\n  NodeJSKernelBackend.prototype.tanh = function (x) {\n    return this.executeSingleInput('Tanh', x);\n  };\n\n  NodeJSKernelBackend.prototype.mod = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('FloorMod', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.round = function (x) {\n    return this.executeSingleInput('Round', x);\n  };\n\n  NodeJSKernelBackend.prototype.sign = function (x) {\n    return this.executeSingleInput('Sign', x);\n  };\n\n  NodeJSKernelBackend.prototype.isNaN = function (x) {\n    return this.executeSingleInput('IsNan', x);\n  };\n\n  NodeJSKernelBackend.prototype.isInf = function (x) {\n    return this.executeSingleInput('IsInf', x);\n  };\n\n  NodeJSKernelBackend.prototype.isFinite = function (x) {\n    return this.executeSingleInput('IsFinite', x);\n  };\n\n  NodeJSKernelBackend.prototype.rsqrt = function (x) {\n    return this.executeSingleInput('Rsqrt', x);\n  };\n\n  NodeJSKernelBackend.prototype.reciprocal = function (x) {\n    return this.executeSingleInput('Reciprocal', x);\n  };\n\n  NodeJSKernelBackend.prototype.asinh = function (x) {\n    return this.executeSingleInput('Asinh', x);\n  };\n\n  NodeJSKernelBackend.prototype.acosh = function (x) {\n    return this.executeSingleInput('Acosh', x);\n  };\n\n  NodeJSKernelBackend.prototype.atanh = function (x) {\n    return this.executeSingleInput('Atanh', x);\n  };\n\n  NodeJSKernelBackend.prototype.erf = function (x) {\n    return this.executeSingleInput('Erf', x);\n  };\n\n  NodeJSKernelBackend.prototype.squaredDifference = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('SquaredDifference', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.expm1 = function (x) {\n    return this.executeSingleInput('Expm1', x);\n  };\n\n  NodeJSKernelBackend.prototype.softplus = function (x) {\n    return this.executeSingleInput('Softplus', x);\n  };\n\n  NodeJSKernelBackend.prototype.atan2 = function (a, b) {\n    var opAttrs = [createTensorsTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('Atan2', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.step = function (x, alpha) {\n    var dtype = x.dtype;\n    var nans = this.isNaN(x);\n    var stepNoNans = this.select(tf.greater(x, tfjs_1.scalar(0, dtype)), tfjs_1.ones(x.shape), tfjs_1.fill(x.shape, alpha, dtype));\n    return this.select(nans, x, stepNoNans);\n  };\n\n  NodeJSKernelBackend.prototype.conv2d = function (x, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME' && convInfo.padInfo.type !== 'EXPLICIT') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n\n    if (padding === 'EXPLICIT') {\n      var padValue = [convInfo.padInfo.top, convInfo.padInfo.bottom, convInfo.padInfo.left, convInfo.padInfo.right];\n      opAttrs.push({\n        name: 'explicit_paddings',\n        type: this.binding.TF_ATTR_INT,\n        value: dataFormat === 'NHWC' ? [0, 0].concat(padValue, [0, 0]) : [0, 0, 0, 0].concat(padValue)\n      });\n    }\n\n    return this.executeSingleOutput('Conv2D', opAttrs, [x, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var inputSizes = tfjs_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('Conv2DBackpropInput', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.conv2dDerFilter = function (x, dy, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('Conv2DBackpropFilter', opAttrs, [x, filterSizes, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var inputSizes = tfjs_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropInput', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropFilter', opAttrs, [x, filterSizes, dY]);\n  };\n\n  NodeJSKernelBackend.prototype.fusedDepthwiseConv2D = function (_a) {\n    var input = _a.input,\n        filter = _a.filter,\n        convInfo = _a.convInfo,\n        bias = _a.bias,\n        activation = _a.activation,\n        preluActivationWeights = _a.preluActivationWeights;\n    var result = this.depthwiseConv2D(input, filter, convInfo);\n\n    if (bias != null) {\n      result = tf.add(result, bias);\n    }\n\n    result = this.applyActivation(result, activation, preluActivationWeights);\n    return result;\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', input.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    return this.executeSingleOutput('DepthwiseConv2dNative', opAttrs, [input, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3d = function (x, filter, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    return this.executeSingleOutput('Conv3D', opAttrs, [x, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', dy.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }, createTensorsTypeOpAttr('Tshape', 'int32')];\n    var inputSizes = tfjs_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('Conv3DBackpropInputV2', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('Conv3DBackpropFilterV2', opAttrs, [x, filterSizes, dY]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPool = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPool', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPoolGrad', opAttrs, [x, y, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPool = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('AvgPool', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    var origInputShape = tfjs_1.tensor1d(x.shape, 'int32');\n    return this.executeSingleOutput('AvgPoolGrad', opAttrs, [origInputShape, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPool3d = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('AvgPool3D', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPool3dBackprop = function (dy, x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    var origInputShape = tfjs_1.tensor1d(x.shape, 'int32');\n    return this.executeSingleOutput('AvgPool3DGrad', opAttrs, [origInputShape, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPool3d = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPool3D', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPool3dBackprop = function (dy, x, y, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPool3DGrad', opAttrs, [x, y, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.reshape = function (x, shape) {\n    var shapeTensor = tfjs_1.tensor1d(shape, 'int32');\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tshape', shapeTensor.dtype)];\n    return this.executeSingleOutput('Reshape', opAttrs, [x, shapeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.cast = function (x, dtype) {\n    var opAttrs = [createTensorsTypeOpAttr('SrcT', x.dtype), createTensorsTypeOpAttr('DstT', dtype), {\n      name: 'Truncate',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }];\n    return this.executeSingleOutput('Cast', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.tile = function (x, reps) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tmultiples', 'int32')];\n    var multiples = tfjs_1.tensor1d(reps, 'int32');\n    return this.executeSingleOutput('Tile', opAttrs, [x, multiples]);\n  };\n\n  NodeJSKernelBackend.prototype.pad = function (x, paddings, constantValue) {\n    // Bind tensor values\n    var paddingsTensor = tfjs_1.tensor2d(paddings, [paddings.length, 2], 'int32');\n    var constantTensor = tfjs_1.scalar(constantValue, x.dtype);\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tpaddings', paddingsTensor.dtype)];\n    return this.executeSingleOutput('PadV2', opAttrs, [x, paddingsTensor, constantTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.transpose = function (x, perm) {\n    var permTensor = tfjs_1.tensor1d(perm, 'int32');\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tperm', 'int32')];\n    return this.executeSingleOutput('Transpose', opAttrs, [x, permTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.gather = function (x, indices, axis) {\n    var axisTensor = tfjs_1.scalar(axis, 'int32');\n    var opAttrs = [createTensorsTypeOpAttr('Tparams', x.dtype), createTensorsTypeOpAttr('Tindices', indices.dtype), createTensorsTypeOpAttr('Taxis', 'int32')];\n    return this.executeSingleOutput('GatherV2', opAttrs, [x, indices, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.gatherND = function (x, indices) {\n    var opAttrs = [createTensorsTypeOpAttr('Tparams', x.dtype), createTensorsTypeOpAttr('Tindices', 'int32')];\n    return this.executeSingleOutput('GatherNd', opAttrs, [x, indices]);\n  };\n\n  NodeJSKernelBackend.prototype.scatterND = function (indices, updates, shape) {\n    var opAttrs = [createTensorsTypeOpAttr('T', updates.dtype), createTensorsTypeOpAttr('Tindices', 'int32')];\n    var shapeTensor = tfjs_1.tensor1d(shape, 'int32');\n    return this.executeSingleOutput('ScatterNd', opAttrs, [indices, updates, shapeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {\n    var blockShapeTensor = tfjs_1.tensor1d(blockShape, 'int32');\n    var cropsTensor = tfjs_1.tensor2d(crops, [crops.length, crops[0].length], 'int32');\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tblock_shape', 'int32'), createTensorsTypeOpAttr('Tcrops', cropsTensor.dtype)];\n    return this.executeSingleOutput('BatchToSpaceND', opAttrs, [x, blockShapeTensor, cropsTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {\n    var blockShapeTensor = tfjs_1.tensor1d(blockShape, 'int32');\n    var paddingsTensor = tfjs_1.tensor2d(paddings, [paddings.length, paddings[0].length], 'int32');\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tblock_shape', 'int32'), createTensorsTypeOpAttr('Tpaddings', paddingsTensor.dtype)];\n    return this.executeSingleOutput('SpaceToBatchND', opAttrs, [x, blockShapeTensor, paddingsTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var size = tfjs_1.tensor1d([newHeight, newWidth], 'int32');\n    return this.executeSingleOutput('ResizeBilinear', opAttrs, [x, size]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    return this.executeSingleOutput('ResizeBilinearGrad', opAttrs, [dy, x]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var size = tfjs_1.tensor1d([newHeight, newWidth], 'int32');\n    return this.executeSingleOutput('ResizeNearestNeighbor', opAttrs, [x, size]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var _a = x.shape,\n        origHeight = _a[1],\n        origWidth = _a[2];\n    var size = tfjs_1.tensor1d([origHeight, origWidth], 'int32');\n    return this.executeSingleOutput('ResizeNearestNeighborGrad', opAttrs, [dy, size]);\n  };\n\n  NodeJSKernelBackend.prototype.batchNorm = function (x, mean, variance, offset, scale, varianceEpsilon) {\n    if (mean.rank > 1) {\n      // Fused batch norm doesn't work with high-dim mean/var/scale/offset.\n      var inv = tfjs_1.rsqrt(variance.add(tfjs_1.scalar(varianceEpsilon)));\n\n      if (scale != null) {\n        inv = inv.mul(scale);\n      }\n\n      var xNorm = x.sub(mean).mul(inv);\n      return offset != null ? xNorm.add(offset) : xNorm;\n    }\n\n    var dataFormat = 'NHWC';\n    var depth = x.shape[3];\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'epsilon',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: varianceEpsilon\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'is_training',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }];\n    var numOutputs = 5;\n\n    if (scale == null) {\n      scale = tfjs_1.fill([depth], 1);\n    }\n\n    if (offset == null) {\n      offset = tfjs_1.fill([depth], 0);\n    }\n\n    return this.executeMultipleOutputs('FusedBatchNorm', opAttrs, [x, scale, offset, mean, variance], numOutputs)[0];\n  };\n\n  NodeJSKernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x.dtype), {\n      name: 'depth_radius',\n      type: this.binding.TF_ATTR_INT,\n      value: radius\n    }, {\n      name: 'bias',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: bias\n    }, {\n      name: 'alpha',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: alpha\n    }, {\n      name: 'beta',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: beta\n    }];\n    return this.executeSingleOutput('LRN', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {\n    var opAttrs = [createTensorsTypeOpAttr('T', dy.dtype), {\n      name: 'depth_radius',\n      type: this.binding.TF_ATTR_INT,\n      value: radius\n    }, {\n      name: 'bias',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: bias\n    }, {\n      name: 'alpha',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: alpha\n    }, {\n      name: 'beta',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: beta\n    }];\n    return this.executeSingleOutput('LRNGrad', opAttrs, [dy, inputImage, outputImage]);\n  };\n\n  NodeJSKernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {\n    if (normalized) {\n      throw new Error('TF Node backend does not support normalized logits ' + 'passed to multinomial');\n    }\n\n    var opAttrs = [createTensorsTypeOpAttr('T', logits.dtype), createTensorsTypeOpAttr('output_dtype', 'int32'), {\n      name: 'seed',\n      type: this.binding.TF_ATTR_INT,\n      value: seed\n    }, {\n      name: 'seed2',\n      type: this.binding.TF_ATTR_INT,\n      value: seed * seed\n    }];\n    return this.executeSingleOutput('Multinomial', opAttrs, [logits, tfjs_1.scalar(numSamples, 'int32')]);\n  };\n\n  NodeJSKernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {\n    var depthTensor = tfjs_1.scalar(depth, 'int32');\n    var onValueTensor = tfjs_1.scalar(onValue, 'int32');\n    var offValueTensor = tfjs_1.scalar(offValue, 'int32');\n    var opAttrs = [{\n      name: 'axis',\n      type: this.binding.TF_ATTR_INT,\n      value: -1\n    }, createTensorsTypeOpAttr('T', indices.dtype), createTensorsTypeOpAttr('TI', indices.dtype)];\n    return this.executeSingleOutput('OneHot', opAttrs, [indices, depthTensor, onValueTensor, offValueTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {\n    var axisTensor = tfjs_1.scalar(axis, 'int32');\n    var opAttrs = [{\n      name: 'exclusive',\n      type: this.binding.TF_ATTR_BOOL,\n      value: exclusive\n    }, {\n      name: 'reverse',\n      type: this.binding.TF_ATTR_BOOL,\n      value: reverse\n    }, createTensorsTypeOpAttr('T', x.dtype), createTensorsTypeOpAttr('Tidx', 'int32')];\n    return this.executeSingleOutput('Cumsum', opAttrs, [x, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    var opAttrs = [createTensorsTypeOpAttr('T', boxes.dtype)];\n    var maxOutputSizeTensor = tfjs_1.scalar(maxOutputSize, 'int32');\n    var iouThresholdTensor = tfjs_1.scalar(iouThreshold);\n    var scoreThresholdTensor = tfjs_1.scalar(scoreThreshold);\n    return this.executeSingleOutput('NonMaxSuppressionV3', opAttrs, [boxes, scores, maxOutputSizeTensor, iouThresholdTensor, scoreThresholdTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.fft = function (x) {\n    var opAttrs = [createTensorsTypeOpAttr('Tcomplex', x.dtype)];\n    return this.executeSingleOutput('FFT', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.ifft = function (x) {\n    var opAttrs = [createTensorsTypeOpAttr('Tcomplex', x.dtype)];\n    return this.executeSingleOutput('IFFT', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.complex = function (real, imag) {\n    var opAttrs = [createTensorsTypeOpAttr('T', real), {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_COMPLEX64\n    }];\n    var inputs = [real, imag];\n    return this.executeSingleOutput('Complex', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.real = function (input) {\n    var opAttrs = [createTensorsTypeOpAttr('T', input), {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_FLOAT\n    }];\n    var inputs = [input];\n    return this.executeSingleOutput('Real', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.imag = function (input) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_COMPLEX64\n    }, {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_FLOAT\n    }];\n    var inputs = [input];\n    return this.executeSingleOutput('Imag', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n    var opAttrs = [createTensorsTypeOpAttr('T', image.dtype), {\n      name: 'method',\n      type: this.binding.TF_ATTR_STRING,\n      value: method\n    }, {\n      name: 'extrapolation_value',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: extrapolationValue\n    }];\n    var cropSizeTensor = tfjs_1.tensor1d(cropSize, 'int32');\n    return this.executeSingleOutput('CropAndResize', opAttrs, [image, boxes, boxIndex, cropSizeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {\n    var opAttrs = [createTensorsTypeOpAttr('T', x), {\n      name: 'block_size',\n      type: this.binding.TF_ATTR_INT,\n      value: blockSize < 2 ? 2 : blockSize\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    var inputs = [x];\n    return this.executeSingleOutput('DepthToSpace', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.split = function (value, sizeSplits, axis) {\n    var opAttrs = [{\n      name: 'num_split',\n      type: this.binding.TF_ATTR_INT,\n      value: sizeSplits.length\n    }, createTensorsTypeOpAttr('T', value), {\n      name: 'Tlen',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }];\n    var inputs = [value];\n    inputs.push(tfjs_1.tensor1d(sizeSplits, 'int32'));\n    inputs.push(tfjs_1.scalar(axis, 'int32'));\n    return this.executeMultipleOutputs('SplitV', opAttrs, inputs, sizeSplits.length);\n  };\n\n  NodeJSKernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {\n    var opAttrs = [{\n      name: 'validate_indices',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, createTensorsTypeOpAttr('T', sparseValues.dtype), createTensorsTypeOpAttr('Tindices', sparseIndices.dtype)];\n    var outputShapeTensor = tfjs_1.tensor1d(outputShape, 'int32');\n    return this.executeSingleOutput('SparseToDense', opAttrs, [sparseIndices, outputShapeTensor, sparseValues, defaultValue]);\n  };\n\n  NodeJSKernelBackend.prototype.linspace = function (start, stop, num) {\n    var opAttrs = [createTensorsTypeOpAttr('T', 'float32'), createTensorsTypeOpAttr('Tidx', 'int32')];\n    var inputs = [tfjs_1.scalar(start, 'float32'), tfjs_1.scalar(stop, 'float32'), tfjs_1.scalar(num, 'int32')];\n    return this.executeSingleOutput('LinSpace', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.decodeJpeg = function (contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod) {\n    var opAttrs = [{\n      name: 'channels',\n      type: this.binding.TF_ATTR_INT,\n      value: channels\n    }, {\n      name: 'ratio',\n      type: this.binding.TF_ATTR_INT,\n      value: ratio\n    }, {\n      name: 'fancy_upscaling',\n      type: this.binding.TF_ATTR_BOOL,\n      value: fancyUpscaling\n    }, {\n      name: 'try_recover_truncated',\n      type: this.binding.TF_ATTR_BOOL,\n      value: tryRecoverTruncated\n    }, {\n      name: 'acceptable_fraction',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: acceptableFraction\n    }, {\n      name: 'dct_method',\n      type: this.binding.TF_ATTR_STRING,\n      value: dctMethod\n    }];\n    var inputArgs = [tfjs_1.scalar(contents, 'string')];\n    return this.executeSingleOutput('DecodeJpeg', opAttrs, inputArgs);\n  };\n\n  NodeJSKernelBackend.prototype.decodePng = function (contents, channels) {\n    var opAttrs = [{\n      name: 'channels',\n      type: this.binding.TF_ATTR_INT,\n      value: channels\n    }];\n    var inputArgs = [tfjs_1.scalar(contents, 'string')];\n    return this.executeSingleOutput('DecodePng', opAttrs, inputArgs);\n  };\n\n  NodeJSKernelBackend.prototype.decodeBmp = function (contents, channels) {\n    var opAttrs = [{\n      name: 'channels',\n      type: this.binding.TF_ATTR_INT,\n      value: channels\n    }];\n    var inputArgs = [tfjs_1.scalar(contents, 'string')];\n    return this.executeSingleOutput('DecodeBmp', opAttrs, inputArgs);\n  };\n\n  NodeJSKernelBackend.prototype.decodeGif = function (contents) {\n    var inputArgs = [tfjs_1.scalar(contents, 'string')];\n    return this.executeSingleOutput('DecodeGif', [], inputArgs);\n  };\n\n  NodeJSKernelBackend.prototype.executeEncodeImageOp = function (name, opAttrs, imageData, imageShape) {\n    var inputTensorId = this.binding.createTensor(imageShape, this.binding.TF_UINT8, imageData);\n    var outputMetadata = this.binding.executeOp(name, opAttrs, [inputTensorId], 1);\n    var outputTensorInfo = outputMetadata[0]; // prevent the tensor data from being converted to a UTF8 string, since\n    // the encoded data is not valid UTF8\n\n    outputTensorInfo.dtype = this.binding.TF_UINT8;\n    return this.createOutputTensor(outputTensorInfo);\n  };\n\n  NodeJSKernelBackend.prototype.encodeJpeg = function (imageData, imageShape, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata) {\n    var opAttrs = [{\n      name: 'format',\n      type: this.binding.TF_ATTR_STRING,\n      value: format\n    }, {\n      name: 'quality',\n      type: this.binding.TF_ATTR_INT,\n      value: quality\n    }, {\n      name: 'progressive',\n      type: this.binding.TF_ATTR_BOOL,\n      value: progressive\n    }, {\n      name: 'optimize_size',\n      type: this.binding.TF_ATTR_BOOL,\n      value: optimizeSize\n    }, {\n      name: 'chroma_downsampling',\n      type: this.binding.TF_ATTR_BOOL,\n      value: chromaDownsampling\n    }, {\n      name: 'density_unit',\n      type: this.binding.TF_ATTR_STRING,\n      value: densityUnit\n    }, {\n      name: 'x_density',\n      type: this.binding.TF_ATTR_INT,\n      value: xDensity\n    }, {\n      name: 'y_density',\n      type: this.binding.TF_ATTR_INT,\n      value: yDensity\n    }, {\n      name: 'xmp_metadata',\n      type: this.binding.TF_ATTR_STRING,\n      value: xmpMetadata\n    }];\n    return this.executeEncodeImageOp('EncodeJpeg', opAttrs, imageData, imageShape);\n  };\n\n  NodeJSKernelBackend.prototype.encodePng = function (imageData, imageShape, compression) {\n    var opAttrs = [{\n      name: 'compression',\n      type: this.binding.TF_ATTR_INT,\n      value: compression\n    }];\n    return this.executeEncodeImageOp('EncodePng', opAttrs, imageData, imageShape);\n  };\n\n  NodeJSKernelBackend.prototype.deleteSavedModel = function (id) {\n    this.binding.deleteSavedModel(id);\n  };\n\n  NodeJSKernelBackend.prototype.loadSavedModelMetaGraph = function (path, tags) {\n    return this.binding.loadSavedModel(path, tags);\n  };\n\n  NodeJSKernelBackend.prototype.getMappedInputTensorIds = function (inputs, inputTensorInfos) {\n    var tensorIds = this.getInputTensorIds(inputs);\n\n    for (var i = 0; i < inputs.length; i++) {\n      if (inputTensorInfos[i] != null) {\n        if (inputTensorInfos[i].tfDtype === 'DT_UINT8') {\n          var data = Uint8Array.from(inputs[i].dataSync());\n          var inputTensorId = this.binding.createTensor(inputs[i].shape, this.binding.TF_UINT8, data);\n          tensorIds[i] = inputTensorId;\n        } else if (inputTensorInfos[i].tfDtype === 'DT_INT64') {\n          var data = int64_tensors_1.encodeInt32ArrayAsInt64(inputs[i].dataSync());\n          var inputTensorId = this.binding.createTensor(inputs[i].shape, this.binding.TF_INT64, data);\n          tensorIds[i] = inputTensorId;\n        }\n      }\n    }\n\n    return tensorIds;\n  };\n\n  NodeJSKernelBackend.prototype.runSavedModel = function (id, inputs, inputTensorInfos, outputOpNames) {\n    var _this = this;\n\n    var outputMetadata = this.binding.runSavedModel(id, this.getMappedInputTensorIds(inputs, inputTensorInfos), inputTensorInfos.map(function (info) {\n      return info.name;\n    }).join(','), outputOpNames.join(','));\n    return outputMetadata.map(function (m) {\n      return _this.createOutputTensor(m);\n    });\n  }; // ------------------------------------------------------------\n  // TensorBoard-related (tfjs-node-specific) backend kernels.\n\n\n  NodeJSKernelBackend.prototype.summaryWriter = function (logdir) {\n    var opAttrs = [{\n      name: 'shared_name',\n      type: this.binding.TF_ATTR_STRING,\n      value: \"logdir:\" + logdir\n    }, {\n      name: 'container',\n      type: this.binding.TF_ATTR_STRING,\n      value: ''\n    }];\n    var writerResource = this.executeSingleOutput('SummaryWriter', opAttrs, []);\n    return writerResource;\n  };\n\n  NodeJSKernelBackend.prototype.createSummaryFileWriter = function (resourceHandle, logdir, maxQueue, flushMillis, filenameSuffix) {\n    var inputArgs = [resourceHandle, tfjs_1.scalar(logdir), tfjs_1.scalar(maxQueue == null ? 10 : maxQueue, 'int32'), tfjs_1.scalar(flushMillis == null ? 2 * 60 * 1000 : flushMillis, 'int32'), tfjs_1.scalar(filenameSuffix == null ? '.v2' : filenameSuffix)];\n    this.executeMultipleOutputs('CreateSummaryFileWriter', [], inputArgs, 0);\n  };\n\n  NodeJSKernelBackend.prototype.writeScalarSummary = function (resourceHandle, step, name, value) {\n    var _this = this;\n\n    tfjs_1.tidy(function () {\n      tfjs_1.util.assert(Number.isInteger(step), function () {\n        return \"step is expected to be an integer, but is instead \" + step;\n      });\n      var inputArgs = [resourceHandle, new int64_tensors_1.Int64Scalar(step), tfjs_1.scalar(name, 'string')];\n      var typeAttr;\n\n      if (typeof value === 'number') {\n        inputArgs.push(tfjs_1.scalar(value));\n        typeAttr = _this.binding.TF_FLOAT;\n      } else {\n        // `value` is a Scalar.\n        tfjs_1.util.assert(value.rank === 0, function () {\n          return \"A non-scalar tensor (rank \" + value.rank + \") is passed to \" + \"writeScalarSummary()\";\n        });\n        inputArgs.push(value);\n        typeAttr = _this.typeAttributeFromTensor(value);\n      }\n\n      var opAttrs = [{\n        name: 'T',\n        type: _this.binding.TF_ATTR_TYPE,\n        value: typeAttr\n      }];\n\n      _this.binding.executeOp('WriteScalarSummary', opAttrs, _this.getInputTensorIds(inputArgs), 0);\n    });\n  };\n\n  NodeJSKernelBackend.prototype.flushSummaryWriter = function (resourceHandle) {\n    var inputArgs = [resourceHandle];\n    this.executeMultipleOutputs('FlushSummaryWriter', [], inputArgs, 0);\n  }; // ~ TensorBoard-related (tfjs-node-specific) backend kernels.\n  // ------------------------------------------------------------\n\n\n  NodeJSKernelBackend.prototype.memory = function () {\n    // Due to automatic garbage collection, the numbers are unreliable.\n    // TODO(kreeger): Since there is finalization in C, count the true\n    // number of undisposed tensors.\n    return {\n      unreliable: true\n    };\n  };\n\n  NodeJSKernelBackend.prototype.time = function (f) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, elapsed;\n      return __generator(this, function (_a) {\n        start = process.hrtime();\n        f();\n        elapsed = process.hrtime(start);\n        return [2\n        /*return*/\n        , {\n          kernelMs: elapsed[0] * 1000 + elapsed[1] / 1000000\n        }];\n      });\n    });\n  };\n\n  NodeJSKernelBackend.prototype.getNumOfSavedModels = function () {\n    return this.binding.getNumOfSavedModels();\n  };\n\n  return NodeJSKernelBackend;\n}(tfjs_1.KernelBackend);\n\nexports.NodeJSKernelBackend = NodeJSKernelBackend;\n/** Returns an instance of the Node.js backend. */\n\nfunction nodeBackend() {\n  return tf.findBackend('tensorflow');\n}\n\nexports.nodeBackend = nodeBackend;\n/** Returns the TF dtype for a given DataType. */\n\nfunction getTFDType(dataType) {\n  var binding = nodeBackend().binding;\n\n  switch (dataType) {\n    case 'float32':\n      return binding.TF_FLOAT;\n\n    case 'int32':\n      return binding.TF_INT32;\n\n    case 'bool':\n      return binding.TF_BOOL;\n\n    case 'complex64':\n      return binding.TF_COMPLEX64;\n\n    case 'string':\n      return binding.TF_STRING;\n    // tslint:disable-next-line:no-any\n\n    case 'int64':\n      // int64 is not a generally supported dtype in TensorFlow.js\n      // (tfjs-core). However, it needs to be included here for the purpose of\n      // writing the `step` value to TensorBoard via WriteScalarSummary and\n      // other op kernels.\n      return binding.TF_INT64;\n\n    default:\n      var errorMessage = \"Unknown dtype: \" + dataType;\n      throw new Error(errorMessage);\n  }\n}\n\nexports.getTFDType = getTFDType;\n/**\n * Creates a TFEOpAttr for a 'type' OpDef attribute from a Tensor or list of\n * Tensors.\n */\n\nfunction createTensorsTypeOpAttr(attrName, tensorsOrDtype) {\n  if (util_1.isNullOrUndefined(tensorsOrDtype)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_ATTR_TYPE,\n    value: tensorsOrDtype instanceof tf.Tensor || Array.isArray(tensorsOrDtype) ? getTFDTypeForInputs(tensorsOrDtype) : getTFDType(tensorsOrDtype)\n  };\n}\n\nexports.createTensorsTypeOpAttr = createTensorsTypeOpAttr; // TODO(yassogba) remove? who uses this?\n\nfunction createOpAttr(attrName, tensorsOrDtype, value) {\n  if (util_1.isNullOrUndefined(tensorsOrDtype)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_BOOL,\n    value: value\n  };\n}\n\nexports.createOpAttr = createOpAttr;\n/** Returns the dtype number for a single or list of input Tensors. */\n\nfunction getTFDTypeForInputs(tensors) {\n  if (util_1.isNullOrUndefined(tensors)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  if (util_1.isArray(tensors)) {\n    for (var i = 0; i < tensors.length; i++) {\n      return getTFDType(tensors[i].dtype);\n    }\n\n    return -1;\n  } else {\n    return getTFDType(tensors.dtype);\n  }\n}\n\nfunction ensureTensorflowBackend() {\n  tf.util.assert(tf.getBackend() === 'tensorflow', function () {\n    return \"Expect the current backend to be \\\"tensorflow\\\", but got \\\"\" + tf.getBackend() + \"\\\"\";\n  });\n}\n\nexports.ensureTensorflowBackend = ensureTensorflowBackend;","map":null,"metadata":{},"sourceType":"script"}