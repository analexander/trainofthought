{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\n\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\n\nvar ImageType;\n\n(function (ImageType) {\n  ImageType[\"JPEG\"] = \"jpeg\";\n  ImageType[\"PNG\"] = \"png\";\n  ImageType[\"GIF\"] = \"gif\";\n  ImageType[\"BMP\"] = \"BMP\";\n})(ImageType = exports.ImageType || (exports.ImageType = {}));\n/**\n * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * @param contents The JPEG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 0. Accepted values are\n *     0: use the number of channels in the JPEG-encoded image.\n *     1: output a grayscale image.\n *     3: output an RGB image.\n * @param ratio An optional int. Defaults to 1. Downscaling ratio. It is used\n *     when image is type Jpeg.\n * @param fancyUpscaling An optional bool. Defaults to True. If true use a\n *     slower but nicer upscaling of the chroma planes. It is used when image is\n *     type Jpeg.\n * @param tryRecoverTruncated An optional bool. Defaults to False. If true try\n *     to recover an image from truncated input. It is used when image is type\n *     Jpeg.\n * @param acceptableFraction An optional float. Defaults to 1. The minimum\n *     required fraction of lines before a truncated input is accepted. It is\n *     used when image is type Jpeg.\n * @param dctMethod An optional string. Defaults to \"\". string specifying a hint\n *     about the algorithm used for decompression. Defaults to \"\" which maps to\n *     a system-specific default. Currently valid values are [\"INTEGER_FAST\",\n *     \"INTEGER_ACCURATE\"]. The hint may be ignored (e.g., the internal jpeg\n *     library changes to a version that does not have that specific option.) It\n *     is used when image is type Jpeg.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\n\nfunction decodeJpeg(contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod) {\n  if (channels === void 0) {\n    channels = 0;\n  }\n\n  if (ratio === void 0) {\n    ratio = 1;\n  }\n\n  if (fancyUpscaling === void 0) {\n    fancyUpscaling = true;\n  }\n\n  if (tryRecoverTruncated === void 0) {\n    tryRecoverTruncated = false;\n  }\n\n  if (acceptableFraction === void 0) {\n    acceptableFraction = 1;\n  }\n\n  if (dctMethod === void 0) {\n    dctMethod = '';\n  }\n\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  return tfjs_1.tidy(function () {\n    return nodejs_kernel_backend_1.nodeBackend().decodeJpeg(contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod).toInt();\n  });\n}\n\nexports.decodeJpeg = decodeJpeg;\n/**\n * Decode a PNG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * @param contents The PNG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 0. Accepted values are\n *      0: use the number of channels in the PNG-encoded image.\n *      1: output a grayscale image.\n *      3: output an RGB image.\n *      4: output an RGBA image.\n * @param dtype The data type of the result. Only `int32` is supported at this\n *     time.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3/4].\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction decodePng(contents, channels, dtype) {\n  if (channels === void 0) {\n    channels = 0;\n  }\n\n  if (dtype === void 0) {\n    dtype = 'int32';\n  }\n\n  tfjs_1.util.assert(dtype === 'int32', function () {\n    return 'decodeImage could only return Tensor of type `int32` for now.';\n  });\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  return tfjs_1.tidy(function () {\n    return nodejs_kernel_backend_1.nodeBackend().decodePng(contents, channels).toInt();\n  });\n}\n\nexports.decodePng = decodePng;\n/**\n * Decode the first frame of a BMP-encoded image to a 3D Tensor of dtype\n * `int32`.\n *\n * @param contents The BMP-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 0. Accepted values are\n *      0: use the number of channels in the BMP-encoded image.\n *      3: output an RGB image.\n *      4: output an RGBA image.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 3/4].\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction decodeBmp(contents, channels) {\n  if (channels === void 0) {\n    channels = 0;\n  }\n\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  return tfjs_1.tidy(function () {\n    return nodejs_kernel_backend_1.nodeBackend().decodeBmp(contents, channels).toInt();\n  });\n}\n\nexports.decodeBmp = decodeBmp;\n/**\n * Decode the frame(s) of a GIF-encoded image to a 4D Tensor of dtype `int32`.\n *\n * @param contents The GIF-encoded image in an Uint8Array.\n * @returns A 4D Tensor of dtype `int32` with shape [num_frames, height, width,\n *     3]. RGB channel order.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction decodeGif(contents) {\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  return tfjs_1.tidy(function () {\n    return nodejs_kernel_backend_1.nodeBackend().decodeGif(contents).toInt();\n  });\n}\n\nexports.decodeGif = decodeGif;\n/**\n * Given the encoded bytes of an image, it returns a 3D or 4D tensor of the\n * decoded image. Supports BMP, GIF, JPEG and PNG formats.\n *\n * @param content The encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 0, use the number of channels in\n *     the image. Number of color channels for the decoded image. It is used\n *     when image is type Png, Bmp, or Jpeg.\n * @param dtype The data type of the result. Only `int32` is supported at this\n *     time.\n * @param expandAnimations A boolean which controls the shape of the returned\n *     op's output. If True, the returned op will produce a 3-D tensor for PNG,\n *     JPEG, and BMP files; and a 4-D tensor for all GIFs, whether animated or\n *     not. If, False, the returned op will produce a 3-D tensor for all file\n *     types and will truncate animated GIFs to the first frame.\n * @returns A Tensor with dtype `int32` and a 3- or 4-dimensional shape,\n *     depending on the file type. For gif file the returned Tensor shape is\n *     [num_frames, height, width, 3], and for jpeg/png/bmp the returned Tensor\n *     shape is [height, width, channels]\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction decodeImage(content, channels, dtype, expandAnimations) {\n  if (channels === void 0) {\n    channels = 0;\n  }\n\n  if (dtype === void 0) {\n    dtype = 'int32';\n  }\n\n  if (expandAnimations === void 0) {\n    expandAnimations = true;\n  }\n\n  tfjs_1.util.assert(dtype === 'int32', function () {\n    return 'decodeImage could only return Tensor of type `int32` for now.';\n  });\n  var imageType = getImageType(content); // The return tensor has dtype uint8, which is not supported in\n  // TensorFlow.js, casting it to int32 which is the default dtype for image\n  // tensor. If the image is BMP, JPEG or PNG type, expanding the tensors\n  // shape so it becomes Tensor4D, which is the default tensor shape for image\n  // ([batch,imageHeight,imageWidth, depth]).\n\n  switch (imageType) {\n    case ImageType.JPEG:\n      return decodeJpeg(content, channels);\n\n    case ImageType.PNG:\n      return decodePng(content, channels);\n\n    case ImageType.GIF:\n      // If not to expand animations, take first frame of the gif and return\n      // as a 3D tensor.\n      return tfjs_1.tidy(function () {\n        var img = decodeGif(content);\n        return expandAnimations ? img : img.slice(0, 1).squeeze([0]);\n      });\n\n    case ImageType.BMP:\n      return decodeBmp(content, channels);\n\n    default:\n      return null;\n  }\n}\n\nexports.decodeImage = decodeImage;\n/**\n * Encodes an image tensor to JPEG.\n *\n * @param image A 3-D uint8 Tensor of shape [height, width, channels].\n * @param format An optional string from: \"\", \"grayscale\", \"rgb\".\n *     Defaults to \"\". Per pixel image format.\n *     - '': Use a default format based on the number of channels in the image.\n *     - grayscale: Output a grayscale JPEG image. The channels dimension of\n *       image must be 1.\n *     - rgb: Output an RGB JPEG image. The channels dimension of image must\n *       be 3.\n * @param quality An optional int. Defaults to 95. Quality of the compression\n *     from 0 to 100 (higher is better and slower).\n * @param progressive An optional bool. Defaults to False. If True, create a\n *     JPEG that loads progressively (coarse to fine).\n * @param optimizeSize An optional bool. Defaults to False. If True, spend\n *     CPU/RAM to reduce size with no quality change.\n * @param chromaDownsampling  An optional bool. Defaults to True.\n *     See http://en.wikipedia.org/wiki/Chroma_subsampling.\n * @param densityUnit An optional string from: \"in\", \"cm\". Defaults to \"in\".\n *     Unit used to specify x_density and y_density: pixels per inch ('in') or\n *     centimeter ('cm').\n * @param xDensity An optional int. Defaults to 300. Horizontal pixels per\n *     density unit.\n * @param yDensity An optional int. Defaults to 300. Vertical pixels per\n *     density unit.\n * @param xmpMetadata An optional string. Defaults to \"\". If not empty, embed\n *     this XMP metadata in the image header.\n * @returns The JPEG encoded data as an Uint8Array.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction encodeJpeg(image, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata) {\n  if (format === void 0) {\n    format = '';\n  }\n\n  if (quality === void 0) {\n    quality = 95;\n  }\n\n  if (progressive === void 0) {\n    progressive = false;\n  }\n\n  if (optimizeSize === void 0) {\n    optimizeSize = false;\n  }\n\n  if (chromaDownsampling === void 0) {\n    chromaDownsampling = true;\n  }\n\n  if (densityUnit === void 0) {\n    densityUnit = 'in';\n  }\n\n  if (xDensity === void 0) {\n    xDensity = 300;\n  }\n\n  if (yDensity === void 0) {\n    yDensity = 300;\n  }\n\n  if (xmpMetadata === void 0) {\n    xmpMetadata = '';\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var backendEncodeImage;\n    return __generator(this, function (_a) {\n      nodejs_kernel_backend_1.ensureTensorflowBackend();\n\n      backendEncodeImage = function backendEncodeImage(imageData) {\n        return nodejs_kernel_backend_1.nodeBackend().encodeJpeg(imageData, image.shape, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata);\n      };\n\n      return [2\n      /*return*/\n      , encodeImage(image, backendEncodeImage)];\n    });\n  });\n}\n\nexports.encodeJpeg = encodeJpeg;\n/**\n * Encodes an image tensor to PNG.\n *\n * @param image A 3-D uint8 Tensor of shape [height, width, channels].\n * @param compression An optional int. Defaults to 1. Compression level.\n * @returns The PNG encoded data as an Uint8Array.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}\n */\n\nfunction encodePng(image, compression) {\n  if (compression === void 0) {\n    compression = 1;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var backendEncodeImage;\n    return __generator(this, function (_a) {\n      nodejs_kernel_backend_1.ensureTensorflowBackend();\n\n      backendEncodeImage = function backendEncodeImage(imageData) {\n        return nodejs_kernel_backend_1.nodeBackend().encodePng(imageData, image.shape, compression);\n      };\n\n      return [2\n      /*return*/\n      , encodeImage(image, backendEncodeImage)];\n    });\n  });\n}\n\nexports.encodePng = encodePng;\n\nfunction encodeImage(image, backendEncodeImage) {\n  return __awaiter(this, void 0, void 0, function () {\n    var encodedDataTensor, _a, _b, encodedPngData;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _a = backendEncodeImage;\n          _b = Uint8Array.bind;\n          return [4\n          /*yield*/\n          , image.data()];\n\n        case 1:\n          encodedDataTensor = _a.apply(void 0, [new (_b.apply(Uint8Array, [void 0, _c.sent()]))()]); // tslint:disable-next-line:no-any\n\n          return [4\n          /*yield*/\n          , encodedDataTensor.data()];\n\n        case 2:\n          encodedPngData = // tslint:disable-next-line:no-any\n          _c.sent()[0];\n          encodedDataTensor.dispose();\n          return [2\n          /*return*/\n          , encodedPngData];\n      }\n    });\n  });\n}\n/**\n * Helper function to get image type based on starting bytes of the image file.\n */\n\n\nfunction getImageType(content) {\n  // Classify the contents of a file based on starting bytes (aka magic number:\n  // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)\n  // This aligns with TensorFlow Core code:\n  // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44\n  if (content.length > 3 && content[0] === 255 && content[1] === 216 && content[2] === 255) {\n    // JPEG byte chunk starts with `ff d8 ff`\n    return ImageType.JPEG;\n  } else if (content.length > 4 && content[0] === 71 && content[1] === 73 && content[2] === 70 && content[3] === 56) {\n    // GIF byte chunk starts with `47 49 46 38`\n    return ImageType.GIF;\n  } else if (content.length > 8 && content[0] === 137 && content[1] === 80 && content[2] === 78 && content[3] === 71 && content[4] === 13 && content[5] === 10 && content[6] === 26 && content[7] === 10) {\n    // PNG byte chunk starts with `\\211 P N G \\r \\n \\032 \\n (89 50 4E 47 0D 0A\n    // 1A 0A)`\n    return ImageType.PNG;\n  } else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n    // BMP byte chunk starts with `42 4d`\n    return ImageType.BMP;\n  } else {\n    throw new Error('Expected image (BMP, JPEG, PNG, or GIF), but got unsupported ' + 'image type');\n  }\n}\n\nexports.getImageType = getImageType;","map":null,"metadata":{},"sourceType":"script"}