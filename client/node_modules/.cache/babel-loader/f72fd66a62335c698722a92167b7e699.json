{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar MiniPass = require('minipass');\n\nvar EE = require('events').EventEmitter;\n\nvar fs = require('fs'); // for writev\n\n\nvar binding = process.binding('fs');\nvar writeBuffers = binding.writeBuffers;\n/* istanbul ignore next */\n\nvar FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n\nvar _autoClose = Symbol('_autoClose');\n\nvar _close = Symbol('_close');\n\nvar _ended = Symbol('_ended');\n\nvar _fd = Symbol('_fd');\n\nvar _finished = Symbol('_finished');\n\nvar _flags = Symbol('_flags');\n\nvar _flush = Symbol('_flush');\n\nvar _handleChunk = Symbol('_handleChunk');\n\nvar _makeBuf = Symbol('_makeBuf');\n\nvar _mode = Symbol('_mode');\n\nvar _needDrain = Symbol('_needDrain');\n\nvar _onerror = Symbol('_onerror');\n\nvar _onopen = Symbol('_onopen');\n\nvar _onread = Symbol('_onread');\n\nvar _onwrite = Symbol('_onwrite');\n\nvar _open = Symbol('_open');\n\nvar _path = Symbol('_path');\n\nvar _pos = Symbol('_pos');\n\nvar _queue = Symbol('_queue');\n\nvar _read = Symbol('_read');\n\nvar _readSize = Symbol('_readSize');\n\nvar _reading = Symbol('_reading');\n\nvar _remain = Symbol('_remain');\n\nvar _size = Symbol('_size');\n\nvar _write = Symbol('_write');\n\nvar _writing = Symbol('_writing');\n\nvar _defaultFlag = Symbol('_defaultFlag');\n\nvar ReadStream = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadStream, _MiniPass);\n\n  function ReadStream(path, opt) {\n    var _this;\n\n    _classCallCheck(this, ReadStream);\n\n    opt = opt || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReadStream).call(this, opt));\n    _this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    _this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this[_path] = path;\n    _this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    _this[_reading] = false;\n    _this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    _this[_remain] = _this[_size];\n    _this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof _this[_fd] === 'number') _this[_read]();else _this[_open]();\n    return _this;\n  }\n\n  _createClass(ReadStream, [{\n    key: \"write\",\n    value: function write() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this2 = this;\n\n      fs.open(this[_path], 'r', function (er, fd) {\n        return _this2[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n\n        this[_read]();\n      }\n    }\n  }, {\n    key: _makeBuf,\n    value: function value() {\n      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var _this3 = this;\n\n      if (!this[_reading]) {\n        this[_reading] = true;\n\n        var buf = this[_makeBuf]();\n        /* istanbul ignore if */\n\n\n        if (buf.length === 0) return process.nextTick(function () {\n          return _this3[_onread](null, 0, buf);\n        });\n        fs.read(this[_fd], buf, 0, buf.length, null, function (er, br, buf) {\n          return _this3[_onread](er, br, buf);\n        });\n      }\n    }\n  }, {\n    key: _onread,\n    value: function value(er, br, buf) {\n      this[_reading] = false;\n      if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this4 = this;\n\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        fs.close(this[_fd], function (_) {\n          return _this4.emit('close');\n        });\n        this[_fd] = null;\n      }\n    }\n  }, {\n    key: _onerror,\n    value: function value(er) {\n      this[_reading] = true;\n\n      this[_close]();\n\n      this.emit('error', er);\n    }\n  }, {\n    key: _handleChunk,\n    value: function value(br, buf) {\n      var ret = false; // no effect if infinite\n\n      this[_remain] -= br;\n      if (br > 0) ret = _get(_getPrototypeOf(ReadStream.prototype), \"write\", this).call(this, br < buf.length ? buf.slice(0, br) : buf);\n\n      if (br === 0 || this[_remain] <= 0) {\n        ret = false;\n\n        this[_close]();\n\n        _get(_getPrototypeOf(ReadStream.prototype), \"end\", this).call(this);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      switch (ev) {\n        case 'prefinish':\n        case 'finish':\n          break;\n\n        case 'drain':\n          if (typeof this[_fd] === 'number') this[_read]();\n          break;\n\n        default:\n          return _get(_getPrototypeOf(ReadStream.prototype), \"emit\", this).call(this, ev, data);\n      }\n    }\n  }, {\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }]);\n\n  return ReadStream;\n}(MiniPass);\n\nvar ReadStreamSync = /*#__PURE__*/function (_ReadStream) {\n  _inherits(ReadStreamSync, _ReadStream);\n\n  function ReadStreamSync() {\n    _classCallCheck(this, ReadStreamSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ReadStreamSync).apply(this, arguments));\n  }\n\n  _createClass(ReadStreamSync, [{\n    key: _open,\n    value: function value() {\n      var threw = true;\n\n      try {\n        this[_onopen](null, fs.openSync(this[_path], 'r'));\n\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var threw = true;\n\n      try {\n        if (!this[_reading]) {\n          this[_reading] = true;\n\n          do {\n            var buf = this[_makeBuf]();\n            /* istanbul ignore next */\n\n\n            var br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n            if (!this[_handleChunk](br, buf)) break;\n          } while (true);\n\n          this[_reading] = false;\n        }\n\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        try {\n          fs.closeSync(this[_fd]);\n        } catch (er) {}\n\n        this[_fd] = null;\n        this.emit('close');\n      }\n    }\n  }]);\n\n  return ReadStreamSync;\n}(ReadStream);\n\nvar WriteStream = /*#__PURE__*/function (_EE) {\n  _inherits(WriteStream, _EE);\n\n  function WriteStream(path, opt) {\n    var _this5;\n\n    _classCallCheck(this, WriteStream);\n\n    opt = opt || {};\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(WriteStream).call(this, opt));\n    _this5.readable = false;\n    _this5[_writing] = false;\n    _this5[_ended] = false;\n    _this5[_needDrain] = false;\n    _this5[_queue] = [];\n    _this5[_path] = path;\n    _this5[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this5[_mode] = opt.mode === undefined ? 438 : opt.mode;\n    _this5[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    _this5[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle\n\n    var defaultFlag = _this5[_pos] !== null ? 'r+' : 'w';\n    _this5[_defaultFlag] = opt.flags === undefined;\n    _this5[_flags] = _this5[_defaultFlag] ? defaultFlag : opt.flags;\n    if (_this5[_fd] === null) _this5[_open]();\n    return _this5;\n  }\n\n  _createClass(WriteStream, [{\n    key: _onerror,\n    value: function value(er) {\n      this[_close]();\n\n      this[_writing] = true;\n      this.emit('error', er);\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this6 = this;\n\n      fs.open(this[_path], this[_flags], this[_mode], function (er, fd) {\n        return _this6[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n        this[_flags] = 'w';\n\n        this[_open]();\n      } else if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n\n        this[_flush]();\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(buf, enc) {\n      if (buf) this.write(buf, enc);\n      this[_ended] = true; // synthetic after-write logic, where drain/finish live\n\n      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf, enc) {\n      if (typeof buf === 'string') buf = new Buffer(buf, enc);\n\n      if (this[_ended]) {\n        this.emit('error', new Error('write() after end()'));\n        return false;\n      }\n\n      if (this[_fd] === null || this[_writing] || this[_queue].length) {\n        this[_queue].push(buf);\n\n        this[_needDrain] = true;\n        return false;\n      }\n\n      this[_writing] = true;\n\n      this[_write](buf);\n\n      return true;\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      var _this7 = this;\n\n      fs.write(this[_fd], buf, 0, buf.length, this[_pos], function (er, bw) {\n        return _this7[_onwrite](er, bw);\n      });\n    }\n  }, {\n    key: _onwrite,\n    value: function value(er, bw) {\n      if (er) this[_onerror](er);else {\n        if (this[_pos] !== null) this[_pos] += bw;\n        if (this[_queue].length) this[_flush]();else {\n          this[_writing] = false;\n\n          if (this[_ended] && !this[_finished]) {\n            this[_finished] = true;\n\n            this[_close]();\n\n            this.emit('finish');\n          } else if (this[_needDrain]) {\n            this[_needDrain] = false;\n            this.emit('drain');\n          }\n        }\n      }\n    }\n  }, {\n    key: _flush,\n    value: function value() {\n      var _this8 = this;\n\n      if (this[_queue].length === 0) {\n        if (this[_ended]) this[_onwrite](null, 0);\n      } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n        var iovec = this[_queue];\n        this[_queue] = [];\n        writev(this[_fd], iovec, this[_pos], function (er, bw) {\n          return _this8[_onwrite](er, bw);\n        });\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this9 = this;\n\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        fs.close(this[_fd], function (_) {\n          return _this9.emit('close');\n        });\n        this[_fd] = null;\n      }\n    }\n  }, {\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }]);\n\n  return WriteStream;\n}(EE);\n\nvar WriteStreamSync = /*#__PURE__*/function (_WriteStream) {\n  _inherits(WriteStreamSync, _WriteStream);\n\n  function WriteStreamSync() {\n    _classCallCheck(this, WriteStreamSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WriteStreamSync).apply(this, arguments));\n  }\n\n  _createClass(WriteStreamSync, [{\n    key: _open,\n    value: function value() {\n      var fd;\n\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n      } catch (er) {\n        if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n          this[_flags] = 'w';\n          return this[_open]();\n        } else throw er;\n      }\n\n      this[_onopen](null, fd);\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        try {\n          fs.closeSync(this[_fd]);\n        } catch (er) {}\n\n        this[_fd] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      try {\n        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n      } catch (er) {\n        this[_onwrite](er, 0);\n      }\n    }\n  }]);\n\n  return WriteStreamSync;\n}(WriteStream);\n\nvar writev = function writev(fd, iovec, pos, cb) {\n  var done = function done(er, bw) {\n    return cb(er, bw, iovec);\n  };\n\n  var req = new FSReqWrap();\n  req.oncomplete = done;\n  binding.writeBuffers(fd, iovec, pos, req);\n};\n\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":null,"metadata":{},"sourceType":"script"}