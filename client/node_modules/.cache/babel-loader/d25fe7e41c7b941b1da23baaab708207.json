{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar types = require('./types.js');\n\nvar MiniPass = require('minipass');\n\nvar SLURP = Symbol('slurp');\n\nmodule.exports = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadEntry, _MiniPass);\n\n  function ReadEntry(header, ex, gex) {\n    var _this;\n\n    _classCallCheck(this, ReadEntry);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReadEntry).call(this)); // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n\n    _this.pause();\n\n    _this.extended = ex;\n    _this.globalExtended = gex;\n    _this.header = header;\n    _this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    _this.blockRemain = _this.startBlockSize;\n    _this.remain = header.size;\n    _this.type = header.type;\n    _this.meta = false;\n    _this.ignore = false;\n\n    switch (_this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        _this.meta = true;\n        break;\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n\n      default:\n        _this.ignore = true;\n    }\n\n    _this.path = header.path;\n    _this.mode = header.mode;\n    if (_this.mode) _this.mode = _this.mode & 4095;\n    _this.uid = header.uid;\n    _this.gid = header.gid;\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    _this.size = header.size;\n    _this.mtime = header.mtime;\n    _this.atime = header.atime;\n    _this.ctime = header.ctime;\n    _this.linkpath = header.linkpath;\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    if (ex) _this[SLURP](ex);\n    if (gex) _this[SLURP](gex, true);\n    return _this;\n  }\n\n  _createClass(ReadEntry, [{\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n      var r = this.remain;\n      var br = this.blockRemain;\n      this.remain = Math.max(0, r - writeLen);\n      this.blockRemain = Math.max(0, br - writeLen);\n      if (this.ignore) return true;\n      if (r >= writeLen) return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data); // r < writeLen\n\n      return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data.slice(0, r));\n    }\n  }, {\n    key: SLURP,\n    value: function value(ex, global) {\n      for (var k in ex) {\n        // we slurp in everything except for the path attribute in\n        // a global extended header, because that's weird.\n        if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) this[k] = ex[k];\n      }\n    }\n  }]);\n\n  return ReadEntry;\n}(MiniPass);","map":null,"metadata":{},"sourceType":"script"}