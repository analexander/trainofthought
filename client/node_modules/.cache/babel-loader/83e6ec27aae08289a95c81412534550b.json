{"ast":null,"code":"import _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var EPSILON_FLOAT32 = 1e-7;\nexport var EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\n\nexport var DataStorage = /*#__PURE__*/function () {\n  function DataStorage(backend, dataMover) {\n    _classCallCheck(this, DataStorage);\n\n    this.backend = backend;\n    this.dataMover = dataMover;\n    this.data = new WeakMap();\n    this.dataIdsCount = 0;\n  }\n\n  _createClass(DataStorage, [{\n    key: \"get\",\n    value: function get(dataId) {\n      if (!this.data.has(dataId)) {\n        this.dataMover.moveData(this.backend, dataId);\n      }\n\n      return this.data.get(dataId);\n    }\n  }, {\n    key: \"set\",\n    value: function set(dataId, value) {\n      this.dataIdsCount++;\n      this.data.set(dataId, value);\n    }\n  }, {\n    key: \"has\",\n    value: function has(dataId) {\n      return this.data.has(dataId);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(dataId) {\n      this.dataIdsCount--;\n      return this.data.delete(dataId);\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.dataIdsCount;\n    }\n  }]);\n\n  return DataStorage;\n}();\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\n\nexport var KernelBackend = /*#__PURE__*/function () {\n  function KernelBackend() {\n    _classCallCheck(this, KernelBackend);\n  }\n\n  _createClass(KernelBackend, [{\n    key: \"time\",\n    value: function time(f) {\n      return notYetImplemented('time');\n    }\n  }, {\n    key: \"read\",\n    value: function read(dataId) {\n      return notYetImplemented('read');\n    }\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      return notYetImplemented('readSync');\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return notYetImplemented('numDataIds');\n    }\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      return notYetImplemented('disposeData');\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      return notYetImplemented('write');\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype) {\n      return notYetImplemented('move');\n    }\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return notYetImplemented('memory');\n    }\n    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return notYetImplemented('floatPrecision');\n    }\n    /** Returns the smallest representable number.  */\n\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n  }, {\n    key: \"batchMatMul\",\n    value: function batchMatMul(a, b, transposeA, transposeB) {\n      return notYetImplemented('batchMatMul');\n    }\n  }, {\n    key: \"fusedBatchMatMul\",\n    value: function fusedBatchMatMul(_ref) {\n      var a = _ref.a,\n          b = _ref.b,\n          transposeA = _ref.transposeA,\n          transposeB = _ref.transposeB,\n          bias = _ref.bias,\n          activation = _ref.activation,\n          preluActivationWeights = _ref.preluActivationWeights;\n      return notYetImplemented('fusedBatchMatMul');\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(x, begin, size) {\n      return notYetImplemented('slice');\n    }\n  }, {\n    key: \"stridedSlice\",\n    value: function stridedSlice(x, begin, end, strides) {\n      return notYetImplemented('stridedSlice');\n    }\n  }, {\n    key: \"unstack\",\n    value: function unstack(x, axis) {\n      return notYetImplemented('unstack');\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(a, axis) {\n      return notYetImplemented('reverse');\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(tensors, axis) {\n      return notYetImplemented('concat');\n    }\n  }, {\n    key: \"neg\",\n    value: function neg(a) {\n      return notYetImplemented('neg');\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      return notYetImplemented('add');\n    }\n  }, {\n    key: \"addN\",\n    value: function addN(tensors) {\n      return notYetImplemented('addN');\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(a, b) {\n      return notYetImplemented('subtract');\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(a, b) {\n      return notYetImplemented('multiply');\n    }\n  }, {\n    key: \"realDivide\",\n    value: function realDivide(a, b) {\n      return notYetImplemented('realDivide');\n    }\n  }, {\n    key: \"floorDiv\",\n    value: function floorDiv(a, b) {\n      return notYetImplemented('floorDiv');\n    }\n  }, {\n    key: \"sum\",\n    value: function sum(x, axes) {\n      return notYetImplemented('sum');\n    }\n  }, {\n    key: \"prod\",\n    value: function prod(x, axes) {\n      return notYetImplemented('prod');\n    }\n  }, {\n    key: \"unsortedSegmentSum\",\n    value: function unsortedSegmentSum(x, segmentIds, numSegments) {\n      return notYetImplemented('unsortedSegmentSum');\n    }\n  }, {\n    key: \"argMin\",\n    value: function argMin(x, axis) {\n      return notYetImplemented('argMin');\n    }\n  }, {\n    key: \"argMax\",\n    value: function argMax(x, axis) {\n      return notYetImplemented('argMax');\n    }\n  }, {\n    key: \"equal\",\n    value: function equal(a, b) {\n      return notYetImplemented('equal');\n    }\n  }, {\n    key: \"notEqual\",\n    value: function notEqual(a, b) {\n      return notYetImplemented('notEqual');\n    }\n  }, {\n    key: \"less\",\n    value: function less(a, b) {\n      return notYetImplemented('less');\n    }\n  }, {\n    key: \"lessEqual\",\n    value: function lessEqual(a, b) {\n      return notYetImplemented('lessEqual');\n    }\n  }, {\n    key: \"greater\",\n    value: function greater(a, b) {\n      return notYetImplemented('greater');\n    }\n  }, {\n    key: \"greaterEqual\",\n    value: function greaterEqual(a, b) {\n      return notYetImplemented('greaterEqual');\n    }\n  }, {\n    key: \"logicalNot\",\n    value: function logicalNot(a) {\n      return notYetImplemented('logicalNot');\n    }\n  }, {\n    key: \"logicalAnd\",\n    value: function logicalAnd(a, b) {\n      return notYetImplemented('logicalAnd');\n    }\n  }, {\n    key: \"logicalOr\",\n    value: function logicalOr(a, b) {\n      return notYetImplemented('logicalOr');\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      return notYetImplemented('where');\n    }\n  }, {\n    key: \"select\",\n    value: function select(condition, a, b) {\n      return notYetImplemented('select');\n    }\n  }, {\n    key: \"topk\",\n    value: function topk(x, k, sorted) {\n      return notYetImplemented('topk');\n    }\n  }, {\n    key: \"min\",\n    value: function min(x, axes) {\n      return notYetImplemented('min');\n    }\n  }, {\n    key: \"minimum\",\n    value: function minimum(a, b) {\n      return notYetImplemented('minimum');\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(a, b) {\n      return notYetImplemented('mod');\n    }\n  }, {\n    key: \"max\",\n    value: function max(x, axes) {\n      return notYetImplemented('max');\n    }\n  }, {\n    key: \"maximum\",\n    value: function maximum(a, b) {\n      return notYetImplemented('maximum');\n    }\n  }, {\n    key: \"all\",\n    value: function all(x, axes) {\n      return notYetImplemented('all');\n    }\n  }, {\n    key: \"any\",\n    value: function any(x, axes) {\n      return notYetImplemented('any');\n    }\n  }, {\n    key: \"squaredDifference\",\n    value: function squaredDifference(a, b) {\n      return notYetImplemented('squaredDifference');\n    }\n  }, {\n    key: \"ceil\",\n    value: function ceil(x) {\n      return notYetImplemented('ceil');\n    }\n  }, {\n    key: \"floor\",\n    value: function floor(x) {\n      return notYetImplemented('floor');\n    }\n  }, {\n    key: \"round\",\n    value: function round(x) {\n      return notYetImplemented('round');\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(x) {\n      return notYetImplemented('sign');\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN(x) {\n      return notYetImplemented('isNaN');\n    }\n  }, {\n    key: \"isInf\",\n    value: function isInf(x) {\n      return notYetImplemented('isInf');\n    }\n  }, {\n    key: \"isFinite\",\n    value: function isFinite(x) {\n      return notYetImplemented('isFinite');\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(a, b) {\n      return notYetImplemented('pow');\n    }\n  }, {\n    key: \"exp\",\n    value: function exp(x) {\n      return notYetImplemented('exp');\n    }\n  }, {\n    key: \"expm1\",\n    value: function expm1(x) {\n      return notYetImplemented('expm1');\n    }\n  }, {\n    key: \"softmax\",\n    value: function softmax(x, dim) {\n      return notYetImplemented('softmax');\n    }\n  }, {\n    key: \"log\",\n    value: function log(x) {\n      return notYetImplemented('log');\n    }\n  }, {\n    key: \"log1p\",\n    value: function log1p(x) {\n      return notYetImplemented('log1p');\n    }\n  }, {\n    key: \"sqrt\",\n    value: function sqrt(x) {\n      return notYetImplemented('sqrt');\n    }\n  }, {\n    key: \"rsqrt\",\n    value: function rsqrt(x) {\n      return notYetImplemented('rsqrt');\n    }\n  }, {\n    key: \"square\",\n    value: function square(x) {\n      return notYetImplemented('square');\n    }\n  }, {\n    key: \"reciprocal\",\n    value: function reciprocal(x) {\n      return notYetImplemented('reciprocal');\n    }\n  }, {\n    key: \"relu\",\n    value: function relu(x) {\n      return notYetImplemented('relu');\n    }\n  }, {\n    key: \"relu6\",\n    value: function relu6(x) {\n      return notYetImplemented('relu6');\n    }\n  }, {\n    key: \"prelu\",\n    value: function prelu(x, a) {\n      return notYetImplemented('prelu');\n    }\n  }, {\n    key: \"elu\",\n    value: function elu(x) {\n      return notYetImplemented('elu');\n    }\n  }, {\n    key: \"eluDer\",\n    value: function eluDer(dy, y) {\n      return notYetImplemented('eluDer');\n    }\n  }, {\n    key: \"selu\",\n    value: function selu(x) {\n      return notYetImplemented('selu');\n    }\n  }, {\n    key: \"int\",\n    value: function int(x) {\n      return notYetImplemented('int');\n    }\n  }, {\n    key: \"clip\",\n    value: function clip(x, min, max) {\n      return notYetImplemented('clip');\n    }\n  }, {\n    key: \"abs\",\n    value: function abs(x) {\n      return notYetImplemented('abs');\n    }\n  }, {\n    key: \"complexAbs\",\n    value: function complexAbs(x) {\n      return notYetImplemented('complexAbs');\n    }\n  }, {\n    key: \"sigmoid\",\n    value: function sigmoid(x) {\n      return notYetImplemented('sigmoid');\n    }\n  }, {\n    key: \"softplus\",\n    value: function softplus(x) {\n      return notYetImplemented('softplus');\n    }\n  }, {\n    key: \"sin\",\n    value: function sin(x) {\n      return notYetImplemented('sin');\n    }\n  }, {\n    key: \"cos\",\n    value: function cos(x) {\n      return notYetImplemented('cos');\n    }\n  }, {\n    key: \"tan\",\n    value: function tan(x) {\n      return notYetImplemented('tan');\n    }\n  }, {\n    key: \"asin\",\n    value: function asin(x) {\n      return notYetImplemented('asin');\n    }\n  }, {\n    key: \"acos\",\n    value: function acos(x) {\n      return notYetImplemented('acos');\n    }\n  }, {\n    key: \"atan\",\n    value: function atan(x) {\n      return notYetImplemented('atan');\n    }\n  }, {\n    key: \"atan2\",\n    value: function atan2(a, b) {\n      return notYetImplemented('atan2');\n    }\n  }, {\n    key: \"sinh\",\n    value: function sinh(x) {\n      return notYetImplemented('sinh');\n    }\n  }, {\n    key: \"cosh\",\n    value: function cosh(x) {\n      return notYetImplemented('cosh');\n    }\n  }, {\n    key: \"tanh\",\n    value: function tanh(x) {\n      return notYetImplemented('tanh');\n    }\n  }, {\n    key: \"asinh\",\n    value: function asinh(x) {\n      return notYetImplemented('asinh');\n    }\n  }, {\n    key: \"acosh\",\n    value: function acosh(x) {\n      return notYetImplemented('acosh');\n    }\n  }, {\n    key: \"atanh\",\n    value: function atanh(x) {\n      return notYetImplemented('atanh');\n    }\n  }, {\n    key: \"erf\",\n    value: function erf(x) {\n      return notYetImplemented('erf');\n    }\n  }, {\n    key: \"step\",\n    value: function step(x, alpha) {\n      return notYetImplemented('step');\n    }\n  }, {\n    key: \"fusedConv2d\",\n    value: function fusedConv2d(_ref2) {\n      var input = _ref2.input,\n          filter = _ref2.filter,\n          convInfo = _ref2.convInfo,\n          bias = _ref2.bias,\n          activation = _ref2.activation,\n          preluActivationWeights = _ref2.preluActivationWeights;\n      return notYetImplemented('fusedConv2d');\n    }\n  }, {\n    key: \"conv2d\",\n    value: function conv2d(x, filter, convInfo) {\n      return notYetImplemented('conv2d');\n    }\n  }, {\n    key: \"conv2dDerInput\",\n    value: function conv2dDerInput(dy, filter, convInfo) {\n      return notYetImplemented('conv2dDerInput');\n    }\n  }, {\n    key: \"conv2dDerFilter\",\n    value: function conv2dDerFilter(x, dY, convInfo) {\n      return notYetImplemented('conv2dDerFilter');\n    }\n  }, {\n    key: \"fusedDepthwiseConv2D\",\n    value: function fusedDepthwiseConv2D(_ref3) {\n      var input = _ref3.input,\n          filter = _ref3.filter,\n          convInfo = _ref3.convInfo,\n          bias = _ref3.bias,\n          activation = _ref3.activation,\n          preluActivationWeights = _ref3.preluActivationWeights;\n      return notYetImplemented('fusedDepthwiseConv2D');\n    }\n  }, {\n    key: \"depthwiseConv2D\",\n    value: function depthwiseConv2D(input, filter, convInfo) {\n      return notYetImplemented('depthwiseConv2D');\n    }\n  }, {\n    key: \"depthwiseConv2DDerInput\",\n    value: function depthwiseConv2DDerInput(dy, filter, convInfo) {\n      return notYetImplemented('depthwiseConv2DDerInput');\n    }\n  }, {\n    key: \"depthwiseConv2DDerFilter\",\n    value: function depthwiseConv2DDerFilter(x, dY, convInfo) {\n      return notYetImplemented('depthwiseConv2DDerFilter');\n    }\n  }, {\n    key: \"conv3d\",\n    value: function conv3d(x, filter, convInfo) {\n      return notYetImplemented('conv3d');\n    }\n  }, {\n    key: \"conv3dDerInput\",\n    value: function conv3dDerInput(dy, filter, convInfo) {\n      return notYetImplemented('conv3dDerInput');\n    }\n  }, {\n    key: \"conv3dDerFilter\",\n    value: function conv3dDerFilter(x, dY, convInfo) {\n      return notYetImplemented('conv3dDerFilter');\n    }\n  }, {\n    key: \"maxPool\",\n    value: function maxPool(x, convInfo) {\n      return notYetImplemented('maxPool');\n    }\n  }, {\n    key: \"maxPoolBackprop\",\n    value: function maxPoolBackprop(dy, x, y, convInfo) {\n      return notYetImplemented('maxPoolBackprop');\n    }\n  }, {\n    key: \"avgPool\",\n    value: function avgPool(x, convInfo) {\n      return notYetImplemented('avgPool');\n    }\n  }, {\n    key: \"avgPoolBackprop\",\n    value: function avgPoolBackprop(dy, x, convInfo) {\n      return notYetImplemented('avgPoolBackprop');\n    }\n  }, {\n    key: \"avgPool3d\",\n    value: function avgPool3d(x, convInfo) {\n      return notYetImplemented('avgPool3d');\n    }\n  }, {\n    key: \"avgPool3dBackprop\",\n    value: function avgPool3dBackprop(dy, x, convInfo) {\n      return notYetImplemented('avgPool3dBackprop');\n    }\n  }, {\n    key: \"maxPool3d\",\n    value: function maxPool3d(x, convInfo) {\n      return notYetImplemented('maxPool3d');\n    }\n  }, {\n    key: \"maxPool3dBackprop\",\n    value: function maxPool3dBackprop(dy, x, y, convInfo) {\n      return notYetImplemented('maxPool3dBackprop');\n    }\n  }, {\n    key: \"reshape\",\n    value: function reshape(x, shape) {\n      return notYetImplemented('reshape');\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(x, dtype) {\n      return notYetImplemented('cast');\n    }\n  }, {\n    key: \"tile\",\n    value: function tile(x, reps) {\n      return notYetImplemented('tile');\n    }\n  }, {\n    key: \"pad\",\n    value: function pad(x, paddings, constantValue) {\n      return notYetImplemented('pad');\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose(x, perm) {\n      return notYetImplemented('transpose');\n    }\n  }, {\n    key: \"gather\",\n    value: function gather(x, indices, axis) {\n      return notYetImplemented('gather');\n    }\n  }, {\n    key: \"gatherND\",\n    value: function gatherND(x, indices) {\n      return notYetImplemented('gatherND');\n    }\n  }, {\n    key: \"scatterND\",\n    value: function scatterND(indices, updates, shape) {\n      return notYetImplemented('scatterND');\n    }\n  }, {\n    key: \"batchToSpaceND\",\n    value: function batchToSpaceND(x, blockShape, crops) {\n      return notYetImplemented('batchToSpaceND');\n    }\n  }, {\n    key: \"spaceToBatchND\",\n    value: function spaceToBatchND(x, blockShape, paddings) {\n      return notYetImplemented('spaceToBatchND');\n    }\n  }, {\n    key: \"resizeBilinear\",\n    value: function resizeBilinear(x, newHeight, newWidth, alignCorners) {\n      return notYetImplemented('resizeBilinear');\n    }\n  }, {\n    key: \"resizeBilinearBackprop\",\n    value: function resizeBilinearBackprop(dy, x, alignCorners) {\n      return notYetImplemented('resizeBilinearBackprop');\n    }\n  }, {\n    key: \"resizeNearestNeighbor\",\n    value: function resizeNearestNeighbor(x, newHEight, newWidth, alignCorners) {\n      return notYetImplemented('resizeNearestNeighbor');\n    }\n  }, {\n    key: \"resizeNearestNeighborBackprop\",\n    value: function resizeNearestNeighborBackprop(dy, x, alignCorners) {\n      return notYetImplemented('resizeNearestNeighborBackprop');\n    }\n  }, {\n    key: \"batchNorm\",\n    value: function batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n      return notYetImplemented('batchNorm');\n    }\n  }, {\n    key: \"localResponseNormalization4D\",\n    value: function localResponseNormalization4D(x, radius, bias, alpha, beta) {\n      return notYetImplemented('localResponseNormalization4D');\n    }\n  }, {\n    key: \"LRNGrad\",\n    value: function LRNGrad(dy, inputImage, outputImage, radius, bias, alpha, beta) {\n      return notYetImplemented('LRNGrad');\n    }\n  }, {\n    key: \"multinomial\",\n    value: function multinomial(logits, normalized, numSamples, seed) {\n      return notYetImplemented('multinomial');\n    }\n  }, {\n    key: \"oneHot\",\n    value: function oneHot(indices, depth, onValue, offValue) {\n      return notYetImplemented('oneHot');\n    }\n  }, {\n    key: \"cumsum\",\n    value: function cumsum(x, axis, exclusive, reverse) {\n      return notYetImplemented('cumsum');\n    }\n  }, {\n    key: \"nonMaxSuppression\",\n    value: function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n      return notYetImplemented('nonMaxSuppression');\n    }\n  }, {\n    key: \"fft\",\n    value: function fft(x) {\n      return notYetImplemented('fft');\n    }\n  }, {\n    key: \"ifft\",\n    value: function ifft(x) {\n      return notYetImplemented('ifft');\n    }\n  }, {\n    key: \"complex\",\n    value: function complex(real, imag) {\n      return notYetImplemented('complex');\n    }\n  }, {\n    key: \"real\",\n    value: function real(input) {\n      return notYetImplemented('real');\n    }\n  }, {\n    key: \"imag\",\n    value: function imag(input) {\n      return notYetImplemented('imag');\n    }\n  }, {\n    key: \"cropAndResize\",\n    value: function cropAndResize(image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n      return notYetImplemented('cropAndResize');\n    }\n  }, {\n    key: \"depthToSpace\",\n    value: function depthToSpace(x, blockSize, dataFormat) {\n      return notYetImplemented('depthToSpace');\n    } // Aligns with the \"SplitV\" kernel in TensorFlow.\n\n  }, {\n    key: \"split\",\n    value: function split(value, sizeSplits, axis) {\n      return notYetImplemented('split');\n    }\n  }, {\n    key: \"sparseToDense\",\n    value: function sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n      return notYetImplemented('sparseToDense');\n    }\n  }, {\n    key: \"diag\",\n    value: function diag(x) {\n      return notYetImplemented('diag');\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(shape, value, dtype) {\n      return notYetImplemented('fill');\n    }\n  }, {\n    key: \"onesLike\",\n    value: function onesLike(x) {\n      return notYetImplemented('onesLike');\n    }\n  }, {\n    key: \"zerosLike\",\n    value: function zerosLike(x) {\n      return notYetImplemented('zerosLike');\n    }\n  }, {\n    key: \"linspace\",\n    value: function linspace(start, stop, num) {\n      return notYetImplemented('linspace');\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      return notYetImplemented('dispose');\n    }\n  }]);\n\n  return KernelBackend;\n}();\n\nfunction notYetImplemented(kernelName) {\n  throw new Error(\"'\".concat(kernelName, \"' not yet implemented or not found in the registry. \") + \"This kernel may not be supported by the tfjs backend you have chosen\");\n}","map":null,"metadata":{},"sourceType":"module"}