{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar mkdirp = require('mkdirp');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar chownr = require('chownr');\n\nvar SymlinkError = /*#__PURE__*/function (_Error) {\n  _inherits(SymlinkError, _Error);\n\n  function SymlinkError(symlink, path) {\n    var _this;\n\n    _classCallCheck(this, SymlinkError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SymlinkError).call(this, 'Cannot extract through symbolic link'));\n    _this.path = path;\n    _this.symlink = symlink;\n    return _this;\n  }\n\n  _createClass(SymlinkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'SylinkError';\n    }\n  }]);\n\n  return SymlinkError;\n}(_wrapNativeSuper(Error));\n\nvar CwdError = /*#__PURE__*/function (_Error2) {\n  _inherits(CwdError, _Error2);\n\n  function CwdError(path, code) {\n    var _this2;\n\n    _classCallCheck(this, CwdError);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CwdError).call(this, code + ': Cannot cd into \\'' + path + '\\''));\n    _this2.path = path;\n    _this2.code = code;\n    return _this2;\n  }\n\n  _createClass(CwdError, [{\n    key: \"name\",\n    get: function get() {\n      return 'CwdError';\n    }\n  }]);\n\n  return CwdError;\n}(_wrapNativeSuper(Error));\n\nvar mkdir = module.exports = function (dir, opt, cb) {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = opt.cwd;\n\n  var done = function done(er, created) {\n    if (er) cb(er);else {\n      cache.set(dir, true);\n      if (created && doChown) chownr(created, uid, gid, function (er) {\n        return done(er);\n      });else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n  if (dir === cwd) return fs.stat(dir, function (er, st) {\n    if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    done(er);\n  });\n  if (preserve) return mkdirp(dir, mode, done);\n  var sub = path.relative(cwd, dir);\n  var parts = sub.split(/\\/|\\\\/);\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nvar mkdir_ = function mkdir_(base, parts, mode, cache, unlink, cwd, created, cb) {\n  if (!parts.length) return cb(null, created);\n  var p = parts.shift();\n  var part = base + '/' + p;\n  if (cache.get(part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nvar onmkdir = function onmkdir(part, parts, mode, cache, unlink, cwd, created, cb) {\n  return function (er) {\n    if (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return cb(new CwdError(cwd, er.code));\n      fs.lstat(part, function (statEr, st) {\n        if (statEr) cb(statEr);else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) fs.unlink(part, function (er) {\n          if (er) return cb(er);\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n        });else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n      });\n    } else {\n      created = created || part;\n      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n  };\n};\n\nvar mkdirSync = module.exports.sync = function (dir, opt) {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = opt.cwd;\n\n  var done = function done(created) {\n    cache.set(dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    var ok = false;\n    var code = 'ENOTDIR';\n\n    try {\n      ok = fs.statSync(dir).isDirectory();\n    } catch (er) {\n      code = er.code;\n    } finally {\n      if (!ok) throw new CwdError(dir, code);\n    }\n\n    done();\n    return;\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  var sub = path.relative(cwd, dir);\n  var parts = sub.split(/\\/|\\\\/);\n  var created = null;\n\n  for (var p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    if (cache.get(part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cache.set(part, true);\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return new CwdError(cwd, er.code);\n      var st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cache.set(part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cache.set(part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":null,"metadata":{},"sourceType":"script"}