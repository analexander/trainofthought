{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EE = require('events');\n\nvar Yallist = require('yallist');\n\nvar SD = require('string_decoder').StringDecoder;\n\nvar EOF = Symbol('EOF');\nvar MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nvar EMITTED_END = Symbol('emittedEnd');\nvar EMITTING_END = Symbol('emittingEnd');\nvar CLOSED = Symbol('closed');\nvar READ = Symbol('read');\nvar FLUSH = Symbol('flush');\nvar FLUSHCHUNK = Symbol('flushChunk');\nvar ENCODING = Symbol('encoding');\nvar DECODER = Symbol('decoder');\nvar FLOWING = Symbol('flowing');\nvar PAUSED = Symbol('paused');\nvar RESUME = Symbol('resume');\nvar BUFFERLENGTH = Symbol('bufferLength');\nvar BUFFERPUSH = Symbol('bufferPush');\nvar BUFFERSHIFT = Symbol('bufferShift');\nvar OBJECTMODE = Symbol('objectMode');\nvar DESTROYED = Symbol('destroyed'); // TODO remove when Node v8 support drops\n\nvar doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nvar ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nvar ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\n\nvar B = Buffer.alloc ? Buffer :\n/* istanbul ignore next */\nrequire('safe-buffer').Buffer; // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nvar isEndish = function isEndish(ev) {\n  return ev === 'end' || ev === 'finish' || ev === 'prefinish';\n};\n\nvar isArrayBuffer = function isArrayBuffer(b) {\n  return b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n};\n\nvar isArrayBufferView = function isArrayBufferView(b) {\n  return !B.isBuffer(b) && ArrayBuffer.isView(b);\n};\n\nmodule.exports = /*#__PURE__*/function (_EE) {\n  _inherits(Minipass, _EE);\n\n  function Minipass(options) {\n    var _this;\n\n    _classCallCheck(this, Minipass);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Minipass).call(this));\n    _this[FLOWING] = false; // whether we're explicitly paused\n\n    _this[PAUSED] = false;\n    _this.pipes = new Yallist();\n    _this.buffer = new Yallist();\n    _this[OBJECTMODE] = options && options.objectMode || false;\n    if (_this[OBJECTMODE]) _this[ENCODING] = null;else _this[ENCODING] = options && options.encoding || null;\n    if (_this[ENCODING] === 'buffer') _this[ENCODING] = null;\n    _this[DECODER] = _this[ENCODING] ? new SD(_this[ENCODING]) : null;\n    _this[EOF] = false;\n    _this[EMITTED_END] = false;\n    _this[EMITTING_END] = false;\n    _this[CLOSED] = false;\n    _this.writable = true;\n    _this.readable = true;\n    _this[BUFFERLENGTH] = 0;\n    _this[DESTROYED] = false;\n    return _this;\n  }\n\n  _createClass(Minipass, [{\n    key: \"setEncoding\",\n    value: function setEncoding(enc) {\n      this.encoding = enc;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      if (this[EOF]) throw new Error('write after end');\n\n      if (this[DESTROYED]) {\n        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n          code: 'ERR_STREAM_DESTROYED'\n        }));\n        return true;\n      }\n\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (!encoding) encoding = 'utf8'; // convert array buffers and typed array views into buffers\n      // at some point in the future, we may want to do the opposite!\n      // leave strings and buffers as-is\n      // anything else switches us into object mode\n\n      if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n        if (isArrayBufferView(chunk)) chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = B.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n          this.objectMode = true;\n      } // this ensures at this point that the chunk is a buffer or string\n      // don't buffer it up or send it to the decoder\n\n\n      if (!this.objectMode && !chunk.length) {\n        var ret = this.flowing;\n        if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n        if (cb) cb();\n        return ret;\n      } // fast-path writing strings of same encoding to a stream with\n      // an empty buffer, skipping the buffer/decoder dance\n\n\n      if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n        chunk = B.from(chunk, encoding);\n      }\n\n      if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n      try {\n        return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);\n      } finally {\n        if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n        if (cb) cb();\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(n) {\n      if (this[DESTROYED]) return null;\n\n      try {\n        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n        if (this[OBJECTMODE]) n = null;\n\n        if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n          if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n        }\n\n        return this[READ](n || null, this.buffer.head.value);\n      } finally {\n        this[MAYBE_EMIT_END]();\n      }\n    }\n  }, {\n    key: READ,\n    value: function value(n, chunk) {\n      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n        this.buffer.head.value = chunk.slice(n);\n        chunk = chunk.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n      this.emit('data', chunk);\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n      return chunk;\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (typeof chunk === 'function') cb = chunk, chunk = null;\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (chunk) this.write(chunk, encoding);\n      if (cb) this.once('end', cb);\n      this[EOF] = true;\n      this.writable = false; // if we haven't written anything, then go ahead and emit,\n      // even if we're not reading.\n      // we'll re-emit if a new 'end' listener is added anyway.\n      // This makes MP more suitable to write-only use cases.\n\n      if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n      return this;\n    } // don't let the internal resume be overwritten\n\n  }, {\n    key: RESUME,\n    value: function value() {\n      if (this[DESTROYED]) return;\n      this[PAUSED] = false;\n      this[FLOWING] = true;\n      this.emit('resume');\n      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      return this[RESUME]();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this[FLOWING] = false;\n      this[PAUSED] = true;\n    }\n  }, {\n    key: BUFFERPUSH,\n    value: function value(chunk) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n      return this.buffer.push(chunk);\n    }\n  }, {\n    key: BUFFERSHIFT,\n    value: function value() {\n      if (this.buffer.length) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n      }\n\n      return this.buffer.shift();\n    }\n  }, {\n    key: FLUSH,\n    value: function value() {\n      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    }\n  }, {\n    key: FLUSHCHUNK,\n    value: function value(chunk) {\n      return chunk ? (this.emit('data', chunk), this.flowing) : false;\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(dest, opts) {\n      var _this2 = this;\n\n      if (this[DESTROYED]) return;\n      var ended = this[EMITTED_END];\n      opts = opts || {};\n      if (dest === process.stdout || dest === process.stderr) opts.end = false;else opts.end = opts.end !== false;\n      var p = {\n        dest: dest,\n        opts: opts,\n        ondrain: function ondrain(_) {\n          return _this2[RESUME]();\n        }\n      };\n      this.pipes.push(p);\n      dest.on('drain', p.ondrain);\n      this[RESUME](); // piping an ended stream ends immediately\n\n      if (ended && p.opts.end) p.dest.end();\n      return dest;\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(ev, fn) {\n      return this.on(ev, fn);\n    }\n  }, {\n    key: \"on\",\n    value: function on(ev, fn) {\n      try {\n        return _get(_getPrototypeOf(Minipass.prototype), \"on\", this).call(this, ev, fn);\n      } finally {\n        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (isEndish(ev) && this[EMITTED_END]) {\n          _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, ev);\n\n          this.removeAllListeners(ev);\n        }\n      }\n    }\n  }, {\n    key: MAYBE_EMIT_END,\n    value: function value() {\n      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n        this[EMITTING_END] = true;\n        this.emit('end');\n        this.emit('prefinish');\n        this.emit('finish');\n        if (this[CLOSED]) this.emit('close');\n        this[EMITTING_END] = false;\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      var _this3 = this;\n\n      // error and close are only events allowed after calling destroy()\n      if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n        if (!data) return;\n        if (this.pipes.length) this.pipes.forEach(function (p) {\n          return p.dest.write(data) === false && _this3.pause();\n        });\n      } else if (ev === 'end') {\n        // only actual end gets this treatment\n        if (this[EMITTED_END] === true) return;\n        this[EMITTED_END] = true;\n        this.readable = false;\n\n        if (this[DECODER]) {\n          data = this[DECODER].end();\n\n          if (data) {\n            this.pipes.forEach(function (p) {\n              return p.dest.write(data);\n            });\n\n            _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'data', data);\n          }\n        }\n\n        this.pipes.forEach(function (p) {\n          p.dest.removeListener('drain', p.ondrain);\n          if (p.opts.end) p.dest.end();\n        });\n      } else if (ev === 'close') {\n        this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n        if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      } // TODO: replace with a spread operator when Node v4 support drops\n\n      var args = new Array(arguments.length);\n      args[0] = ev;\n      args[1] = data;\n\n      if (arguments.length > 2) {\n        for (var i = 2; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n      }\n\n      try {\n        return _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).apply(this, args);\n      } finally {\n        if (!isEndish(ev)) this[MAYBE_EMIT_END]();else this.removeAllListeners(ev);\n      }\n    } // const all = await stream.collect()\n\n  }, {\n    key: \"collect\",\n    value: function collect() {\n      var buf = [];\n      buf.dataLength = 0;\n      this.on('data', function (c) {\n        buf.push(c);\n        buf.dataLength += c.length;\n      });\n      return this.promise().then(function () {\n        return buf;\n      });\n    } // const data = await stream.concat()\n\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this4 = this;\n\n      return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(function (buf) {\n        return _this4[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : _this4[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength);\n      });\n    } // stream.promise().then(() => done, er => emitted error)\n\n  }, {\n    key: \"promise\",\n    value: function promise() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5.on(DESTROYED, function () {\n          return reject(new Error('stream destroyed'));\n        });\n\n        _this5.on('end', function () {\n          return resolve();\n        });\n\n        _this5.on('error', function (er) {\n          return reject(er);\n        });\n      });\n    } // for await (let chunk of stream)\n\n  }, {\n    key: ASYNCITERATOR,\n    value: function value() {\n      var _this6 = this;\n\n      var next = function next() {\n        var res = _this6.read();\n\n        if (res !== null) return Promise.resolve({\n          done: false,\n          value: res\n        });\n        if (_this6[EOF]) return Promise.resolve({\n          done: true\n        });\n        var resolve = null;\n        var reject = null;\n\n        var onerr = function onerr(er) {\n          _this6.removeListener('data', ondata);\n\n          _this6.removeListener('end', onend);\n\n          reject(er);\n        };\n\n        var ondata = function ondata(value) {\n          _this6.removeListener('error', onerr);\n\n          _this6.removeListener('end', onend);\n\n          _this6.pause();\n\n          resolve({\n            value: value,\n            done: !!_this6[EOF]\n          });\n        };\n\n        var onend = function onend() {\n          _this6.removeListener('error', onerr);\n\n          _this6.removeListener('data', ondata);\n\n          resolve({\n            done: true\n          });\n        };\n\n        var ondestroy = function ondestroy() {\n          return onerr(new Error('stream destroyed'));\n        };\n\n        return new Promise(function (res, rej) {\n          reject = rej;\n          resolve = res;\n\n          _this6.once(DESTROYED, ondestroy);\n\n          _this6.once('error', onerr);\n\n          _this6.once('end', onend);\n\n          _this6.once('data', ondata);\n        });\n      };\n\n      return {\n        next: next\n      };\n    } // for (let chunk of stream)\n\n  }, {\n    key: ITERATOR,\n    value: function value() {\n      var _this7 = this;\n\n      var next = function next() {\n        var value = _this7.read();\n\n        var done = value === null;\n        return {\n          value: value,\n          done: done\n        };\n      };\n\n      return {\n        next: next\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(er) {\n      if (this[DESTROYED]) {\n        if (er) this.emit('error', er);else this.emit(DESTROYED);\n        return this;\n      }\n\n      this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n      this.buffer = new Yallist();\n      this[BUFFERLENGTH] = 0;\n      if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n      if (er) this.emit('error', er);else // if no error to emit, still reject pending promises\n        this.emit(DESTROYED);\n      return this;\n    }\n  }, {\n    key: \"bufferLength\",\n    get: function get() {\n      return this[BUFFERLENGTH];\n    }\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this[ENCODING];\n    },\n    set: function set(enc) {\n      var _this8 = this;\n\n      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n      if (this[ENCODING] !== enc) {\n        this[DECODER] = enc ? new SD(enc) : null;\n        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {\n          return _this8[DECODER].write(chunk);\n        });\n      }\n\n      this[ENCODING] = enc;\n    }\n  }, {\n    key: \"objectMode\",\n    get: function get() {\n      return this[OBJECTMODE];\n    },\n    set: function set(ॐ) {\n      this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this[DESTROYED];\n    }\n  }, {\n    key: \"flowing\",\n    get: function get() {\n      return this[FLOWING];\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this[PAUSED];\n    }\n  }, {\n    key: \"emittedEnd\",\n    get: function get() {\n      return this[EMITTED_END];\n    }\n  }], [{\n    key: \"isStream\",\n    value: function isStream(s) {\n      return !!s && (s instanceof Minipass || s instanceof EE && (typeof s.pipe === 'function' || // readable\n      typeof s.write === 'function' && typeof s.end === 'function' // writable\n      ));\n    }\n  }]);\n\n  return Minipass;\n}(EE);","map":null,"metadata":{},"sourceType":"script"}