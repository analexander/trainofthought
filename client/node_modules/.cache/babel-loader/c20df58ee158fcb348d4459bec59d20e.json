{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport { binaryCrossentropy as lossBinaryCrossentropy } from './losses';\nimport { lossesMap } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n  return tidy(function () {\n    var threshold = tfc.mul(.5, tfc.onesLike(yPred));\n    var yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n    return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n  });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n  return tidy(function () {\n    return K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32');\n  });\n}\n\nfunction truePositives(yTrue, yPred) {\n  return tidy(function () {\n    return tfc.logicalAnd(yTrue.equal(1), yPred.equal(1)).sum().cast('float32');\n  });\n}\n\nfunction falseNegatives(yTrue, yPred) {\n  return tidy(function () {\n    return tfc.logicalAnd(yTrue.equal(1), yPred.equal(0)).sum().cast('float32');\n  });\n}\n\nfunction falsePositives(yTrue, yPred) {\n  return tidy(function () {\n    return tfc.logicalAnd(yTrue.equal(0), yPred.equal(1)).sum().cast('float32');\n  });\n}\n\nexport function precision(yTrue, yPred) {\n  return tidy(function () {\n    var tp = truePositives(yTrue, yPred);\n    var fp = falsePositives(yTrue, yPred);\n    var denominator = tp.add(fp);\n    return tfc.where(tfc.greater(denominator, 0), tp.div(denominator), 0).cast('float32');\n  });\n}\nexport function recall(yTrue, yPred) {\n  return tidy(function () {\n    var tp = truePositives(yTrue, yPred);\n    var fn = falseNegatives(yTrue, yPred);\n    var denominator = tp.add(fn);\n    return tfc.where(tfc.greater(denominator, 0), tp.div(denominator), 0).cast('float32');\n  });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n  return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n  if (yTrue.rank === yPred.rank) {\n    yTrue = yTrue.squeeze([yTrue.rank - 1]);\n  }\n\n  yPred = yPred.argMax(-1);\n\n  if (yPred.dtype !== yTrue.dtype) {\n    yPred = yPred.asType(yTrue.dtype);\n  }\n\n  return tfc.equal(yTrue, yPred).asType('float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n} // Aliases.\n\nexport var mse = meanSquaredError;\nexport var MSE = meanSquaredError;\nexport var mae = meanAbsoluteError;\nexport var MAE = meanAbsoluteError;\nexport var mape = meanAbsolutePercentageError;\nexport var MAPE = meanAbsolutePercentageError;\nexport var categoricalCrossentropy = categoricalCrossentropyLoss;\nexport var cosine = cosineProximity;\nexport var sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss; // TODO(cais, nielsene): Add serialize().\n\nexport var metricsMap = {\n  binaryAccuracy: binaryAccuracy,\n  categoricalAccuracy: categoricalAccuracy,\n  precision: precision,\n  categoricalCrossentropy: categoricalCrossentropy,\n  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,\n  mse: mse,\n  MSE: MSE,\n  mae: mae,\n  MAE: MAE,\n  mape: mape,\n  MAPE: MAPE,\n  cosine: cosine\n};\nexport function get(identifier) {\n  if (typeof identifier === 'string' && identifier in metricsMap) {\n    return metricsMap[identifier];\n  } else if (typeof identifier !== 'string' && identifier != null) {\n    return identifier;\n  } else {\n    throw new ValueError(\"Unknown metric \".concat(identifier));\n  }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\n\nexport function getLossOrMetricName(fn) {\n  util.assert(fn !== null, \"Unknown LossOrMetricFn \".concat(fn));\n\n  if (typeof fn === 'string') {\n    return fn;\n  } else {\n    var fnName;\n\n    for (var _i = 0, _Object$keys = Object.keys(lossesMap); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (lossesMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    for (var _i2 = 0, _Object$keys2 = Object.keys(metricsMap); _i2 < _Object$keys2.length; _i2++) {\n      var _key = _Object$keys2[_i2];\n\n      if (metricsMap[_key] === fn) {\n        fnName = _key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    return fn.name;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}