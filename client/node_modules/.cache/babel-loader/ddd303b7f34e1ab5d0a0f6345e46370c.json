{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, upcastType } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { complex } from '../kernels/Complex';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport var CHECK_NAN_SNIPPET_UNARY = \"if (isnan(x)) return x;\";\nexport var CHECK_NAN_SNIPPET_BINARY = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nexport var CHECK_NAN_SNIPPET_BINARY_PACKED = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\n\nexport function unaryKernelFunc(opSnippet) {\n  return function (_ref) {\n    var inputs = _ref.inputs,\n        backend = _ref.backend;\n    var x = inputs.x;\n    var webglBackend = backend;\n    var program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\n\nexport function binaryKernelFunc(_ref2) {\n  var opSnippet = _ref2.opSnippet,\n      packedOpSnippet = _ref2.packedOpSnippet,\n      _ref2$checkOutOfBound = _ref2.checkOutOfBounds,\n      checkOutOfBounds = _ref2$checkOutOfBound === void 0 ? false : _ref2$checkOutOfBound,\n      _ref2$supportsComplex = _ref2.supportsComplex,\n      supportsComplex = _ref2$supportsComplex === void 0 ? false : _ref2$supportsComplex,\n      cpuKernelImpl = _ref2.cpuKernelImpl,\n      dtype = _ref2.dtype;\n  return function (_ref3) {\n    var inputs = _ref3.inputs,\n        backend = _ref3.backend;\n    var a = inputs.a,\n        b = inputs.b;\n    var webglBackend = backend;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      var aData = webglBackend.texData.get(a.dataId);\n      var bData = webglBackend.texData.get(b.dataId);\n\n      var _map = [[aData.complexTensorInfos.real, bData.complexTensorInfos.real], [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]].map(function (complexParts) {\n        var _complexParts = _slicedToArray(complexParts, 2),\n            aPart = _complexParts[0],\n            bPart = _complexParts[1];\n\n        var aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        var bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n        var program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      }),\n          _map2 = _slicedToArray(_map, 2),\n          real = _map2[0],\n          imag = _map2[1];\n\n      var complexOutput = complex({\n        inputs: {\n          real: real,\n          imag: imag\n        },\n        backend: webglBackend\n      });\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag); // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    var $dtype = dtype || upcastType(a.dtype, b.dtype);\n\n    if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {\n      var _aData = webglBackend.texData.get(a.dataId);\n\n      var _bData = webglBackend.texData.get(b.dataId);\n\n      var _cpuKernelImpl = cpuKernelImpl(a.shape, b.shape, _aData.values, _bData.values, $dtype),\n          _cpuKernelImpl2 = _slicedToArray(_cpuKernelImpl, 2),\n          outValues = _cpuKernelImpl2[0],\n          outShape = _cpuKernelImpl2[1];\n\n      var out = webglBackend.makeTensorInfo(outShape, $dtype);\n      var outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    var shouldUsePackedProgram = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') && packedOpSnippet != null;\n    var program;\n\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}","map":null,"metadata":{},"sourceType":"module"}