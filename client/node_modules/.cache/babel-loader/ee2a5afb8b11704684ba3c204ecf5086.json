{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { customGrad } from '../gradients';\nimport { Mean } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam, sizeFromShape } from '../util';\nimport { computeOutAndReduceShapes } from './axis_util';\nimport { cast } from './cast';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { ones } from './ones';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sum } from './sum';\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\n\nfunction mean_(x) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var keepDims = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var $x = convertToTensor(x, 'x', 'mean');\n  var axes = parseAxisParam(axis, $x.shape);\n  var shapes = computeOutAndReduceShapes($x.shape, axes);\n  var reduceShape = shapes[1];\n  var reduceSize = sizeFromShape(reduceShape);\n  var inputs = {\n    x: $x\n  };\n  var attrs = {\n    axis: axis,\n    keepDims: keepDims\n  };\n\n  var forward = function forward() {\n    var reduceSizeScalar = scalar(reduceSize); // Cast if needed.\n\n    var xReduce = reduceSizeScalar.dtype === $x.dtype ? $x : cast($x, reduceSizeScalar.dtype);\n    var res = div(xReduce, reduceSizeScalar);\n    return sum(res, axis, keepDims);\n  }; // Use a custom gradient to bypass 2 gradient backprops since mean is used\n  // extremely often.\n\n\n  var customOp = customGrad(function (x) {\n    var value = ENGINE.runKernelFunc(forward, inputs, null\n    /* grad */\n    , Mean, attrs);\n\n    var gradFunc = function gradFunc(dy) {\n      var expandedDyShape = x.shape.slice();\n      axes.forEach(function (axis) {\n        expandedDyShape[axis] = 1;\n      });\n      var expandedDy = reshape(dy, expandedDyShape);\n      var derX = div(mul(expandedDy, ones(x.shape, 'float32')), reduceSize);\n      return derX;\n    };\n\n    return {\n      value: value,\n      gradFunc: gradFunc\n    };\n  });\n  return customOp($x);\n}\n\nexport var mean = op({\n  mean_: mean_\n});","map":null,"metadata":{},"sourceType":"module"}