{"ast":null,"code":"import _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Executor: Evaluates SymbolicTensor based on feeds.\n */\nimport { cast, dispose, memory, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../errors';\nimport { toList } from '../utils/generic_utils';\nimport { InputLayer } from './input_layer';\nimport { SymbolicTensor } from './topology';\n/**\n * Helper function to check the dtype and shape compatibility of a feed value.\n */\n\nfunction assertFeedCompatibility(key, val) {\n  // Check dtype compatibility.\n  if (key.dtype == null || key.dtype === val.dtype) {\n    //  a.  If types match, return val tensor as is.\n    return val;\n  }\n\n  try {\n    //  b. Attempt to convert to expected type.\n    return cast(val, key.dtype);\n  } catch (err) {\n    //  c. If conversion fails, return helpful error.\n    throw new ValueError(\"The dtype of the feed (\".concat(val.dtype, \") can not be cast to the dtype \") + \"of the key '\".concat(key.name, \"' (\").concat(key.dtype, \").\"));\n  }\n}\n/**\n * FeedDict: A mapping from unique SymbolicTensors to feed values for them.\n * A feed value is a concrete value represented as an `Tensor`.\n */\n\n\nexport var FeedDict = /*#__PURE__*/function () {\n  /**\n   * Constructor, optionally does copy-construction.\n   * @param feeds An Array of `Feed`s, or another `FeedDict`, in which case\n   *   copy-construction will be performed.\n   */\n  function FeedDict(feeds) {\n    _classCallCheck(this, FeedDict);\n\n    this.id2Value = {};\n    this.id2Mask = {};\n    this.name2Id = {};\n\n    if (feeds instanceof FeedDict) {\n      for (var id in feeds.id2Value) {\n        this.id2Value[id] = feeds.id2Value[id];\n\n        if (id in feeds.id2Mask) {\n          this.id2Mask[id] = feeds.id2Mask[id];\n        }\n      }\n    } else {\n      if (feeds == null) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper(feeds),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var feed = _step.value;\n          this.add(feed.key, feed.value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Add a key-value pair to the FeedDict.\n   *\n   * @param key The key of the feed.\n   * @param value The value of the tensor feed.\n   * @param mask The value of the mask feed (optional).\n   * @returns This `FeedDict`.\n   * @throws ValueError: If the key `SymbolicTensor` already exists in the\n   *   `FeedDict`.\n   */\n\n\n  _createClass(FeedDict, [{\n    key: \"add\",\n    value: function add(key, value, mask) {\n      if (this.id2Value[key.id] == null) {\n        this.id2Value[key.id] = assertFeedCompatibility(key, value);\n        this.name2Id[key.name] = key.id;\n\n        if (mask != null) {\n          this.id2Mask[key.id] = mask;\n        }\n      } else {\n        throw new ValueError(\"Duplicate key: name=\".concat(key.name, \", id=\").concat(key.id));\n      }\n\n      return this;\n    }\n    /**\n     * Add a Feed to the FeedDict.\n     * @param feed The new `Feed` to add.\n     * @returns This `FeedDict`.\n     */\n\n  }, {\n    key: \"addFeed\",\n    value: function addFeed(feed) {\n      this.add(feed.key, feed.value);\n    }\n    /**\n     * Probe whether a key already exists in the FeedDict.\n     * @param key\n     */\n\n  }, {\n    key: \"hasKey\",\n    value: function hasKey(key) {\n      return this.id2Value[key.id] != null;\n    }\n    /**\n     * Get all the SymbolicTensor available in this FeedDict.\n     */\n\n  }, {\n    key: \"names\",\n    value: function names() {\n      return Object.keys(this.name2Id);\n    }\n    /**\n     * Get the feed value for given key.\n     * @param key The SymbolicTensor, or its name (as a string), of which the\n     *     value is sought.\n     * @returns If `key` exists, the corresponding feed value.\n     * @throws ValueError: If `key` does not exist in this `FeedDict`.\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue(key) {\n      if (key instanceof SymbolicTensor) {\n        if (this.id2Value[key.id] == null) {\n          throw new ValueError(\"Nonexistent key: \".concat(key.name));\n        } else {\n          return this.id2Value[key.id];\n        }\n      } else {\n        var id = this.name2Id[key];\n\n        if (id == null) {\n          throw new ValueError(\"Feed dict has no SymbolicTensor name: \".concat(key));\n        }\n\n        return this.id2Value[id];\n      }\n    }\n    /**\n     * Get the feed mask for given key.\n     * @param key The SymbolicTensor, or its name (as a string), of which the\n     *     value is sought.\n     * @returns If `key` exists, the corresponding feed mask.\n     * @throws ValueError: If `key` does not exist in this `FeedDict`.\n     */\n\n  }, {\n    key: \"getMask\",\n    value: function getMask(key) {\n      if (key instanceof SymbolicTensor) {\n        if (this.id2Value[key.id] == null) {\n          throw new ValueError(\"Nonexistent key: \".concat(key.name));\n        } else {\n          return this.id2Mask[key.id];\n        }\n      } else {\n        var id = this.name2Id[key];\n\n        if (id == null) {\n          throw new ValueError(\"Feed dict has no SymbolicTensor name: \".concat(key));\n        }\n\n        return this.id2Mask[id];\n      }\n    }\n    /** Dispose all mask Tensors held by this object. */\n\n  }, {\n    key: \"disposeMasks\",\n    value: function disposeMasks() {\n      if (this.id2Mask != null) {\n        dispose(this.id2Mask);\n      }\n    }\n  }]);\n\n  return FeedDict;\n}(); // Cache for topologically sorted SymbolicTensors for given execution\n// targets (i.e., fetches).\n\nvar cachedSorted = {}; // Cache for recipient count maps for given execution targets (i.e., fetches).\n\nvar cachedRecipientCounts = {};\n/**\n * Execute a SymbolicTensor by using concrete feed values.\n *\n * A `SymbolicTensor` object is a node in a computation graph of TF.js\n * Layers. The object is backed by a source layer and input\n * `SymbolicTensor`s to the source layer. This method evaluates\n * the `call()` method of the source layer, using concrete values of the\n * inputs obtained from either\n * * `feedDict`, if the input key exists in `feedDict`, or else,\n * * a recursive call to `execute()` itself.\n *\n * @param x: The `SymbolicTensor` to execute.\n * @param feedDict: The feed values, as base condition of the recursion.\n *   execution.\n * @param kwargs: Optional keyword arguments.\n * @param probe: A probe object (of interface `ExecutionProbe`) used for\n *   testing memory footprint of `execute` calls.\n * @returns Result of the execution.\n * @throws ValueError: If any `SymbolicTensor`s from `InputLayer`s\n *   encountered during the execution lacks a feed value in `feedDict`.\n */\n\nexport function execute(fetches, feedDict, kwargs, probe) {\n  var training = kwargs == null ? false : kwargs['training'];\n  var arrayFetches = Array.isArray(fetches);\n  var fetchArray = arrayFetches ? fetches : [fetches];\n  var outputNames = fetchArray.map(function (t) {\n    return t.name;\n  });\n  var finalOutputs = [];\n  var feedNames = feedDict.names();\n\n  var _iterator2 = _createForOfIteratorHelper(outputNames),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var outputName = _step2.value;\n\n      if (feedNames.indexOf(outputName) !== -1) {\n        finalOutputs.push(feedDict.getValue(outputName));\n      } else {\n        finalOutputs.push(null);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (probe != null) {\n    // For optional probing of memory footprint during execution.\n    probe.maxNumTensors = -Infinity;\n    probe.minNumTensors = Infinity;\n  } // Check cache.\n\n\n  var fetchAndFeedKey = outputNames.join(',') + '|' + feedDict.names().join(',');\n  var sorted;\n  var recipientCounts;\n\n  if (cachedSorted[fetchAndFeedKey] == null) {\n    // Cache doesn't contain the desired combination of fetches. Compute\n    // topological sort for the combination for the first time.\n    var out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);\n    sorted = out.sorted;\n    recipientCounts = out.recipientCounts; // Store results in cache for future use.\n\n    cachedSorted[fetchAndFeedKey] = sorted;\n    cachedRecipientCounts[fetchAndFeedKey] = recipientCounts;\n  }\n\n  sorted = cachedSorted[fetchAndFeedKey];\n  recipientCounts = {};\n\n  if (!training) {\n    Object.assign(recipientCounts, cachedRecipientCounts[fetchAndFeedKey]);\n  }\n\n  var internalFeedDict = new FeedDict(feedDict); // Start iterative execution on the topologically-sorted SymbolicTensors.\n\n  for (var i = 0; i < sorted.length; ++i) {\n    if (probe != null) {\n      // For optional probing of memory usage during execution.\n      var numTensors = memory().numTensors;\n\n      if (numTensors > probe.maxNumTensors) {\n        probe.maxNumTensors = numTensors;\n      }\n\n      if (numTensors < probe.minNumTensors) {\n        probe.minNumTensors = numTensors;\n      }\n    }\n\n    var symbolic = sorted[i];\n    var srcLayer = symbolic.sourceLayer;\n\n    if (srcLayer instanceof InputLayer) {\n      continue;\n    }\n\n    var inputValues = [];\n    var inputMasks = [];\n    var tensorsToDispose = [];\n    var maskExists = false;\n\n    var _iterator3 = _createForOfIteratorHelper(symbolic.inputs),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var input = _step3.value;\n        var value = internalFeedDict.getValue(input);\n        var mask = internalFeedDict.getMask(input);\n        inputValues.push(value);\n        inputMasks.push(mask);\n\n        if (mask != null) {\n          maskExists = true;\n        }\n\n        if (!training) {\n          recipientCounts[input.name]--;\n\n          if (recipientCounts[input.name] === 0 && !feedDict.hasKey(input) && outputNames.indexOf(input.name) === -1 && !value.isDisposed && input.sourceLayer.stateful !== true) {\n            tensorsToDispose.push(value);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    if (maskExists) {\n      kwargs = kwargs || {};\n      kwargs['mask'] = inputMasks[0];\n    }\n\n    var outputTensors = toList(srcLayer.apply(inputValues, kwargs));\n    var outputMask = null;\n\n    if (srcLayer.supportsMasking) {\n      outputMask = srcLayer.computeMask(inputValues, inputMasks);\n    }\n\n    var layerOutputs = getNodeOutputs(symbolic);\n    var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];\n\n    for (var _i = 0; _i < outputSymbolicTensors.length; ++_i) {\n      if (!internalFeedDict.hasKey(outputSymbolicTensors[_i])) {\n        internalFeedDict.add(outputSymbolicTensors[_i], outputTensors[_i], Array.isArray(outputMask) ? outputMask[0] : outputMask);\n      }\n\n      var index = outputNames.indexOf(outputSymbolicTensors[_i].name);\n\n      if (index !== -1) {\n        finalOutputs[index] = outputTensors[_i];\n      }\n    }\n\n    if (!training) {\n      // Clean up Tensors that are no longer needed.\n      dispose(tensorsToDispose);\n    }\n  } // NOTE(cais): Unlike intermediate tensors, we don't discard mask\n  // tensors as we go, because these tensors are sometimes passed over a\n  // series of mutliple layers, i.e., not obeying the immediate input\n  // relations in the graph. If this becomes a memory-usage concern,\n  // we can improve this in the future.\n\n\n  internalFeedDict.disposeMasks();\n  return arrayFetches ? finalOutputs : finalOutputs[0];\n}\n/**\n * Sort the `SymbolicTensor`s topologically, for an array of fetches.\n *\n * This function calls getTopologicalSortAndRecipientCountsForOneFetch and\n * merges their results.\n *\n * @param fetch The array of fetches requested. Must be a non-empty array.\n * @param feedDict The dictionary of fed values.\n * @returns sorted: Topologically-sorted array of SymbolicTensors.\n *   recipientCounts: Recipient counts for all SymbolicTensors in `sorted`.\n */\n\nfunction getTopologicalSortAndRecipientCounts(fetches, feedDict) {\n  util.assert(fetches != null && fetches.length > 0, function () {\n    return \"Expected at least one fetch, got none\";\n  });\n  var finalSorted = [];\n  var finalRecipientMap = {};\n\n  if (fetches.length === 1) {\n    // Special-casing 1 fetch for efficiency.\n    var out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);\n    finalSorted = out.sorted;\n    finalRecipientMap = out.recipientMap;\n  } else {\n    var visited = new Set();\n\n    var _iterator4 = _createForOfIteratorHelper(fetches),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fetch = _step4.value;\n\n        var _getTopologicalSortAn = getTopologicalSortAndRecipientCountsForOneFetch(fetch, feedDict),\n            sorted = _getTopologicalSortAn.sorted,\n            recipientMap = _getTopologicalSortAn.recipientMap; // Merge sorted SymbolicTensor Arrays.\n\n\n        var _iterator5 = _createForOfIteratorHelper(sorted),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var symbolicTensor = _step5.value;\n\n            if (!visited.has(symbolicTensor.name)) {\n              finalSorted.push(symbolicTensor);\n              visited.add(symbolicTensor.name);\n            }\n          } // Merge recipient maps.\n\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        var _loop = function _loop(name) {\n          if (finalRecipientMap[name] == null) {\n            finalRecipientMap[name] = new Set();\n          }\n\n          recipientMap[name].forEach(function (recipient) {\n            return finalRecipientMap[name].add(recipient);\n          });\n        };\n\n        for (var name in recipientMap) {\n          _loop(name);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  return {\n    sorted: finalSorted,\n    recipientCounts: recipientMap2Counts(finalRecipientMap)\n  };\n}\n\nfunction recipientMap2Counts(recipientMap) {\n  var recipientCounts = {};\n\n  for (var name in recipientMap) {\n    recipientCounts[name] = recipientMap[name].size;\n  }\n\n  return recipientCounts;\n}\n/**\n * Sort the `SymbolicTensor`s topologically, for a single fetch.\n *\n * This helper function processes the upstream SymbolicTensors of a single\n * fetch.\n *\n * @param fetch The single fetch requested.\n * @param feedDict The dictionary of fed values.\n * @returns sorted: Topologically-sorted array of SymbolicTensors.\n *   recipientMap: Recipient names for all SymbolicTensors in `sorted`.\n */\n\n\nexport function getTopologicalSortAndRecipientCountsForOneFetch(fetch, feedDict) {\n  var visited = new Set();\n  var sorted = [];\n  var recipientMap = {}; // Put keys of the feedDict into visited first, so they don't have to be\n  // walked. This is needed in case where there are feeds for intermediate\n  // SymbolicTensors of the graph.\n\n  var _iterator6 = _createForOfIteratorHelper(feedDict.names()),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var key = _step6.value;\n      visited.add(key);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var stack = [];\n  var marks = []; // Initial population of stack and marks.\n\n  stack.push(fetch);\n\n  while (stack.length > 0) {\n    var top = stack[stack.length - 1];\n\n    if (visited.has(top.name)) {\n      stack.pop();\n      continue;\n    }\n\n    var topIsMarked = marks[marks.length - 1] === stack.length - 1;\n\n    if (top.inputs.length === 0 || topIsMarked) {\n      // Input SymbolicTensor or all children have been visited.\n      stack.pop();\n      sorted.push(top);\n      visited.add(top.name);\n\n      if (topIsMarked) {\n        marks.pop();\n      }\n    } else {\n      // A non-input SymbolicTensor whose upstream SymbolicTensors haven't\n      // been visited yet. Push them onto the stack.\n      marks.push(stack.length - 1);\n\n      var _iterator7 = _createForOfIteratorHelper(top.inputs),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var input = _step7.value;\n\n          // Increment the recipient count. Note that this needs to happen\n          // regardless of whether the SymbolicTensor has been visited before.\n          if (recipientMap[input.name] == null) {\n            recipientMap[input.name] = new Set();\n          }\n\n          recipientMap[input.name].add(top.name);\n\n          if (visited.has(input.name)) {\n            continue; // Avoid repeated visits to the same SymbolicTensor.\n          }\n\n          stack.push(input);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }\n\n  return {\n    sorted: sorted,\n    recipientMap: recipientMap\n  };\n}\n/**\n * Get the symbolic output tensors of the node to which a given fetch belongs.\n * @param fetch The fetched symbolic tensor.\n * @returns The Array of symbolic tensors output by the node to which `fetch`\n *   belongs.\n */\n\nfunction getNodeOutputs(fetch) {\n  var layerOutputs;\n\n  if (fetch.sourceLayer.inboundNodes.length === 1) {\n    layerOutputs = fetch.sourceLayer.output;\n  } else {\n    var nodeIndex = null;\n\n    for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {\n      var _iterator8 = _createForOfIteratorHelper(fetch.sourceLayer.inboundNodes[i].outputTensors),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var outputTensor = _step8.value;\n\n          if (outputTensor.id === fetch.id) {\n            nodeIndex = i;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n\n    layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);\n  }\n\n  return layerOutputs;\n}","map":null,"metadata":{},"sourceType":"module"}