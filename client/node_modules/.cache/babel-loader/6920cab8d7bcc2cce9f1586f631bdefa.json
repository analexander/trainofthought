{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar assert = require('assert');\n\nvar Buffer = require('buffer').Buffer;\n\nvar realZlib = require('zlib');\n\nvar constants = exports.constants = require('./constants.js');\n\nvar Minipass = require('minipass');\n\nvar OriginalBufferConcat = Buffer.concat;\n\nvar ZlibError = /*#__PURE__*/function (_Error) {\n  _inherits(ZlibError, _Error);\n\n  function ZlibError(err) {\n    var _this;\n\n    _classCallCheck(this, ZlibError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZlibError).call(this, 'zlib: ' + err.message));\n    _this.code = err.code;\n    _this.errno = err.errno;\n    /* istanbul ignore if */\n\n    if (!_this.code) _this.code = 'ZLIB_ERROR';\n    _this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    return _this;\n  }\n\n  _createClass(ZlibError, [{\n    key: \"name\",\n    get: function get() {\n      return 'ZlibError';\n    }\n  }]);\n\n  return ZlibError;\n}(_wrapNativeSuper(Error)); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nvar _opts = Symbol('opts');\n\nvar _flushFlag = Symbol('flushFlag');\n\nvar _finishFlushFlag = Symbol('finishFlushFlag');\n\nvar _fullFlushFlag = Symbol('fullFlushFlag');\n\nvar _handle = Symbol('handle');\n\nvar _onError = Symbol('onError');\n\nvar _sawError = Symbol('sawError');\n\nvar _level = Symbol('level');\n\nvar _strategy = Symbol('strategy');\n\nvar _ended = Symbol('ended');\n\nvar _defaultFullFlush = Symbol('_defaultFullFlush');\n\nvar ZlibBase = /*#__PURE__*/function (_Minipass) {\n  _inherits(ZlibBase, _Minipass);\n\n  function ZlibBase(opts, mode) {\n    var _this2;\n\n    _classCallCheck(this, ZlibBase);\n\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ZlibBase).call(this, opts));\n    _this2[_ended] = false;\n    _this2[_opts] = opts;\n    _this2[_flushFlag] = opts.flush;\n    _this2[_finishFlushFlag] = opts.finishFlush; // this will throw if any options are invalid for the class selected\n\n    try {\n      _this2[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n\n    _this2[_onError] = function (err) {\n      _this2[_sawError] = true; // there is no way to cleanly recover.\n      // continuing only obscures problems.\n\n      _this2.close();\n\n      _this2.emit('error', err);\n    };\n\n    _this2[_handle].on('error', function (er) {\n      return _this2[_onError](new ZlibError(er));\n    });\n\n    _this2.once('end', function () {\n      return _this2.close;\n    });\n\n    return _this2;\n  }\n\n  _createClass(ZlibBase, [{\n    key: \"close\",\n    value: function close() {\n      if (this[_handle]) {\n        this[_handle].close();\n\n        this[_handle] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this[_sawError]) {\n        assert(this[_handle], 'zlib binding closed');\n        return this[_handle].reset();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(flushFlag) {\n      if (this.ended) return;\n      if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n      this.write(Object.assign(Buffer.alloc(0), _defineProperty({}, _flushFlag, flushFlag)));\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (chunk) this.write(chunk, encoding);\n      this.flush(this[_finishFlushFlag]);\n      this[_ended] = true;\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"end\", this).call(this, null, null, cb);\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      // process the chunk using the sync process\n      // then super.write() all the outputted chunks\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n      if (this[_sawError]) return;\n      assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n      // intercept that by temporarily making it a no-op.\n\n      var nativeHandle = this[_handle]._handle;\n      var originalNativeClose = nativeHandle.close;\n\n      nativeHandle.close = function () {};\n\n      var originalClose = this[_handle].close;\n\n      this[_handle].close = function () {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n      // for some, but which we are not interested in as it slows us down.\n\n\n      Buffer.concat = function (args) {\n        return args;\n      };\n\n      var result;\n\n      try {\n        var flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n        result = this[_handle]._processChunk(chunk, flushFlag); // if we don't throw, reset it back how it was\n\n        Buffer.concat = OriginalBufferConcat;\n      } catch (err) {\n        // or if we do, put Buffer.concat() back before we emit error\n        // Error events call into user code, which may call Buffer.concat()\n        Buffer.concat = OriginalBufferConcat;\n\n        this[_onError](new ZlibError(err));\n      } finally {\n        if (this[_handle]) {\n          // Core zlib resets `_handle` to null after attempting to close the\n          // native handle. Our no-op handler prevented actual closure, but we\n          // need to restore the `._handle` property.\n          this[_handle]._handle = nativeHandle;\n          nativeHandle.close = originalNativeClose;\n          this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n          // after each call, these handlers start piling up.\n\n          this[_handle].removeAllListeners('error');\n        }\n      }\n\n      var writeReturn;\n\n      if (result) {\n        if (Array.isArray(result) && result.length > 0) {\n          // The first buffer is always `handle._outBuffer`, which would be\n          // re-used for later invocations; so, we always have to copy that one.\n          writeReturn = _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, Buffer.from(result[0]));\n\n          for (var i = 1; i < result.length; i++) {\n            writeReturn = _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, result[i]);\n          }\n        } else {\n          writeReturn = _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, Buffer.from(result));\n        }\n      }\n\n      if (cb) cb();\n      return writeReturn;\n    }\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return this[_ended];\n    }\n  }]);\n\n  return ZlibBase;\n}(Minipass);\n\nvar Zlib = /*#__PURE__*/function (_ZlibBase) {\n  _inherits(Zlib, _ZlibBase);\n\n  function Zlib(opts, mode) {\n    var _this3;\n\n    _classCallCheck(this, Zlib);\n\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Zlib).call(this, opts, mode));\n    _this3[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    _this3[_level] = opts.level;\n    _this3[_strategy] = opts.strategy;\n    return _this3;\n  }\n\n  _createClass(Zlib, [{\n    key: \"params\",\n    value: function params(level, strategy) {\n      var _this4 = this;\n\n      if (this[_sawError]) return;\n      if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n      /* istanbul ignore if */\n\n      if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n      if (this[_level] !== level || this[_strategy] !== strategy) {\n        this.flush(constants.Z_SYNC_FLUSH);\n        assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n        // core zlib. We override .flush() temporarily to intercept that and\n        // flush synchronously.\n\n        var origFlush = this[_handle].flush;\n\n        this[_handle].flush = function (flushFlag, cb) {\n          _this4.flush(flushFlag);\n\n          cb();\n        };\n\n        try {\n          this[_handle].params(level, strategy);\n        } finally {\n          this[_handle].flush = origFlush;\n        }\n        /* istanbul ignore else */\n\n\n        if (this[_handle]) {\n          this[_level] = level;\n          this[_strategy] = strategy;\n        }\n      }\n    }\n  }]);\n\n  return Zlib;\n}(ZlibBase); // minimal 2-byte header\n\n\nvar Deflate = /*#__PURE__*/function (_Zlib) {\n  _inherits(Deflate, _Zlib);\n\n  function Deflate(opts) {\n    _classCallCheck(this, Deflate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Deflate).call(this, opts, 'Deflate'));\n  }\n\n  return Deflate;\n}(Zlib);\n\nvar Inflate = /*#__PURE__*/function (_Zlib2) {\n  _inherits(Inflate, _Zlib2);\n\n  function Inflate(opts) {\n    _classCallCheck(this, Inflate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Inflate).call(this, opts, 'Inflate'));\n  }\n\n  return Inflate;\n}(Zlib); // gzip - bigger header, same deflate compression\n\n\nvar Gzip = /*#__PURE__*/function (_Zlib3) {\n  _inherits(Gzip, _Zlib3);\n\n  function Gzip(opts) {\n    _classCallCheck(this, Gzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Gzip).call(this, opts, 'Gzip'));\n  }\n\n  return Gzip;\n}(Zlib);\n\nvar Gunzip = /*#__PURE__*/function (_Zlib4) {\n  _inherits(Gunzip, _Zlib4);\n\n  function Gunzip(opts) {\n    _classCallCheck(this, Gunzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Gunzip).call(this, opts, 'Gunzip'));\n  }\n\n  return Gunzip;\n}(Zlib); // raw - no header\n\n\nvar DeflateRaw = /*#__PURE__*/function (_Zlib5) {\n  _inherits(DeflateRaw, _Zlib5);\n\n  function DeflateRaw(opts) {\n    _classCallCheck(this, DeflateRaw);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateRaw).call(this, opts, 'DeflateRaw'));\n  }\n\n  return DeflateRaw;\n}(Zlib);\n\nvar InflateRaw = /*#__PURE__*/function (_Zlib6) {\n  _inherits(InflateRaw, _Zlib6);\n\n  function InflateRaw(opts) {\n    _classCallCheck(this, InflateRaw);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(InflateRaw).call(this, opts, 'InflateRaw'));\n  }\n\n  return InflateRaw;\n}(Zlib); // auto-detect header.\n\n\nvar Unzip = /*#__PURE__*/function (_Zlib7) {\n  _inherits(Unzip, _Zlib7);\n\n  function Unzip(opts) {\n    _classCallCheck(this, Unzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Unzip).call(this, opts, 'Unzip'));\n  }\n\n  return Unzip;\n}(Zlib);\n\nvar Brotli = /*#__PURE__*/function (_ZlibBase2) {\n  _inherits(Brotli, _ZlibBase2);\n\n  function Brotli(opts, mode) {\n    var _this5;\n\n    _classCallCheck(this, Brotli);\n\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Brotli).call(this, opts, mode));\n    _this5[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n    return _this5;\n  }\n\n  return Brotli;\n}(ZlibBase);\n\nvar BrotliCompress = /*#__PURE__*/function (_Brotli) {\n  _inherits(BrotliCompress, _Brotli);\n\n  function BrotliCompress(opts) {\n    _classCallCheck(this, BrotliCompress);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliCompress).call(this, opts, 'BrotliCompress'));\n  }\n\n  return BrotliCompress;\n}(Brotli);\n\nvar BrotliDecompress = /*#__PURE__*/function (_Brotli2) {\n  _inherits(BrotliDecompress, _Brotli2);\n\n  function BrotliDecompress(opts) {\n    _classCallCheck(this, BrotliDecompress);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliDecompress).call(this, opts, 'BrotliDecompress'));\n  }\n\n  return BrotliDecompress;\n}(Brotli);\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\n\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n\n    return _class;\n  }();\n}","map":null,"metadata":{},"sourceType":"script"}