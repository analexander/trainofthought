{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { env } from '../env';\nimport { createCanvas } from './createCanvas';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { imageTensorToCanvas } from './imageTensorToCanvas';\nimport { toNetInput } from './toNetInput';\n/**\r\n * Extracts the image regions containing the detected faces.\r\n *\r\n * @param input The image that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns The Canvases of the corresponding image region for each detected face.\r\n */\n\nexport function extractFaces(input, detections) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          Canvas = env.getEnv().Canvas;\n          canvas = input;\n          if (!!(input instanceof Canvas)) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , toNetInput(input)];\n\n        case 1:\n          netInput = _b.sent();\n\n          if (netInput.batchSize > 1) {\n            throw new Error('extractFaces - batchSize > 1 not supported');\n          }\n\n          tensorOrCanvas = netInput.getInput(0);\n          if (!(tensorOrCanvas instanceof Canvas)) return [3\n          /*break*/\n          , 2];\n          _a = tensorOrCanvas;\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , imageTensorToCanvas(tensorOrCanvas)];\n\n        case 3:\n          _a = _b.sent();\n          _b.label = 4;\n\n        case 4:\n          canvas = _a;\n          _b.label = 5;\n\n        case 5:\n          ctx = getContext2dOrThrow(canvas);\n          boxes = detections.map(function (det) {\n            return det instanceof FaceDetection ? det.forSize(canvas.width, canvas.height).box.floor() : det;\n          }).map(function (box) {\n            return box.clipAtImageBorders(canvas.width, canvas.height);\n          });\n          return [2\n          /*return*/\n          , boxes.map(function (_a) {\n            var x = _a.x,\n                y = _a.y,\n                width = _a.width,\n                height = _a.height;\n            var faceImg = createCanvas({\n              width: width,\n              height: height\n            });\n            getContext2dOrThrow(faceImg).putImageData(ctx.getImageData(x, y, width, height), 0, 0);\n            return faceImg;\n          })];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/dom/extractFaces.ts"],"names":[],"mappings":";AAAA,SAAS,aAAT,QAA8B,0BAA9B;AAEA,SAAS,GAAT,QAAoB,QAApB;AACA,SAAS,YAAT,QAA6B,gBAA7B;AACA,SAAS,mBAAT,QAAoC,uBAApC;AACA,SAAS,mBAAT,QAAoC,uBAApC;AACA,SAAS,UAAT,QAA2B,cAA3B;AAGA;;;;;;AAMG;;AACH,OAAM,SAAgB,YAAhB,CACJ,KADI,EAEJ,UAFI,EAEmC;;;;;;;AAG/B,UAAA,MAAM,GAAK,GAAG,CAAC,MAAJ,GAAL,MAAN;AAEJ,UAAA,MAAM,GAAG,KAAT;eAEA,EAAE,KAAK,YAAY,MAAnB,C,EAAA,OAAA,CAAA;AAAA;AAAA,YAAA,CAAA,CAAA;AACe,iBAAA,CAAA;AAAA;AAAA,YAAM,UAAU,CAAC,KAAD,CAAhB,CAAA;;;AAAX,UAAA,QAAQ,GAAG,EAAA,CAAA,IAAA,EAAX;;AAEN,cAAI,QAAQ,CAAC,SAAT,GAAqB,CAAzB,EAA4B;AAC1B,kBAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAEK,UAAA,cAAc,GAAG,QAAQ,CAAC,QAAT,CAAkB,CAAlB,CAAjB;cACG,EAAA,cAAc,YAAY,MAA1B,C,EAAA,OAAA,CAAA;AAAA;AAAA,YAAA,CAAA,CAAA;AACL,UAAA,EAAA,GAAA,cAAA;;;;;;AACA,iBAAA,CAAA;AAAA;AAAA,YAAM,mBAAmB,CAAC,cAAD,CAAzB,CAAA;;;AAAA,UAAA,EAAA,GAAA,EAAA,CAAA,IAAA,EAAA;;;;AAFJ,UAAA,MAAM,GAAA,EAAN;;;;AAKI,UAAA,GAAG,GAAG,mBAAmB,CAAC,MAAD,CAAzB;AACA,UAAA,KAAK,GAAG,UAAU,CAAC,GAAX,CACZ,UAAA,GAAA,EAAG;AAAI,mBAAA,GAAG,YAAY,aAAf,GACH,GAAG,CAAC,OAAJ,CAAY,MAAM,CAAC,KAAnB,EAA0B,MAAM,CAAC,MAAjC,EAAyC,GAAzC,CAA6C,KAA7C,EADG,GAAA,GAAA;AAEA,WAHK,EAKX,GALW,CAKP,UAAA,GAAA,EAAG;AAAI,mBAAA,GAAG,CAAC,kBAAJ,CAAuB,MAAM,CAAC,KAA9B,EAAqC,MAAM,CAA3C,MAAA,CAAA;AAAmD,WALnD,CAAR;AAON,iBAAA,CAAA;AAAA;AAAA,YAAO,KAAK,CAAC,GAAN,CAAU,UAAC,EAAD,EAAwB;gBAArB,CAAA,GAAA,EAAA,CAAA,C;gBAAG,CAAA,GAAA,EAAA,CAAA,C;gBAAG,KAAA,GAAA,EAAA,CAAA,K;gBAAO,MAAA,GAAA,EAAA,CAAA,M;AAC/B,gBAAM,OAAO,GAAG,YAAY,CAAC;AAAE,cAAA,KAAK,EAAA,KAAP;AAAS,cAAA,MAAM,EAAA;AAAf,aAAD,CAA5B;AACA,YAAA,mBAAmB,CAAC,OAAD,CAAnB,CACG,YADH,CACgB,GAAG,CAAC,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,KAAvB,EAA8B,MAA9B,CADhB,EACuD,CADvD,EAC0D,CAD1D;AAEA,mBAAO,OAAP;AACD,WALM,CAAP,CAAA;;;;AAMD","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { env } from '../env';\r\nimport { createCanvas } from './createCanvas';\r\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\r\nimport { imageTensorToCanvas } from './imageTensorToCanvas';\r\nimport { toNetInput } from './toNetInput';\r\n/**\r\n * Extracts the image regions containing the detected faces.\r\n *\r\n * @param input The image that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns The Canvases of the corresponding image region for each detected face.\r\n */\r\nexport function extractFaces(input, detections) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    Canvas = env.getEnv().Canvas;\r\n                    canvas = input;\r\n                    if (!!(input instanceof Canvas)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, toNetInput(input)];\r\n                case 1:\r\n                    netInput = _b.sent();\r\n                    if (netInput.batchSize > 1) {\r\n                        throw new Error('extractFaces - batchSize > 1 not supported');\r\n                    }\r\n                    tensorOrCanvas = netInput.getInput(0);\r\n                    if (!(tensorOrCanvas instanceof Canvas)) return [3 /*break*/, 2];\r\n                    _a = tensorOrCanvas;\r\n                    return [3 /*break*/, 4];\r\n                case 2: return [4 /*yield*/, imageTensorToCanvas(tensorOrCanvas)];\r\n                case 3:\r\n                    _a = _b.sent();\r\n                    _b.label = 4;\r\n                case 4:\r\n                    canvas = _a;\r\n                    _b.label = 5;\r\n                case 5:\r\n                    ctx = getContext2dOrThrow(canvas);\r\n                    boxes = detections.map(function (det) { return det instanceof FaceDetection\r\n                        ? det.forSize(canvas.width, canvas.height).box.floor()\r\n                        : det; })\r\n                        .map(function (box) { return box.clipAtImageBorders(canvas.width, canvas.height); });\r\n                    return [2 /*return*/, boxes.map(function (_a) {\r\n                            var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n                            var faceImg = createCanvas({ width: width, height: height });\r\n                            getContext2dOrThrow(faceImg)\r\n                                .putImageData(ctx.getImageData(x, y, width, height), 0, 0);\r\n                            return faceImg;\r\n                        })];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=extractFaces.js.map"]},"metadata":{},"sourceType":"module"}