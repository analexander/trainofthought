{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport var GPGPUContext = /*#__PURE__*/function () {\n  function GPGPUContext(gl) {\n    _classCallCheck(this, GPGPUContext);\n\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.vertexAttrsAreBound = false;\n    this.itemsToPoll = [];\n    var glVersion = env().getNumber('WEBGL_VERSION');\n\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    } // WebGL 2.0 enables texture floats without an extension.\n\n\n    var COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    var COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      var TEXTURE_FLOAT = 'OES_texture_float';\n      var TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  _createClass(GPGPUContext, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n\n      if (this.disposed) {\n        return;\n      }\n\n      if (this.program != null) {\n        console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n      }\n\n      if (this.outputTexture != null) {\n        console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n      }\n\n      var gl = this.gl;\n      webgl_util.callAndCheck(gl, function () {\n        return gl.finish();\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.deleteFramebuffer(_this.framebuffer);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.deleteBuffer(_this.indexBuffer);\n      });\n      this.disposed = true;\n    }\n  }, {\n    key: \"createFloat32MatrixTexture\",\n    value: function createFloat32MatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createFloat16MatrixTexture\",\n    value: function createFloat16MatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createUnsignedBytesMatrixTexture\",\n    value: function createUnsignedBytesMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"uploadPixelDataToTexture\",\n    value: function uploadPixelDataToTexture(texture, pixels) {\n      this.throwIfDisposed();\n      gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n  }, {\n    key: \"uploadDenseMatrixToTexture\",\n    value: function uploadDenseMatrixToTexture(texture, width, height, data) {\n      this.throwIfDisposed();\n      gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n  }, {\n    key: \"createFloat16PackedMatrixTexture\",\n    value: function createFloat16PackedMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createPackedMatrixTexture\",\n    value: function createPackedMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"deleteMatrixTexture\",\n    value: function deleteMatrixTexture(texture) {\n      var _this2 = this;\n\n      this.throwIfDisposed();\n\n      if (this.outputTexture === texture) {\n        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        this.outputTexture = null;\n      }\n\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this2.gl.deleteTexture(texture);\n      });\n    }\n  }, {\n    key: \"downloadByteEncodedFloatMatrixFromOutputTexture\",\n    value: function downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n      var _this3 = this;\n\n      return this.downloadMatrixDriver(texture, function () {\n        return gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(_this3.gl, rows, columns, _this3.textureConfig);\n      });\n    }\n  }, {\n    key: \"downloadPackedMatrixFromBuffer\",\n    value: function downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n      return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n  }, {\n    key: \"downloadFloat32MatrixFromBuffer\",\n    value: function downloadFloat32MatrixFromBuffer(buffer, size) {\n      return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n  }, {\n    key: \"createBufferFromTexture\",\n    value: function createBufferFromTexture(texture, rows, columns) {\n      this.bindTextureToFrameBuffer(texture);\n      var result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n      this.unbindTextureToFrameBuffer();\n      return result;\n    }\n  }, {\n    key: \"createAndWaitForFence\",\n    value: function createAndWaitForFence() {\n      var fenceContext = this.createFence(this.gl);\n      return this.pollFence(fenceContext);\n    }\n  }, {\n    key: \"createFence\",\n    value: function createFence(gl) {\n      var _this4 = this;\n\n      var query;\n      var isFencePassed;\n\n      if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n        var gl2 = gl;\n        var sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        gl.flush();\n\n        isFencePassed = function isFencePassed() {\n          var status = gl2.clientWaitSync(sync, 0, 0);\n          return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n        };\n\n        query = sync;\n      } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n        query = this.beginQuery();\n        this.endQuery();\n\n        isFencePassed = function isFencePassed() {\n          return _this4.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        };\n      } else {\n        // If we have no way to fence, return true immediately. This will fire in\n        // WebGL 1.0 when there is no disjoint query timer. In this case, because\n        // the fence passes immediately, we'll immediately ask for a download of\n        // the texture, which will cause the UI thread to hang.\n        isFencePassed = function isFencePassed() {\n          return true;\n        };\n      }\n\n      return {\n        query: query,\n        isFencePassed: isFencePassed\n      };\n    }\n  }, {\n    key: \"downloadMatrixFromPackedTexture\",\n    value: function downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n      var _this5 = this;\n\n      return this.downloadMatrixDriver(texture, function () {\n        return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this5.gl, physicalRows, physicalCols);\n      });\n    }\n  }, {\n    key: \"createProgram\",\n    value: function createProgram(fragmentShaderSource) {\n      this.throwIfDisposed();\n      var gl = this.gl;\n      var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n      var vertexShader = gpgpu_util.createVertexShader(gl);\n      var program = webgl_util.createProgram(gl);\n      webgl_util.callAndCheck(gl, function () {\n        return gl.attachShader(program, vertexShader);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.attachShader(program, fragmentShader);\n      });\n      webgl_util.linkProgram(gl, program);\n\n      if (this.debug) {\n        webgl_util.validateProgram(gl, program);\n      }\n\n      if (!this.vertexAttrsAreBound) {\n        this.setProgram(program);\n        this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n      }\n\n      return program;\n    }\n  }, {\n    key: \"deleteProgram\",\n    value: function deleteProgram(program) {\n      var _this6 = this;\n\n      this.throwIfDisposed();\n\n      if (program === this.program) {\n        this.program = null;\n      }\n\n      if (program != null) {\n        webgl_util.callAndCheck(this.gl, function () {\n          return _this6.gl.deleteProgram(program);\n        });\n      }\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(program) {\n      var _this7 = this;\n\n      this.throwIfDisposed();\n      this.program = program;\n\n      if (this.program != null && this.debug) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this7.gl.useProgram(program);\n      });\n    }\n  }, {\n    key: \"getUniformLocation\",\n    value: function getUniformLocation(program, uniformName) {\n      var shouldThrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      this.throwIfDisposed();\n\n      if (shouldThrow) {\n        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n      } else {\n        return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n      }\n    }\n  }, {\n    key: \"getAttributeLocation\",\n    value: function getAttributeLocation(program, attribute) {\n      var _this8 = this;\n\n      this.throwIfDisposed();\n      return webgl_util.callAndCheck(this.gl, function () {\n        return _this8.gl.getAttribLocation(program, attribute);\n      });\n    }\n  }, {\n    key: \"getUniformLocationNoThrow\",\n    value: function getUniformLocationNoThrow(program, uniformName) {\n      this.throwIfDisposed();\n      return this.gl.getUniformLocation(program, uniformName);\n    }\n  }, {\n    key: \"setInputMatrixTexture\",\n    value: function setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n      this.throwIfDisposed();\n      this.throwIfNoProgram();\n      webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n  }, {\n    key: \"setOutputMatrixTexture\",\n    value: function setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n      this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n  }, {\n    key: \"setOutputPackedMatrixTexture\",\n    value: function setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n      this.throwIfDisposed();\n\n      var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n          _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2),\n          width = _tex_util$getPackedMa2[0],\n          height = _tex_util$getPackedMa2[1];\n\n      this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n  }, {\n    key: \"setOutputMatrixWriteRegion\",\n    value: function setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n      this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n  }, {\n    key: \"setOutputPackedMatrixWriteRegion\",\n    value: function setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n      throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n  }, {\n    key: \"debugValidate\",\n    value: function debugValidate() {\n      if (this.program != null) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }, {\n    key: \"executeProgram\",\n    value: function executeProgram() {\n      this.throwIfDisposed();\n      this.throwIfNoProgram();\n      var gl = this.gl;\n\n      if (this.debug) {\n        this.debugValidate();\n      }\n\n      webgl_util.callAndCheck(gl, function () {\n        return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      });\n    }\n  }, {\n    key: \"blockUntilAllProgramsCompleted\",\n    value: function blockUntilAllProgramsCompleted() {\n      var _this9 = this;\n\n      this.throwIfDisposed();\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this9.gl.finish();\n      });\n    }\n  }, {\n    key: \"getQueryTimerExtension\",\n    value: function getQueryTimerExtension() {\n      if (this.disjointQueryTimerExtension == null) {\n        this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n      }\n\n      return this.disjointQueryTimerExtension;\n    }\n  }, {\n    key: \"getQueryTimerExtensionWebGL2\",\n    value: function getQueryTimerExtensionWebGL2() {\n      return this.getQueryTimerExtension();\n    }\n  }, {\n    key: \"getQueryTimerExtensionWebGL1\",\n    value: function getQueryTimerExtensionWebGL1() {\n      return this.getQueryTimerExtension();\n    }\n  }, {\n    key: \"beginQuery\",\n    value: function beginQuery() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n        var gl2 = this.gl;\n\n        var _ext = this.getQueryTimerExtensionWebGL2();\n\n        var _query = gl2.createQuery();\n\n        gl2.beginQuery(_ext.TIME_ELAPSED_EXT, _query);\n        return _query;\n      }\n\n      var ext = this.getQueryTimerExtensionWebGL1();\n      var query = ext.createQueryEXT();\n      ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n  }, {\n    key: \"endQuery\",\n    value: function endQuery() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n        var gl2 = this.gl;\n\n        var _ext2 = this.getQueryTimerExtensionWebGL2();\n\n        gl2.endQuery(_ext2.TIME_ELAPSED_EXT);\n        return;\n      }\n\n      var ext = this.getQueryTimerExtensionWebGL1();\n      ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n  }, {\n    key: \"waitForQueryAndGetTime\",\n    value: function () {\n      var _waitForQueryAndGetTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(query) {\n        var _this10 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return util.repeatedTry(function () {\n                  return _this10.disposed || // while testing contexts are created / disposed\n                  // in rapid succession, so without this check we\n                  // may poll for the query timer indefinitely\n                  _this10.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n                });\n\n              case 2:\n                return _context.abrupt(\"return\", this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function waitForQueryAndGetTime(_x) {\n        return _waitForQueryAndGetTime.apply(this, arguments);\n      }\n\n      return waitForQueryAndGetTime;\n    }()\n  }, {\n    key: \"getQueryTime\",\n    value: function getQueryTime(query, queryTimerVersion) {\n      if (queryTimerVersion === 0) {\n        return null;\n      }\n\n      if (queryTimerVersion === 2) {\n        var gl2 = this.gl;\n        var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT); // Return milliseconds.\n\n        return timeElapsedNanos / 1000000;\n      } else {\n        var ext = this.getQueryTimerExtensionWebGL1();\n\n        var _timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT); // Return milliseconds.\n\n\n        return _timeElapsedNanos / 1000000;\n      }\n    }\n  }, {\n    key: \"isQueryAvailable\",\n    value: function isQueryAvailable(query, queryTimerVersion) {\n      if (queryTimerVersion === 0) {\n        return true;\n      }\n\n      if (queryTimerVersion === 2) {\n        var gl2 = this.gl;\n        var ext = this.getQueryTimerExtensionWebGL2();\n        var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n\n        if (this.disjoint == null) {\n          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n        }\n\n        return available && !this.disjoint;\n      } else {\n        var _ext3 = this.getQueryTimerExtensionWebGL1();\n\n        var _available = _ext3.getQueryObjectEXT(query, _ext3.QUERY_RESULT_AVAILABLE_EXT);\n\n        if (this.disjoint == null) {\n          this.disjoint = this.gl.getParameter(_ext3.GPU_DISJOINT_EXT);\n        }\n\n        return _available && !this.disjoint;\n      }\n    }\n  }, {\n    key: \"pollFence\",\n    value: function pollFence(fenceContext) {\n      var _this11 = this;\n\n      return new Promise(function (resolve) {\n        _this11.addItemToPoll(function () {\n          return fenceContext.isFencePassed();\n        }, function () {\n          return resolve();\n        });\n      });\n    }\n  }, {\n    key: \"pollItems\",\n    value: function pollItems() {\n      // Find the last query that has finished.\n      var index = linearSearchLastTrue(this.itemsToPoll.map(function (x) {\n        return x.isDoneFn;\n      }));\n\n      for (var i = 0; i <= index; ++i) {\n        var resolveFn = this.itemsToPoll[i].resolveFn;\n        resolveFn();\n      }\n\n      this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n  }, {\n    key: \"addItemToPoll\",\n    value: function addItemToPoll(isDoneFn, resolveFn) {\n      var _this12 = this;\n\n      this.itemsToPoll.push({\n        isDoneFn: isDoneFn,\n        resolveFn: resolveFn\n      });\n\n      if (this.itemsToPoll.length > 1) {\n        // We already have a running loop that polls.\n        return;\n      } // Start a new loop that polls.\n\n\n      util.repeatedTry(function () {\n        _this12.pollItems(); // End the loop if no more items to poll.\n\n\n        return _this12.itemsToPoll.length === 0;\n      });\n    }\n  }, {\n    key: \"bindTextureToFrameBuffer\",\n    value: function bindTextureToFrameBuffer(texture) {\n      this.throwIfDisposed();\n      webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    }\n  }, {\n    key: \"unbindTextureToFrameBuffer\",\n    value: function unbindTextureToFrameBuffer() {\n      if (this.outputTexture != null) {\n        webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n\n        if (this.debug) {\n          webgl_util.validateFramebuffer(this.gl);\n        }\n      } else {\n        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      }\n    }\n  }, {\n    key: \"downloadMatrixDriver\",\n    value: function downloadMatrixDriver(texture, downloadAndDecode) {\n      this.bindTextureToFrameBuffer(texture);\n      var result = downloadAndDecode();\n      this.unbindTextureToFrameBuffer();\n      return result;\n    }\n  }, {\n    key: \"setOutputMatrixTextureDriver\",\n    value: function setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n      this.throwIfDisposed();\n      var gl = this.gl;\n      webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(gl);\n      }\n\n      this.outputTexture = outputMatrixTextureMaybePacked;\n      webgl_util.callAndCheck(gl, function () {\n        return gl.viewport(0, 0, width, height);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.scissor(0, 0, width, height);\n      });\n    }\n  }, {\n    key: \"setOutputMatrixWriteRegionDriver\",\n    value: function setOutputMatrixWriteRegionDriver(x, y, width, height) {\n      var _this13 = this;\n\n      this.throwIfDisposed();\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this13.gl.scissor(x, y, width, height);\n      });\n    }\n  }, {\n    key: \"throwIfDisposed\",\n    value: function throwIfDisposed() {\n      if (this.disposed) {\n        throw new Error('Attempted to use disposed GPGPUContext.');\n      }\n    }\n  }, {\n    key: \"throwIfNoProgram\",\n    value: function throwIfNoProgram() {\n      if (this.program == null) {\n        throw new Error('No GPU program is currently set.');\n      }\n    }\n  }, {\n    key: \"debug\",\n    get: function get() {\n      return env().getBool('DEBUG');\n    }\n  }]);\n\n  return GPGPUContext;\n}();\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\n\nexport function linearSearchLastTrue(arr) {\n  var i = 0;\n\n  for (; i < arr.length; ++i) {\n    var isDone = arr[i]();\n\n    if (!isDone) {\n      break;\n    }\n  }\n\n  return i - 1;\n}","map":null,"metadata":{},"sourceType":"module"}