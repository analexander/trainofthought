{"ast":null,"code":"import * as tf from '@tensorflow/tfjs-core';\nimport { env } from '../env';\nimport { padToSquare } from '../ops/padToSquare';\nimport { computeReshapedDimensions, isTensor3D, isTensor4D, range } from '../utils';\nimport { createCanvasFromMedia } from './createCanvas';\nimport { imageToSquare } from './imageToSquare';\n\nvar NetInput =\n/** @class */\nfunction () {\n  function NetInput(inputs, treatAsBatchInput) {\n    var _this = this;\n\n    if (treatAsBatchInput === void 0) {\n      treatAsBatchInput = false;\n    }\n\n    this._imageTensors = [];\n    this._canvases = [];\n    this._treatAsBatchInput = false;\n    this._inputDimensions = [];\n\n    if (!Array.isArray(inputs)) {\n      throw new Error(\"NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have \" + inputs);\n    }\n\n    this._treatAsBatchInput = treatAsBatchInput;\n    this._batchSize = inputs.length;\n    inputs.forEach(function (input, idx) {\n      if (isTensor3D(input)) {\n        _this._imageTensors[idx] = input;\n        _this._inputDimensions[idx] = input.shape;\n        return;\n      }\n\n      if (isTensor4D(input)) {\n        var batchSize = input.shape[0];\n\n        if (batchSize !== 1) {\n          throw new Error(\"NetInput - tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n        }\n\n        _this._imageTensors[idx] = input;\n        _this._inputDimensions[idx] = input.shape.slice(1);\n        return;\n      }\n\n      var canvas = input instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input);\n      _this._canvases[idx] = canvas;\n      _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\n    });\n  }\n\n  Object.defineProperty(NetInput.prototype, \"imageTensors\", {\n    get: function get() {\n      return this._imageTensors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"canvases\", {\n    get: function get() {\n      return this._canvases;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"isBatchInput\", {\n    get: function get() {\n      return this.batchSize > 1 || this._treatAsBatchInput;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"batchSize\", {\n    get: function get() {\n      return this._batchSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"inputDimensions\", {\n    get: function get() {\n      return this._inputDimensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"inputSize\", {\n    get: function get() {\n      return this._inputSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"reshapedInputDimensions\", {\n    get: function get() {\n      var _this = this;\n\n      return range(this.batchSize, 0, 1).map(function (_, batchIdx) {\n        return _this.getReshapedInputDimensions(batchIdx);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  NetInput.prototype.getInput = function (batchIdx) {\n    return this.canvases[batchIdx] || this.imageTensors[batchIdx];\n  };\n\n  NetInput.prototype.getInputDimensions = function (batchIdx) {\n    return this._inputDimensions[batchIdx];\n  };\n\n  NetInput.prototype.getInputHeight = function (batchIdx) {\n    return this._inputDimensions[batchIdx][0];\n  };\n\n  NetInput.prototype.getInputWidth = function (batchIdx) {\n    return this._inputDimensions[batchIdx][1];\n  };\n\n  NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {\n    if (typeof this.inputSize !== 'number') {\n      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\n    }\n\n    var width = this.getInputWidth(batchIdx);\n    var height = this.getInputHeight(batchIdx);\n    return computeReshapedDimensions({\n      width: width,\n      height: height\n    }, this.inputSize);\n  };\n  /**\r\n   * Create a batch tensor from all input canvases and tensors\r\n   * with size [batchSize, inputSize, inputSize, 3].\r\n   *\r\n   * @param inputSize Height and width of the tensor.\r\n   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n   * both sides of the minor dimension oof the image.\r\n   * @returns The batch tensor.\r\n   */\n\n\n  NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {\n    var _this = this;\n\n    if (isCenterInputs === void 0) {\n      isCenterInputs = true;\n    }\n\n    this._inputSize = inputSize;\n    return tf.tidy(function () {\n      var inputTensors = range(_this.batchSize, 0, 1).map(function (batchIdx) {\n        var input = _this.getInput(batchIdx);\n\n        if (input instanceof tf.Tensor) {\n          var imgTensor = isTensor4D(input) ? input : input.expandDims();\n          imgTensor = padToSquare(imgTensor, isCenterInputs);\n\n          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\n            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);\n          }\n\n          return imgTensor.as3D(inputSize, inputSize, 3);\n        }\n\n        if (input instanceof env.getEnv().Canvas) {\n          return tf.browser.fromPixels(imageToSquare(input, inputSize, isCenterInputs));\n        }\n\n        throw new Error(\"toBatchTensor - at batchIdx \" + batchIdx + \", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have \" + input);\n      });\n      var batchTensor = tf.stack(inputTensors.map(function (t) {\n        return t.toFloat();\n      })).as4D(_this.batchSize, inputSize, inputSize, 3);\n      return batchTensor;\n    });\n  };\n\n  return NetInput;\n}();\n\nexport { NetInput };","map":{"version":3,"sources":["../../../src/dom/NetInput.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tf from '@tensorflow/tfjs-core';\r\nimport { env } from '../env';\r\nimport { padToSquare } from '../ops/padToSquare';\r\nimport { computeReshapedDimensions, isTensor3D, isTensor4D, range } from '../utils';\r\nimport { createCanvasFromMedia } from './createCanvas';\r\nimport { imageToSquare } from './imageToSquare';\r\nvar NetInput = /** @class */ (function () {\r\n    function NetInput(inputs, treatAsBatchInput) {\r\n        var _this = this;\r\n        if (treatAsBatchInput === void 0) { treatAsBatchInput = false; }\r\n        this._imageTensors = [];\r\n        this._canvases = [];\r\n        this._treatAsBatchInput = false;\r\n        this._inputDimensions = [];\r\n        if (!Array.isArray(inputs)) {\r\n            throw new Error(\"NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have \" + inputs);\r\n        }\r\n        this._treatAsBatchInput = treatAsBatchInput;\r\n        this._batchSize = inputs.length;\r\n        inputs.forEach(function (input, idx) {\r\n            if (isTensor3D(input)) {\r\n                _this._imageTensors[idx] = input;\r\n                _this._inputDimensions[idx] = input.shape;\r\n                return;\r\n            }\r\n            if (isTensor4D(input)) {\r\n                var batchSize = input.shape[0];\r\n                if (batchSize !== 1) {\r\n                    throw new Error(\"NetInput - tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\r\n                }\r\n                _this._imageTensors[idx] = input;\r\n                _this._inputDimensions[idx] = input.shape.slice(1);\r\n                return;\r\n            }\r\n            var canvas = input instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input);\r\n            _this._canvases[idx] = canvas;\r\n            _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\r\n        });\r\n    }\r\n    Object.defineProperty(NetInput.prototype, \"imageTensors\", {\r\n        get: function () {\r\n            return this._imageTensors;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"canvases\", {\r\n        get: function () {\r\n            return this._canvases;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"isBatchInput\", {\r\n        get: function () {\r\n            return this.batchSize > 1 || this._treatAsBatchInput;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"batchSize\", {\r\n        get: function () {\r\n            return this._batchSize;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"inputDimensions\", {\r\n        get: function () {\r\n            return this._inputDimensions;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"inputSize\", {\r\n        get: function () {\r\n            return this._inputSize;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NetInput.prototype, \"reshapedInputDimensions\", {\r\n        get: function () {\r\n            var _this = this;\r\n            return range(this.batchSize, 0, 1).map(function (_, batchIdx) { return _this.getReshapedInputDimensions(batchIdx); });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NetInput.prototype.getInput = function (batchIdx) {\r\n        return this.canvases[batchIdx] || this.imageTensors[batchIdx];\r\n    };\r\n    NetInput.prototype.getInputDimensions = function (batchIdx) {\r\n        return this._inputDimensions[batchIdx];\r\n    };\r\n    NetInput.prototype.getInputHeight = function (batchIdx) {\r\n        return this._inputDimensions[batchIdx][0];\r\n    };\r\n    NetInput.prototype.getInputWidth = function (batchIdx) {\r\n        return this._inputDimensions[batchIdx][1];\r\n    };\r\n    NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {\r\n        if (typeof this.inputSize !== 'number') {\r\n            throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\r\n        }\r\n        var width = this.getInputWidth(batchIdx);\r\n        var height = this.getInputHeight(batchIdx);\r\n        return computeReshapedDimensions({ width: width, height: height }, this.inputSize);\r\n    };\r\n    /**\r\n     * Create a batch tensor from all input canvases and tensors\r\n     * with size [batchSize, inputSize, inputSize, 3].\r\n     *\r\n     * @param inputSize Height and width of the tensor.\r\n     * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n     * both sides of the minor dimension oof the image.\r\n     * @returns The batch tensor.\r\n     */\r\n    NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {\r\n        var _this = this;\r\n        if (isCenterInputs === void 0) { isCenterInputs = true; }\r\n        this._inputSize = inputSize;\r\n        return tf.tidy(function () {\r\n            var inputTensors = range(_this.batchSize, 0, 1).map(function (batchIdx) {\r\n                var input = _this.getInput(batchIdx);\r\n                if (input instanceof tf.Tensor) {\r\n                    var imgTensor = isTensor4D(input) ? input : input.expandDims();\r\n                    imgTensor = padToSquare(imgTensor, isCenterInputs);\r\n                    if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\r\n                        imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);\r\n                    }\r\n                    return imgTensor.as3D(inputSize, inputSize, 3);\r\n                }\r\n                if (input instanceof env.getEnv().Canvas) {\r\n                    return tf.browser.fromPixels(imageToSquare(input, inputSize, isCenterInputs));\r\n                }\r\n                throw new Error(\"toBatchTensor - at batchIdx \" + batchIdx + \", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have \" + input);\r\n            });\r\n            var batchTensor = tf.stack(inputTensors.map(function (t) { return t.toFloat(); })).as4D(_this.batchSize, inputSize, inputSize, 3);\r\n            return batchTensor;\r\n        });\r\n    };\r\n    return NetInput;\r\n}());\r\nexport { NetInput };\r\n//# sourceMappingURL=NetInput.js.map"]},"metadata":{},"sourceType":"module"}