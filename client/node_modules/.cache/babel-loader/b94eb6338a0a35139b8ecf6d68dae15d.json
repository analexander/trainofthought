{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport React, { Component } from \"react\";\nimport \"./face_expression_model-weights_manifest.json\";\nimport \"./tiny_face_detector_model-weights_manifest.json\";\n\nvar Video = /*#__PURE__*/function (_Component) {\n  _inherits(Video, _Component);\n\n  function Video() {\n    _classCallCheck(this, Video);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Video).apply(this, arguments));\n  }\n\n  _createClass(Video, [{\n    key: \"render\",\n    value: function render() {\n      var main = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var canvasElement, videoElement, constraints, stream, onPlay;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return faceapi.nets.tinyFaceDetector.load('/');\n\n                case 2:\n                  _context2.next = 4;\n                  return faceapi.loadFaceExpressionModel('/');\n\n                case 4:\n                  // get canvas and video elements\n                  canvasElement = document.getElementById(\"overlay\");\n                  videoElement = document.querySelector(\"video\"); // get Webcam video stream\n\n                  constraints = {\n                    audio: false,\n                    video: {}\n                  };\n                  _context2.next = 9;\n                  return navigator.mediaDevices.getUserMedia(constraints);\n\n                case 9:\n                  stream = _context2.sent;\n\n                  // what to do when the video stream is available\n                  // AKA facial recogition \n                  onPlay = /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                      var options, result, dims, resizedResult, minConfidence;\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              options = new faceapi.TinyFaceDetectorOptions({\n                                inputSize: 512,\n                                scoreThreshold: 0.5\n                              });\n                              _context.next = 3;\n                              return faceapi.detectSingleFace(videoElement, options).withFaceExpressions();\n\n                            case 3:\n                              result = _context.sent;\n\n                              if (result) {\n                                dims = faceapi.matchDimensions(canvasElement, videoElement, true);\n                                resizedResult = faceapi.resizeResults(result, dims);\n                                minConfidence = 0.05;\n                                faceapi.draw.drawDetections(canvasElement, resizedResult);\n                                faceapi.draw.drawFaceExpressions(canvasElement, resizedResult, minConfidence);\n                              }\n\n                              setTimeout(function () {\n                                return onPlay();\n                              });\n\n                            case 6:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function onPlay() {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n\n                  videoElement.srcObject = stream;\n\n                  videoElement.onloadedmetadata = function () {\n                    videoElement.play();\n                  };\n\n                  videoElement.onplay = onPlay;\n\n                case 14:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function main() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }]);\n\n  return Video;\n}(Component);\n\nexport default Video;","map":{"version":3,"sources":["/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/src/component/facerec/Video.js"],"names":["React","Component","Video","main","faceapi","nets","tinyFaceDetector","load","loadFaceExpressionModel","canvasElement","document","getElementById","videoElement","querySelector","constraints","audio","video","navigator","mediaDevices","getUserMedia","stream","onPlay","options","TinyFaceDetectorOptions","inputSize","scoreThreshold","detectSingleFace","withFaceExpressions","result","dims","matchDimensions","resizedResult","resizeResults","minConfidence","draw","drawDetections","drawFaceExpressions","setTimeout","srcObject","onloadedmetadata","play","onplay"],"mappings":";;;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAO,+CAAP;AACA,OAAO,kDAAP;;IAEMC,K;;;;;;;;;;;6BACO;AACL,UAAMC,IAAI;AAAA,4EAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAEHC,OAAO,CAACC,IAAR,CAAaC,gBAAb,CAA8BC,IAA9B,CAAmC,GAAnC,CAFG;;AAAA;AAAA;AAAA,yBAIHH,OAAO,CAACI,uBAAR,CAAgC,GAAhC,CAJG;;AAAA;AAMT;AACMC,kBAAAA,aAPG,GAOaC,QAAQ,CAACC,cAAT,CAAwB,SAAxB,CAPb;AAQHC,kBAAAA,YARG,GAQYF,QAAQ,CAACG,aAAT,CAAuB,OAAvB,CARZ,EAUT;;AACMC,kBAAAA,WAXG,GAWW;AAAEC,oBAAAA,KAAK,EAAE,KAAT;AAAgBC,oBAAAA,KAAK,EAAE;AAAvB,mBAXX;AAAA;AAAA,yBAYYC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoCL,WAApC,CAZZ;;AAAA;AAYHM,kBAAAA,MAZG;;AAcT;AACA;AACMC,kBAAAA,MAhBG;AAAA,yFAgBM;AAAA;AAAA;AAAA;AAAA;AAAA;AAELC,8BAAAA,OAFK,GAEK,IAAIlB,OAAO,CAACmB,uBAAZ,CAAoC;AAAEC,gCAAAA,SAAS,EAAE,GAAb;AAAkBC,gCAAAA,cAAc,EAAE;AAAlC,+BAApC,CAFL;AAAA;AAAA,qCAGUrB,OAAO,CAACsB,gBAAR,CAAyBd,YAAzB,EAAuCU,OAAvC,EAAgDK,mBAAhD,EAHV;;AAAA;AAGLC,8BAAAA,MAHK;;AAKX,kCAAIA,MAAJ,EAAY;AACFC,gCAAAA,IADE,GACKzB,OAAO,CAAC0B,eAAR,CAAwBrB,aAAxB,EAAuCG,YAAvC,EAAqD,IAArD,CADL;AAEFmB,gCAAAA,aAFE,GAEc3B,OAAO,CAAC4B,aAAR,CAAsBJ,MAAtB,EAA8BC,IAA9B,CAFd;AAGFI,gCAAAA,aAHE,GAGc,IAHd;AAIR7B,gCAAAA,OAAO,CAAC8B,IAAR,CAAaC,cAAb,CAA4B1B,aAA5B,EAA2CsB,aAA3C;AACA3B,gCAAAA,OAAO,CAAC8B,IAAR,CAAaE,mBAAb,CAAiC3B,aAAjC,EAAgDsB,aAAhD,EAA+DE,aAA/D;AACH;;AAEDI,8BAAAA,UAAU,CAAC;AAAA,uCAAMhB,MAAM,EAAZ;AAAA,+BAAD,CAAV;;AAbW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAhBN;;AAAA,oCAgBHA,MAhBG;AAAA;AAAA;AAAA;;AAgCTT,kBAAAA,YAAY,CAAC0B,SAAb,GAAyBlB,MAAzB;;AACAR,kBAAAA,YAAY,CAAC2B,gBAAb,GAAgC,YAAM;AAClC3B,oBAAAA,YAAY,CAAC4B,IAAb;AACH,mBAFD;;AAGA5B,kBAAAA,YAAY,CAAC6B,MAAb,GAAsBpB,MAAtB;;AApCS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAH;;AAAA,wBAAJlB,IAAI;AAAA;AAAA;AAAA,SAAV;AAuCH;;;;EAzCeF,S;;AA4CpB,eAAeC,KAAf","sourcesContent":["import React, { Component } from \"react\"\nimport \"./face_expression_model-weights_manifest.json\"\nimport \"./tiny_face_detector_model-weights_manifest.json\"\n\nclass Video extends Component {\n    render() {\n        const main = async () => {\n            // load the face detection model\n            await faceapi.nets.tinyFaceDetector.load('/');\n            // load the face expression detection model\n            await faceapi.loadFaceExpressionModel('/');\n        \n            // get canvas and video elements\n            const canvasElement = document.getElementById(\"overlay\");\n            const videoElement = document.querySelector(\"video\");\n        \n            // get Webcam video stream\n            const constraints = { audio: false, video: {} };\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        \n            // what to do when the video stream is available\n            // AKA facial recogition \n            const onPlay = async () => {\n        \n                const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.5 });\n                const result = await faceapi.detectSingleFace(videoElement, options).withFaceExpressions();\n        \n                if (result) {\n                    const dims = faceapi.matchDimensions(canvasElement, videoElement, true);\n                    const resizedResult = faceapi.resizeResults(result, dims);\n                    const minConfidence = 0.05;\n                    faceapi.draw.drawDetections(canvasElement, resizedResult);\n                    faceapi.draw.drawFaceExpressions(canvasElement, resizedResult, minConfidence);\n                }\n        \n                setTimeout(() => onPlay());\n            }\n        \n            videoElement.srcObject = stream;\n            videoElement.onloadedmetadata = () => {\n                videoElement.play();\n            };\n            videoElement.onplay = onPlay;\n        \n        }        \n    }\n}\n\nexport default Video"]},"metadata":{},"sourceType":"module"}