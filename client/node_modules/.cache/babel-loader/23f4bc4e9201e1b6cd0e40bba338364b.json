{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as spectral from './op_list/spectral';\nimport * as transformation from './op_list/transformation';\nexport var OperationMapper = /*#__PURE__*/function () {\n  _createClass(OperationMapper, null, [{\n    key: \"Instance\",\n    // Singleton instance for the mapper\n    get: function get() {\n      return this._instance || (this._instance = new this());\n    } // Loads the op mapping from the JSON file.\n\n  }]);\n\n  function OperationMapper() {\n    var _ref;\n\n    _classCallCheck(this, OperationMapper);\n\n    var ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation, hashTable];\n\n    var mappersJson = (_ref = []).concat.apply(_ref, _toConsumableArray(ops.map(function (op) {\n      return op.json;\n    })));\n\n    this.opMappers = mappersJson.reduce(function (map, mapper) {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  } // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n\n\n  _createClass(OperationMapper, [{\n    key: \"transformGraph\",\n    value: function transformGraph(graph) {\n      var _this = this;\n\n      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tfNodes = graph.node;\n      var placeholders = [];\n      var weights = [];\n      var initNodes = [];\n      var nodes = tfNodes.reduce(function (map, node) {\n        map[node.name] = _this.mapNode(node);\n\n        if (node.op.startsWith('Placeholder')) {\n          placeholders.push(map[node.name]);\n        } else if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        } else if (node.input == null || node.input.length === 0) {\n          initNodes.push(map[node.name]);\n        }\n\n        return map;\n      }, {});\n      var inputs = [];\n      var outputs = [];\n      var inputNodeNameToKey = {};\n      var outputNodeNameToKey = {};\n\n      if (signature != null) {\n        inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n        outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n      }\n\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name) {\n          var _getNodeNameAndIndex = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex2 = _slicedToArray(_getNodeNameAndIndex, 1),\n              nodeName = _getNodeNameAndIndex2[0];\n\n          node.inputs.push(nodes[nodeName]);\n          nodes[nodeName].children.push(node);\n        });\n      }); // if signature has not outputs set, add any node that does not have\n      // outputs.\n\n      if (Object.keys(outputNodeNameToKey).length === 0) {\n        allNodes.forEach(function (key) {\n          var node = nodes[key];\n\n          if (node.children.length === 0) {\n            outputs.push(node);\n          }\n        });\n      } else {\n        Object.keys(outputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex3 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex4 = _slicedToArray(_getNodeNameAndIndex3, 1),\n              nodeName = _getNodeNameAndIndex4[0];\n\n          var node = nodes[nodeName];\n\n          if (node != null) {\n            node.signatureKey = outputNodeNameToKey[name];\n            outputs.push(node);\n          }\n        });\n      }\n\n      if (Object.keys(inputNodeNameToKey).length > 0) {\n        Object.keys(inputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex5 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex6 = _slicedToArray(_getNodeNameAndIndex5, 1),\n              nodeName = _getNodeNameAndIndex6[0];\n\n          var node = nodes[nodeName];\n\n          if (node) {\n            node.signatureKey = inputNodeNameToKey[name];\n            inputs.push(node);\n          }\n        });\n      } else {\n        inputs = placeholders;\n      }\n\n      var functions = {};\n\n      if (graph.library != null && graph.library.function != null) {\n        functions = graph.library.function.reduce(function (functions, func) {\n          functions[func.signature.name] = _this.mapFunction(func);\n          return functions;\n        }, {});\n      }\n\n      var result = {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature,\n        functions: functions\n      };\n\n      if (initNodes.length > 0) {\n        result.initNodes = initNodes;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"mapSignatureEntries\",\n    value: function mapSignatureEntries(entries) {\n      return Object.keys(entries || {}).reduce(function (prev, curr) {\n        prev[entries[curr].name] = curr;\n        return prev;\n      }, {});\n    }\n  }, {\n    key: \"mapNode\",\n    value: function mapNode(node) {\n      // Unsupported ops will cause an error at run-time (not parse time), since\n      // they may not be used by the actual execution subgraph.\n      var mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n\n      if (node.attr == null) {\n        node.attr = {};\n      }\n\n      var newNode = {\n        name: node.name,\n        op: node.op,\n        category: mapper.category,\n        inputNames: (node.input || []).map(function (input) {\n          return input.startsWith('^') ? input.substr(1) : input;\n        }),\n        inputs: [],\n        children: [],\n        inputParams: {},\n        attrParams: {},\n        rawAttrs: node.attr\n      };\n\n      if (mapper.inputs != null) {\n        newNode.inputParams = mapper.inputs.reduce(function (map, param) {\n          map[param.name] = {\n            type: param.type,\n            inputIndexStart: param.start,\n            inputIndexEnd: param.end\n          };\n          return map;\n        }, {});\n      }\n\n      if (mapper.attrs != null) {\n        newNode.attrParams = mapper.attrs.reduce(function (map, param) {\n          var type = param.type;\n          var value = undefined;\n\n          switch (param.type) {\n            case 'string':\n              value = getStringParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'string[]':\n              value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'number':\n              value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'number[]':\n              value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'bool':\n              value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'bool[]':\n              value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'shape':\n              value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'shape[]':\n              value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'dtype':\n              value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'dtype[]':\n              value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'func':\n              value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'tensor':\n            case 'tensors':\n              break;\n\n            default:\n              throw new Error(\"Unsupported param type: \".concat(param.type, \" for op: \").concat(node.op));\n          }\n\n          map[param.name] = {\n            value: value,\n            type: type\n          };\n          return map;\n        }, {});\n      }\n\n      return newNode;\n    } // map the TFunctionDef to TFJS graph object\n\n  }, {\n    key: \"mapFunction\",\n    value: function mapFunction(functionDef) {\n      var _this2 = this;\n\n      var tfNodes = functionDef.nodeDef;\n      var placeholders = [];\n      var weights = [];\n      var nodes = {};\n\n      if (tfNodes != null) {\n        nodes = tfNodes.reduce(function (map, node) {\n          map[node.name] = _this2.mapNode(node);\n\n          if (node.op === 'Const') {\n            weights.push(map[node.name]);\n          }\n\n          return map;\n        }, {});\n      }\n\n      var inputs = [];\n      var outputs = [];\n      functionDef.signature.inputArg.forEach(function (arg) {\n        var _getNodeNameAndIndex7 = getNodeNameAndIndex(arg.name),\n            _getNodeNameAndIndex8 = _slicedToArray(_getNodeNameAndIndex7, 1),\n            nodeName = _getNodeNameAndIndex8[0];\n\n        var node = {\n          name: nodeName,\n          op: 'Placeholder',\n          inputs: [],\n          inputNames: [],\n          category: 'graph',\n          inputParams: {},\n          attrParams: {\n            dtype: {\n              value: parseDtypeParam(arg.type),\n              type: 'dtype'\n            }\n          },\n          children: []\n        };\n        node.signatureKey = arg.name;\n        inputs.push(node);\n        nodes[nodeName] = node;\n      });\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name) {\n          var _getNodeNameAndIndex9 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex10 = _slicedToArray(_getNodeNameAndIndex9, 1),\n              nodeName = _getNodeNameAndIndex10[0];\n\n          node.inputs.push(nodes[nodeName]);\n          nodes[nodeName].children.push(node);\n        });\n      });\n      var returnNodeMap = functionDef.ret;\n      functionDef.signature.outputArg.forEach(function (output) {\n        var _getNodeNameAndIndex11 = getNodeNameAndIndex(returnNodeMap[output.name]),\n            _getNodeNameAndIndex12 = _slicedToArray(_getNodeNameAndIndex11, 2),\n            nodeName = _getNodeNameAndIndex12[0],\n            index = _getNodeNameAndIndex12[1];\n\n        var node = nodes[nodeName];\n\n        if (node != null) {\n          node.defaultOutput = index;\n          outputs.push(node);\n        }\n      });\n      var signature = this.mapArgsToSignature(functionDef);\n      return {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature\n      };\n    }\n  }, {\n    key: \"mapArgsToSignature\",\n    value: function mapArgsToSignature(functionDef) {\n      var _this3 = this;\n\n      return {\n        methodName: functionDef.signature.name,\n        inputs: functionDef.signature.inputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg);\n          return map;\n        }, {}),\n        outputs: functionDef.signature.outputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg, functionDef.ret);\n          return map;\n        }, {})\n      };\n    }\n  }, {\n    key: \"mapArgToTensorInfo\",\n    value: function mapArgToTensorInfo(arg, nameMap) {\n      var name = arg.name;\n\n      if (nameMap != null) {\n        name = nameMap[name];\n      }\n\n      return {\n        name: name,\n        dtype: arg.type\n      };\n    }\n  }]);\n\n  return OperationMapper;\n}();\nexport function decodeBase64(text) {\n  var global = env().global;\n\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  var param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  var param = attrs[name] || {};\n  var value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n      return 'float32';\n\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.func) {\n    return param.func.name;\n  }\n\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(function (v) {\n      return parseDtypeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n\n  if (shape.dim != null) {\n    return shape.dim.map(function (dim) {\n      return typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10);\n    });\n  }\n\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(function (v) {\n      return typeof v === 'number' ? v : parseInt(v, 10);\n    });\n  }\n\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(function (v) {\n      return parseStringParam(v, keepCase);\n    });\n  }\n\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(function (v) {\n      return parseTensorShapeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n\n  return def;\n}","map":null,"metadata":{},"sourceType":"module"}