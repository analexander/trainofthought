{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport var TextureManager = /*#__PURE__*/function () {\n  function TextureManager(gpgpu) {\n    _classCallCheck(this, TextureManager);\n\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  _createClass(TextureManager, [{\n    key: \"acquireTexture\",\n    value: function acquireTexture(shapeRC, usage, isPacked) {\n      var physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n      var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n\n      if (!(shapeKey in this.usedTextures)) {\n        this.usedTextures[shapeKey] = [];\n      }\n\n      var texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n\n      if (this.freeTextures[shapeKey].length > 0) {\n        this.numFreeTextures--;\n        this.numUsedTextures++;\n        this._numBytesFree -= texBytes;\n        this.log();\n\n        var _newTexture = this.freeTextures[shapeKey].shift();\n\n        this.usedTextures[shapeKey].push(_newTexture);\n        return _newTexture;\n      }\n\n      var newTexture;\n\n      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n      }\n\n      this.usedTextures[shapeKey].push(newTexture);\n      this.numUsedTextures++;\n      this._numBytesAllocated += texBytes;\n      this.log();\n      return newTexture;\n    }\n  }, {\n    key: \"releaseTexture\",\n    value: function releaseTexture(texture, shape, logicalTexType, isPacked) {\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n\n      var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n      var shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n\n      var texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n      var deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n\n      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n        this.gpgpu.deleteMatrixTexture(texture);\n        this._numBytesAllocated -= texBytes;\n      } else {\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this._numBytesFree += texBytes;\n      }\n\n      this.numUsedTextures--;\n      var texList = this.usedTextures[shapeKey];\n      var texIndex = texList.indexOf(texture);\n\n      if (texIndex < 0) {\n        throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n      }\n\n      texList.splice(texIndex, 1);\n      this.log();\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (!this.logEnabled) {\n        return;\n      }\n\n      var total = this.numFreeTextures + this.numUsedTextures;\n      console.log('Free/Used', \"\".concat(this.numFreeTextures, \" / \").concat(this.numUsedTextures), \"(\".concat(total, \")\"));\n      var freeRatio = this._numBytesFree / this._numBytesAllocated;\n      console.log(\"Bytes allocated: \".concat(this._numBytesAllocated));\n      console.log(\"Bytes unused: \".concat(this._numBytesFree, \" (\").concat(Math.round(100 * freeRatio), \"%)\"));\n    }\n  }, {\n    key: \"getNumUsedTextures\",\n    value: function getNumUsedTextures() {\n      return this.numUsedTextures;\n    }\n  }, {\n    key: \"getNumFreeTextures\",\n    value: function getNumFreeTextures() {\n      return this.numFreeTextures;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n\n      for (var texShape in this.freeTextures) {\n        this.freeTextures[texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex);\n        });\n      }\n\n      for (var _texShape in this.usedTextures) {\n        this.usedTextures[_texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex);\n        });\n      }\n\n      this.freeTextures = null;\n      this.usedTextures = null;\n      this.numUsedTextures = 0;\n      this.numFreeTextures = 0;\n      this._numBytesAllocated = 0;\n      this._numBytesFree = 0;\n    }\n  }, {\n    key: \"numBytesAllocated\",\n    get: function get() {\n      return this._numBytesAllocated;\n    }\n  }, {\n    key: \"numBytesFree\",\n    get: function get() {\n      return this._numBytesFree;\n    }\n  }]);\n\n  return TextureManager;\n}();\n\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  var glany = gl;\n\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  }\n\n  throw new Error(\"Unknown internal format \".concat(internalFormat));\n}\n\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  var internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  var numElements;\n\n  if (isPacked) {\n    var _getPackedMatrixTextu = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n        _getPackedMatrixTextu2 = _slicedToArray(_getPackedMatrixTextu, 2),\n        packedWidth = _getPackedMatrixTextu2[0],\n        packedHeight = _getPackedMatrixTextu2[1];\n\n    numElements = packedWidth * packedHeight;\n  } else {\n    var _getUnpackedMatrixTex = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n        _getUnpackedMatrixTex2 = _slicedToArray(_getUnpackedMatrixTex, 2),\n        width = _getUnpackedMatrixTex2[0],\n        height = _getUnpackedMatrixTex2[1];\n\n    numElements = width * height;\n  }\n\n  var bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n\n    default:\n      throw new Error(\"Unknown physical texture type \".concat(physicalTexType));\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(\"Unknown logical texture type \".concat(logicalTexType));\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return \"\".concat(shapeRowsCol[0], \"_\").concat(shapeRowsCol[1], \"_\").concat(physicalTexType, \"_\").concat(isPacked);\n}","map":null,"metadata":{},"sourceType":"module"}