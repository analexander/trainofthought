{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Point, Rect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks5 } from '../classes/FaceLandmarks5';\nimport { toNetInput } from '../dom';\nimport { extendWithFaceDetection, extendWithFaceLandmarks } from '../factories';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { bgrToRgbTensor } from './bgrToRgbTensor';\nimport { CELL_SIZE } from './config';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { getSizesForScale } from './getSizesForScale';\nimport { MtcnnOptions } from './MtcnnOptions';\nimport { pyramidDown } from './pyramidDown';\nimport { stage1 } from './stage1';\nimport { stage2 } from './stage2';\nimport { stage3 } from './stage3';\n\nvar Mtcnn =\n/** @class */\nfunction (_super) {\n  __extends(Mtcnn, _super);\n\n  function Mtcnn() {\n    return _super.call(this, 'Mtcnn') || this;\n  }\n\n  Mtcnn.prototype.load = function (weightsOrUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2\n        /*return*/\n        , _super.prototype.load.call(this, weightsOrUrl)];\n      });\n    });\n  };\n\n  Mtcnn.prototype.loadFromDisk = function (filePath) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2\n        /*return*/\n        , _super.prototype.loadFromDisk.call(this, filePath)];\n      });\n    });\n  };\n\n  Mtcnn.prototype.forwardInput = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            params = this.params;\n\n            if (!params) {\n              throw new Error('Mtcnn - load model before inference');\n            }\n\n            inputCanvas = input.canvases[0];\n\n            if (!inputCanvas) {\n              throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');\n            }\n\n            stats = {};\n            tsTotal = Date.now();\n            imgTensor = tf.tidy(function () {\n              return bgrToRgbTensor(tf.expandDims(tf.browser.fromPixels(inputCanvas)).toFloat());\n            });\n\n            onReturn = function onReturn(results) {\n              // dispose tensors on return\n              imgTensor.dispose();\n              stats.total = Date.now() - tsTotal;\n              return results;\n            };\n\n            _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\n            _b = new MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\n            scales = (scaleSteps || pyramidDown(minFaceSize, scaleFactor, [height, width])).filter(function (scale) {\n              var sizes = getSizesForScale(scale, [height, width]);\n              return Math.min(sizes.width, sizes.height) > CELL_SIZE;\n            }).slice(0, maxNumScales);\n            stats.scales = scales;\n            stats.pyramid = scales.map(function (scale) {\n              return getSizesForScale(scale, [height, width]);\n            });\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];\n\n          case 1:\n            out1 = _c.sent();\n            stats.total_stage1 = Date.now() - ts;\n\n            if (!out1.boxes.length) {\n              return [2\n              /*return*/\n              , onReturn({\n                results: [],\n                stats: stats\n              })];\n            }\n\n            stats.stage2_numInputBoxes = out1.boxes.length; // using the inputCanvas to extract and resize the image patches, since it is faster\n            // than doing this on the gpu\n\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];\n\n          case 2:\n            out2 = _c.sent();\n            stats.total_stage2 = Date.now() - ts;\n\n            if (!out2.boxes.length) {\n              return [2\n              /*return*/\n              , onReturn({\n                results: [],\n                stats: stats\n              })];\n            }\n\n            stats.stage3_numInputBoxes = out2.boxes.length;\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];\n\n          case 3:\n            out3 = _c.sent();\n            stats.total_stage3 = Date.now() - ts;\n            results = out3.boxes.map(function (box, idx) {\n              return extendWithFaceLandmarks(extendWithFaceDetection({}, new FaceDetection(out3.scores[idx], new Rect(box.left / width, box.top / height, box.width / width, box.height / height), {\n                height: height,\n                width: width\n              })), new FaceLandmarks5(out3.points[idx].map(function (pt) {\n                return pt.sub(new Point(box.left, box.top)).div(new Point(box.width, box.height));\n              }), {\n                width: box.width,\n                height: box.height\n              }));\n            });\n            return [2\n            /*return*/\n            , onReturn({\n              results: results,\n              stats: stats\n            })];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.forward = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_b.sent(), forwardParams])];\n\n          case 2:\n            return [2\n            /*return*/\n            , _b.sent().results];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent(), forwardParams])];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.getDefaultModelName = function () {\n    return 'mtcnn_model';\n  };\n\n  Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  };\n\n  Mtcnn.prototype.extractParams = function (weights) {\n    return extractParams(weights);\n  };\n\n  return Mtcnn;\n}(NeuralNetwork);\n\nexport { Mtcnn };","map":{"version":3,"sources":["../../../src/mtcnn/Mtcnn.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAZ,MAAoB,uBAApB;AAEA,SAAS,KAAT,EAAgB,IAAhB,QAA4B,YAA5B;AACA,SAAS,aAAT,QAA8B,0BAA9B;AACA,SAAS,cAAT,QAA+B,2BAA/B;AACA,SAA8B,UAA9B,QAAgD,QAAhD;AACA,SAAS,uBAAT,EAAkC,uBAAlC,QAAiE,cAAjE;AACA,SAAS,aAAT,QAA8B,kBAA9B;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,SAAT,QAA0B,UAA1B;AACA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,0BAAT,QAA2C,8BAA3C;AACA,SAAS,gBAAT,QAAiC,oBAAjC;AACA,SAAwB,YAAxB,QAA4C,gBAA5C;AACA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,MAAT,QAAuB,UAAvB;AACA,SAAS,MAAT,QAAuB,UAAvB;AACA,SAAS,MAAT,QAAuB,UAAvB;;AAGA,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2B,EAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;;AAEzB,WAAA,KAAA,GAAA;WACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,OAAN,KAAc,I;AACf;;AAEY,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,GAAb,UAAkB,YAAlB,EAAiE;;;AAC/D,QAAA,OAAO,CAAC,IAAR,CAAa,8CAAb;AACA,eAAA,CAAA;AAAA;AAAA,UAAO,MAAA,CAAA,SAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,YAAX,CAAP,CAAA;;;AACD,GAHY;;AAKA,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAb,UAA0B,QAA1B,EAAsD;;;AACpD,QAAA,OAAO,CAAC,IAAR,CAAa,8CAAb;AACA,eAAA,CAAA;AAAA;AAAA,UAAO,MAAA,CAAA,SAAA,CAAM,YAAN,CAAkB,IAAlB,CAAkB,IAAlB,EAAmB,QAAnB,CAAP,CAAA;;;AACD,GAHY;;AAKA,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAb,UACE,KADF,EAEE,aAFF,EAEmC;AAAjC,QAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,aAAA,GAAA,EAAA;AAAiC;;;;;;;;AAGzB,YAAA,MAAM,GAAK,KAAL,MAAN;;AAER,gBAAI,CAAC,MAAL,EAAa;AACX,oBAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAEK,YAAA,WAAW,GAAG,KAAK,CAAC,QAAN,CAAe,CAAf,CAAd;;AAEN,gBAAI,CAAC,WAAL,EAAkB;AAChB,oBAAM,IAAI,KAAJ,CAAU,6GAAV,CAAN;AACD;;AAEK,YAAA,KAAK,GAAQ,EAAb;AAEA,YAAA,OAAO,GAAG,IAAI,CAAC,GAAL,EAAV;AAEA,YAAA,SAAS,GAAG,EAAE,CAAC,IAAH,CAAQ,YAAA;AACxB,qBAAA,cAAc,CACZ,EAAE,CAAC,UAAH,CAAc,EAAE,CAAC,OAAH,CAAW,UAAX,CAAsB,WAAtB,CAAd,EAAkD,OAAlD,EADY,CAAd;AAEC,aAHe,CAAZ;;AAMA,YAAA,QAAQ,GAAG,kBAAC,OAAD,EAAa;AAC5B;AACA,cAAA,SAAS,CAAC,OAAV;AACA,cAAA,KAAK,CAAC,KAAN,GAAc,IAAI,CAAC,GAAL,KAAa,OAA3B;AACA,qBAAO,OAAP;AACD,aALK;;AAOA,YAAA,EAAA,GAAkB,SAAS,CAAC,KAAV,CAAgB,KAAhB,CAAsB,CAAtB,CAAlB,EAAC,MAAM,GAAA,EAAA,CAAA,CAAA,CAAP,EAAS,KAAK,GAAA,EAAA,CAAA,CAAA,CAAd;AAEA,YAAA,EAAA,GAMF,IAAI,YAAJ,CAAiB,aAAjB,CANE,EACJ,WAAW,GAAA,EAAA,CAAA,WADP,EAEJ,WAAW,GAAA,EAAA,CAAA,WAFP,EAGJ,YAAY,GAAA,EAAA,CAAA,YAHR,EAIJ,eAAe,GAAA,EAAA,CAAA,eAJX,EAKJ,UAAU,GAAA,EAAA,CAAA,UALN;AAQA,YAAA,MAAM,GAAG,CAAC,UAAU,IAAI,WAAW,CAAC,WAAD,EAAc,WAAd,EAA2B,CAAC,MAAD,EAAS,KAAT,CAA3B,CAA1B,EACZ,MADY,CACL,UAAA,KAAA,EAAK;AACX,kBAAM,KAAK,GAAG,gBAAgB,CAAC,KAAD,EAAQ,CAAC,MAAD,EAAS,KAAT,CAAR,CAA9B;AACA,qBAAO,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,KAAf,EAAsB,KAAK,CAAC,MAA5B,IAAsC,SAA7C;AACD,aAJY,EAKZ,KALY,CAKN,CALM,EAKH,YALG,CAAT;AAON,YAAA,KAAK,CAAC,MAAN,GAAe,MAAf;AACA,YAAA,KAAK,CAAC,OAAN,GAAgB,MAAM,CAAC,GAAP,CAAW,UAAA,KAAA,EAAK;AAAI,qBAAA,gBAAgB,CAAC,KAAD,EAAQ,CAAC,MAAD,EAAxB,KAAwB,CAAR,CAAhB;AAAwC,aAA5D,CAAhB;AAEI,YAAA,EAAE,GAAG,IAAI,CAAC,GAAL,EAAL;AACS,mBAAA,CAAA;AAAA;AAAA,cAAM,MAAM,CAAC,SAAD,EAAY,MAAZ,EAAoB,eAAe,CAAC,CAAD,CAAnC,EAAwC,MAAM,CAAC,IAA/C,EAAqD,KAArD,CAAZ,CAAA;;;AAAP,YAAA,IAAI,GAAG,EAAA,CAAA,IAAA,EAAP;AACN,YAAA,KAAK,CAAC,YAAN,GAAqB,IAAI,CAAC,GAAL,KAAa,EAAlC;;AAEA,gBAAI,CAAC,IAAI,CAAC,KAAL,CAAW,MAAhB,EAAwB;AACtB,qBAAA,CAAA;AAAA;AAAA,gBAAO,QAAQ,CAAC;AAAE,gBAAA,OAAO,EAAE,EAAX;AAAe,gBAAA,KAAK,EAAA;AAApB,eAAD,CAAf,CAAA;AACD;;AAED,YAAA,KAAK,CAAC,oBAAN,GAA6B,IAAI,CAAC,KAAL,CAAW,MAAxC,C,CACA;AACA;;AACA,YAAA,EAAE,GAAG,IAAI,CAAC,GAAL,EAAL;AACa,mBAAA,CAAA;AAAA;AAAA,cAAM,MAAM,CAAC,WAAD,EAAc,IAAI,CAAC,KAAnB,EAA0B,eAAe,CAAC,CAAD,CAAzC,EAA8C,MAAM,CAAC,IAArD,EAA2D,KAA3D,CAAZ,CAAA;;;AAAP,YAAA,IAAI,GAAG,EAAA,CAAA,IAAA,EAAP;AACN,YAAA,KAAK,CAAC,YAAN,GAAqB,IAAI,CAAC,GAAL,KAAa,EAAlC;;AAEA,gBAAI,CAAC,IAAI,CAAC,KAAL,CAAW,MAAhB,EAAwB;AACtB,qBAAA,CAAA;AAAA;AAAA,gBAAO,QAAQ,CAAC;AAAE,gBAAA,OAAO,EAAE,EAAX;AAAe,gBAAA,KAAK,EAAA;AAApB,eAAD,CAAf,CAAA;AACD;;AAED,YAAA,KAAK,CAAC,oBAAN,GAA6B,IAAI,CAAC,KAAL,CAAW,MAAxC;AAEA,YAAA,EAAE,GAAG,IAAI,CAAC,GAAL,EAAL;AACa,mBAAA,CAAA;AAAA;AAAA,cAAM,MAAM,CAAC,WAAD,EAAc,IAAI,CAAC,KAAnB,EAA0B,eAAe,CAAC,CAAD,CAAzC,EAA8C,MAAM,CAAC,IAArD,EAA2D,KAA3D,CAAZ,CAAA;;;AAAP,YAAA,IAAI,GAAG,EAAA,CAAA,IAAA,EAAP;AACN,YAAA,KAAK,CAAC,YAAN,GAAqB,IAAI,CAAC,GAAL,KAAa,EAAlC;AAEM,YAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,UAAC,GAAD,EAAM,GAAN,EAAS;AAAK,qBAAA,uBAAuB,CAClE,uBAAuB,CACrB,EADqB,EAErB,IAAI,aAAJ,CACE,IAAI,CAAC,MAAL,CAAY,GAAZ,CADF,EAEE,IAAI,IAAJ,CACE,GAAG,CAAC,IAAJ,GAAW,KADb,EAEE,GAAG,CAAC,GAAJ,GAAU,MAFZ,EAGE,GAAG,CAAC,KAAJ,GAAY,KAHd,EAIE,GAAG,CAAC,MAAJ,GAAa,MAJf,CAFF,EAQE;AACE,gBAAA,MAAM,EAAA,MADR;AAEE,gBAAA,KAAK,EAAA;AAFP,eARF,CAFqB,CAD2C,EAiBlE,IAAI,cAAJ,CACE,IAAI,CAAC,MAAL,CAAY,GAAZ,EAAiB,GAAjB,CAAqB,UAAA,EAAA,EAAE;AAAI,uBAAA,EAAE,CAAC,GAAH,CAAO,IAAI,KAAJ,CAAU,GAAG,CAAC,IAAd,EAAoB,GAAG,CAAC,GAAxB,CAAP,EAAqC,GAArC,CAAyC,IAAI,KAAJ,CAAU,GAAG,CAAC,KAAd,EAAqB,GAAG,CAAjE,MAAyC,CAAzC,CAAA;AAA0E,eAArG,CADF,EAEE;AAAE,gBAAA,KAAK,EAAE,GAAG,CAAC,KAAb;AAAoB,gBAAA,MAAM,EAAE,GAAG,CAnBU;AAmBzC,eAFF,CAjBkE,CAAvB;AAqB5C,aArBe,CAAV;AAuBN,mBAAA,CAAA;AAAA;AAAA,cAAO,QAAQ,CAAC;AAAE,cAAA,OAAO,EAAA,OAAT;AAAW,cAAA,KAAK,EAAA;AAAhB,aAAD,CAAf,CAAA;;;;AACD,GAvGY;;AAyGA,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAb,UACE,KADF,EAEE,aAFF,EAEmC;AAAjC,QAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,aAAA,GAAA,EAAA;AAAiC;;;;;;;;AAGzB,YAAA,EAAA,GAAA,KAAK,YAAL;AACJ,mBAAA,CAAA;AAAA;AAAA,cAAM,UAAU,CAAC,KAAD,CAAhB,CAAA;;;AADF,mBAAA,CAAA;AAAA;AAAA,cAAM,EAAA,CAAA,KAAA,CAAA,IAAA,EAAI,CACR,EAAA,CAAA,IAAA,EADQ,EAER,aAFQ,CAAJ,CAAN,CAAA;;;AADF,mBAAA,CAAA;AAAA;AAAA,cACE,EAAA,CAAA,IAAA,EADK,CAKL,OALF,CAAA;;;;AAMD,GAVY;;AAYA,EAAA,KAAA,CAAA,SAAA,CAAA,gBAAA,GAAb,UACE,KADF,EAEE,aAFF,EAEmC;AAAjC,QAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,aAAA,GAAA,EAAA;AAAiC;;;;;;;;AAE1B,YAAA,EAAA,GAAA,KAAK,YAAL;AACL,mBAAA,CAAA;AAAA;AAAA,cAAM,UAAU,CAAC,KAAD,CAAhB,CAAA;;;AADF,mBAAA,CAAA;AAAA;AAAA,cAAO,EAAA,CAAA,KAAA,CAAA,IAAA,EAAI,CACT,EAAA,CAAA,IAAA,EADS,EAET,aAFS,CAAJ,CAAP,CAAA;;;;AAID,GARY;;AAUH,EAAA,KAAA,CAAA,SAAA,CAAA,mBAAA,GAAV,YAAA;AACE,WAAO,aAAP;AACD,GAFS;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,0BAAA,GAAV,UAAqC,SAArC,EAAiE;AAC/D,WAAO,0BAA0B,CAAC,SAAD,CAAjC;AACD,GAFS;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,OAAxB,EAA6C;AAC3C,WAAO,aAAa,CAAC,OAAD,CAApB;AACD,GAFS;;AAGZ,SAAA,KAAA;AAAC,CA1JD,CAA2B,aAA3B,CAAA","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { Point, Rect } from '../classes';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { FaceLandmarks5 } from '../classes/FaceLandmarks5';\r\nimport { toNetInput } from '../dom';\r\nimport { extendWithFaceDetection, extendWithFaceLandmarks } from '../factories';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { bgrToRgbTensor } from './bgrToRgbTensor';\r\nimport { CELL_SIZE } from './config';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\r\nimport { getSizesForScale } from './getSizesForScale';\r\nimport { MtcnnOptions } from './MtcnnOptions';\r\nimport { pyramidDown } from './pyramidDown';\r\nimport { stage1 } from './stage1';\r\nimport { stage2 } from './stage2';\r\nimport { stage3 } from './stage3';\r\nvar Mtcnn = /** @class */ (function (_super) {\r\n    __extends(Mtcnn, _super);\r\n    function Mtcnn() {\r\n        return _super.call(this, 'Mtcnn') || this;\r\n    }\r\n    Mtcnn.prototype.load = function (weightsOrUrl) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                console.warn('mtcnn is deprecated and will be removed soon');\r\n                return [2 /*return*/, _super.prototype.load.call(this, weightsOrUrl)];\r\n            });\r\n        });\r\n    };\r\n    Mtcnn.prototype.loadFromDisk = function (filePath) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                console.warn('mtcnn is deprecated and will be removed soon');\r\n                return [2 /*return*/, _super.prototype.loadFromDisk.call(this, filePath)];\r\n            });\r\n        });\r\n    };\r\n    Mtcnn.prototype.forwardInput = function (input, forwardParams) {\r\n        if (forwardParams === void 0) { forwardParams = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        params = this.params;\r\n                        if (!params) {\r\n                            throw new Error('Mtcnn - load model before inference');\r\n                        }\r\n                        inputCanvas = input.canvases[0];\r\n                        if (!inputCanvas) {\r\n                            throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');\r\n                        }\r\n                        stats = {};\r\n                        tsTotal = Date.now();\r\n                        imgTensor = tf.tidy(function () {\r\n                            return bgrToRgbTensor(tf.expandDims(tf.browser.fromPixels(inputCanvas)).toFloat());\r\n                        });\r\n                        onReturn = function (results) {\r\n                            // dispose tensors on return\r\n                            imgTensor.dispose();\r\n                            stats.total = Date.now() - tsTotal;\r\n                            return results;\r\n                        };\r\n                        _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\r\n                        _b = new MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\r\n                        scales = (scaleSteps || pyramidDown(minFaceSize, scaleFactor, [height, width]))\r\n                            .filter(function (scale) {\r\n                            var sizes = getSizesForScale(scale, [height, width]);\r\n                            return Math.min(sizes.width, sizes.height) > CELL_SIZE;\r\n                        })\r\n                            .slice(0, maxNumScales);\r\n                        stats.scales = scales;\r\n                        stats.pyramid = scales.map(function (scale) { return getSizesForScale(scale, [height, width]); });\r\n                        ts = Date.now();\r\n                        return [4 /*yield*/, stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];\r\n                    case 1:\r\n                        out1 = _c.sent();\r\n                        stats.total_stage1 = Date.now() - ts;\r\n                        if (!out1.boxes.length) {\r\n                            return [2 /*return*/, onReturn({ results: [], stats: stats })];\r\n                        }\r\n                        stats.stage2_numInputBoxes = out1.boxes.length;\r\n                        // using the inputCanvas to extract and resize the image patches, since it is faster\r\n                        // than doing this on the gpu\r\n                        ts = Date.now();\r\n                        return [4 /*yield*/, stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];\r\n                    case 2:\r\n                        out2 = _c.sent();\r\n                        stats.total_stage2 = Date.now() - ts;\r\n                        if (!out2.boxes.length) {\r\n                            return [2 /*return*/, onReturn({ results: [], stats: stats })];\r\n                        }\r\n                        stats.stage3_numInputBoxes = out2.boxes.length;\r\n                        ts = Date.now();\r\n                        return [4 /*yield*/, stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];\r\n                    case 3:\r\n                        out3 = _c.sent();\r\n                        stats.total_stage3 = Date.now() - ts;\r\n                        results = out3.boxes.map(function (box, idx) { return extendWithFaceLandmarks(extendWithFaceDetection({}, new FaceDetection(out3.scores[idx], new Rect(box.left / width, box.top / height, box.width / width, box.height / height), {\r\n                            height: height,\r\n                            width: width\r\n                        })), new FaceLandmarks5(out3.points[idx].map(function (pt) { return pt.sub(new Point(box.left, box.top)).div(new Point(box.width, box.height)); }), { width: box.width, height: box.height })); });\r\n                        return [2 /*return*/, onReturn({ results: results, stats: stats })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Mtcnn.prototype.forward = function (input, forwardParams) {\r\n        if (forwardParams === void 0) { forwardParams = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(),\r\n                            forwardParams])];\r\n                    case 2: return [2 /*return*/, (_b.sent()).results];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {\r\n        if (forwardParams === void 0) { forwardParams = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent(),\r\n                            forwardParams])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Mtcnn.prototype.getDefaultModelName = function () {\r\n        return 'mtcnn_model';\r\n    };\r\n    Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {\r\n        return extractParamsFromWeigthMap(weightMap);\r\n    };\r\n    Mtcnn.prototype.extractParams = function (weights) {\r\n        return extractParams(weights);\r\n    };\r\n    return Mtcnn;\r\n}(NeuralNetwork));\r\nexport { Mtcnn };\r\n//# sourceMappingURL=Mtcnn.js.map"]},"metadata":{},"sourceType":"module"}