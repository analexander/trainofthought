{"ast":null,"code":"import * as tf from '@tensorflow/tfjs-core';\nimport { BoundingBox, Point } from '../classes';\nimport { nonMaxSuppression } from '../ops';\nimport { CELL_SIZE, CELL_STRIDE } from './config';\nimport { getSizesForScale } from './getSizesForScale';\nimport { MtcnnBox } from './MtcnnBox';\nimport { normalize } from './normalize';\nimport { PNet } from './PNet';\n\nfunction rescaleAndNormalize(x, scale) {\n  return tf.tidy(function () {\n    var _a = getSizesForScale(scale, x.shape.slice(1)),\n        height = _a.height,\n        width = _a.width;\n\n    var resized = tf.image.resizeBilinear(x, [height, width]);\n    var normalized = normalize(resized);\n    return tf.transpose(normalized, [0, 2, 1, 3]);\n  });\n}\n\nfunction extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {\n  // TODO: fix this!, maybe better to use tf.gather here\n  var indices = [];\n  var scoresData = scoresTensor.arraySync();\n\n  for (var y = 0; y < scoresTensor.shape[0]; y++) {\n    for (var x = 0; x < scoresTensor.shape[1]; x++) {\n      if (scoresData[y][x] >= scoreThreshold) {\n        indices.push(new Point(x, y));\n      }\n    }\n  }\n\n  var boundingBoxes = indices.map(function (idx) {\n    var cell = new BoundingBox(Math.round((idx.y * CELL_STRIDE + 1) / scale), Math.round((idx.x * CELL_STRIDE + 1) / scale), Math.round((idx.y * CELL_STRIDE + CELL_SIZE) / scale), Math.round((idx.x * CELL_STRIDE + CELL_SIZE) / scale));\n    var score = scoresData[idx.y][idx.x];\n    var regionsData = regionsTensor.arraySync();\n    var region = new MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);\n    return {\n      cell: cell,\n      score: score,\n      region: region\n    };\n  });\n  return boundingBoxes;\n}\n\nexport function stage1(imgTensor, scales, scoreThreshold, params, stats) {\n  stats.stage1 = [];\n  var pnetOutputs = scales.map(function (scale) {\n    return tf.tidy(function () {\n      var statsForScale = {\n        scale: scale\n      };\n      var resized = rescaleAndNormalize(imgTensor, scale);\n      var ts = Date.now();\n\n      var _a = PNet(resized, params),\n          prob = _a.prob,\n          regions = _a.regions;\n\n      statsForScale.pnet = Date.now() - ts;\n      var scoresTensor = tf.unstack(tf.unstack(prob, 3)[1])[0];\n      var regionsTensor = tf.unstack(regions)[0];\n      return {\n        scoresTensor: scoresTensor,\n        regionsTensor: regionsTensor,\n        scale: scale,\n        statsForScale: statsForScale\n      };\n    });\n  });\n  var boxesForScale = pnetOutputs.map(function (_a) {\n    var scoresTensor = _a.scoresTensor,\n        regionsTensor = _a.regionsTensor,\n        scale = _a.scale,\n        statsForScale = _a.statsForScale;\n    var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);\n    scoresTensor.dispose();\n    regionsTensor.dispose();\n\n    if (!boundingBoxes.length) {\n      stats.stage1.push(statsForScale);\n      return [];\n    }\n\n    var ts = Date.now();\n    var indices = nonMaxSuppression(boundingBoxes.map(function (bbox) {\n      return bbox.cell;\n    }), boundingBoxes.map(function (bbox) {\n      return bbox.score;\n    }), 0.5);\n    statsForScale.nms = Date.now() - ts;\n    statsForScale.numBoxes = indices.length;\n    stats.stage1.push(statsForScale);\n    return indices.map(function (boxIdx) {\n      return boundingBoxes[boxIdx];\n    });\n  });\n  var allBoxes = boxesForScale.reduce(function (all, boxes) {\n    return all.concat(boxes);\n  }, []);\n  var finalBoxes = [];\n  var finalScores = [];\n\n  if (allBoxes.length > 0) {\n    var ts = Date.now();\n    var indices = nonMaxSuppression(allBoxes.map(function (bbox) {\n      return bbox.cell;\n    }), allBoxes.map(function (bbox) {\n      return bbox.score;\n    }), 0.7);\n    stats.stage1_nms = Date.now() - ts;\n    finalScores = indices.map(function (idx) {\n      return allBoxes[idx].score;\n    });\n    finalBoxes = indices.map(function (idx) {\n      return allBoxes[idx];\n    }).map(function (_a) {\n      var cell = _a.cell,\n          region = _a.region;\n      return new BoundingBox(cell.left + region.left * cell.width, cell.top + region.top * cell.height, cell.right + region.right * cell.width, cell.bottom + region.bottom * cell.height).toSquare().round();\n    });\n  }\n\n  return {\n    boxes: finalBoxes,\n    scores: finalScores\n  };\n}","map":{"version":3,"sources":["../../../src/mtcnn/stage1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tf from '@tensorflow/tfjs-core';\r\nimport { BoundingBox, Point } from '../classes';\r\nimport { nonMaxSuppression } from '../ops';\r\nimport { CELL_SIZE, CELL_STRIDE } from './config';\r\nimport { getSizesForScale } from './getSizesForScale';\r\nimport { MtcnnBox } from './MtcnnBox';\r\nimport { normalize } from './normalize';\r\nimport { PNet } from './PNet';\r\nfunction rescaleAndNormalize(x, scale) {\r\n    return tf.tidy(function () {\r\n        var _a = getSizesForScale(scale, x.shape.slice(1)), height = _a.height, width = _a.width;\r\n        var resized = tf.image.resizeBilinear(x, [height, width]);\r\n        var normalized = normalize(resized);\r\n        return tf.transpose(normalized, [0, 2, 1, 3]);\r\n    });\r\n}\r\nfunction extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {\r\n    // TODO: fix this!, maybe better to use tf.gather here\r\n    var indices = [];\r\n    var scoresData = scoresTensor.arraySync();\r\n    for (var y = 0; y < scoresTensor.shape[0]; y++) {\r\n        for (var x = 0; x < scoresTensor.shape[1]; x++) {\r\n            if (scoresData[y][x] >= scoreThreshold) {\r\n                indices.push(new Point(x, y));\r\n            }\r\n        }\r\n    }\r\n    var boundingBoxes = indices.map(function (idx) {\r\n        var cell = new BoundingBox(Math.round((idx.y * CELL_STRIDE + 1) / scale), Math.round((idx.x * CELL_STRIDE + 1) / scale), Math.round((idx.y * CELL_STRIDE + CELL_SIZE) / scale), Math.round((idx.x * CELL_STRIDE + CELL_SIZE) / scale));\r\n        var score = scoresData[idx.y][idx.x];\r\n        var regionsData = regionsTensor.arraySync();\r\n        var region = new MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);\r\n        return {\r\n            cell: cell,\r\n            score: score,\r\n            region: region\r\n        };\r\n    });\r\n    return boundingBoxes;\r\n}\r\nexport function stage1(imgTensor, scales, scoreThreshold, params, stats) {\r\n    stats.stage1 = [];\r\n    var pnetOutputs = scales.map(function (scale) { return tf.tidy(function () {\r\n        var statsForScale = { scale: scale };\r\n        var resized = rescaleAndNormalize(imgTensor, scale);\r\n        var ts = Date.now();\r\n        var _a = PNet(resized, params), prob = _a.prob, regions = _a.regions;\r\n        statsForScale.pnet = Date.now() - ts;\r\n        var scoresTensor = tf.unstack(tf.unstack(prob, 3)[1])[0];\r\n        var regionsTensor = tf.unstack(regions)[0];\r\n        return {\r\n            scoresTensor: scoresTensor,\r\n            regionsTensor: regionsTensor,\r\n            scale: scale,\r\n            statsForScale: statsForScale\r\n        };\r\n    }); });\r\n    var boxesForScale = pnetOutputs.map(function (_a) {\r\n        var scoresTensor = _a.scoresTensor, regionsTensor = _a.regionsTensor, scale = _a.scale, statsForScale = _a.statsForScale;\r\n        var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);\r\n        scoresTensor.dispose();\r\n        regionsTensor.dispose();\r\n        if (!boundingBoxes.length) {\r\n            stats.stage1.push(statsForScale);\r\n            return [];\r\n        }\r\n        var ts = Date.now();\r\n        var indices = nonMaxSuppression(boundingBoxes.map(function (bbox) { return bbox.cell; }), boundingBoxes.map(function (bbox) { return bbox.score; }), 0.5);\r\n        statsForScale.nms = Date.now() - ts;\r\n        statsForScale.numBoxes = indices.length;\r\n        stats.stage1.push(statsForScale);\r\n        return indices.map(function (boxIdx) { return boundingBoxes[boxIdx]; });\r\n    });\r\n    var allBoxes = boxesForScale.reduce(function (all, boxes) { return all.concat(boxes); }, []);\r\n    var finalBoxes = [];\r\n    var finalScores = [];\r\n    if (allBoxes.length > 0) {\r\n        var ts = Date.now();\r\n        var indices = nonMaxSuppression(allBoxes.map(function (bbox) { return bbox.cell; }), allBoxes.map(function (bbox) { return bbox.score; }), 0.7);\r\n        stats.stage1_nms = Date.now() - ts;\r\n        finalScores = indices.map(function (idx) { return allBoxes[idx].score; });\r\n        finalBoxes = indices\r\n            .map(function (idx) { return allBoxes[idx]; })\r\n            .map(function (_a) {\r\n            var cell = _a.cell, region = _a.region;\r\n            return new BoundingBox(cell.left + (region.left * cell.width), cell.top + (region.top * cell.height), cell.right + (region.right * cell.width), cell.bottom + (region.bottom * cell.height)).toSquare().round();\r\n        });\r\n    }\r\n    return {\r\n        boxes: finalBoxes,\r\n        scores: finalScores\r\n    };\r\n}\r\n//# sourceMappingURL=stage1.js.map"]},"metadata":{},"sourceType":"module"}