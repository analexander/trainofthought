{"ast":null,"code":"import _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { computeStrides } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  if (tensor.rank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + \" but the rank was \".concat(tensor.rank, \".\"));\n  }\n\n  if (indices.rank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + \" but the rank was \".concat(indices.rank, \".\"));\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + \" but the dtype was \".concat(indices.dtype, \".\"));\n  }\n\n  if (indices.shape[indices.rank - 1] > tensor.rank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + \"\".concat(indices.shape[indices.rank - 1], \" vs. \").concat(tensor.rank));\n  }\n\n  if (tensor.size === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + \" Input shape: \".concat(tensor.shape, \".\"));\n  }\n\n  var indicesShape = indices.shape;\n  var sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  var nResult = 1;\n\n  for (var i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  var inputShape = tensor.shape;\n  var resultShape = indicesShape.slice();\n  resultShape.pop();\n  var sliceSize = 1;\n\n  for (var _i = sliceRank; _i < tensor.rank; ++_i) {\n    sliceSize *= inputShape[_i];\n    resultShape.push(inputShape[_i]);\n  }\n\n  var strides = [].concat(_toConsumableArray(computeStrides(tensor.shape).map(function (stride) {\n    return stride / sliceSize;\n  })), [1]).slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":null,"metadata":{},"sourceType":"module"}