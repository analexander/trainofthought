{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\n\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {\n  var $image = convertToTensor(image, 'image', 'cropAndResize');\n  var $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  var $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  method = method || 'bilinear';\n  extrapolationValue = extrapolationValue || 0;\n  var numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, function () {\n    return 'Error in cropAndResize: image must be rank 4,' + \"but got rank \".concat($image.rank, \".\");\n  });\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, function () {\n    return \"Error in cropAndResize: boxes must be have size [\".concat(numBoxes, \",4] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, function () {\n    return \"Error in cropAndResize: boxInd must be have size [\".concat(numBoxes, \"] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert(cropSize.length === 2, function () {\n    return \"Error in cropAndResize: cropSize must be of length 2, but got \" + \"length \".concat(cropSize.length, \".\");\n  });\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, function () {\n    return \"cropSize must be atleast [1,1], but was \".concat(cropSize);\n  });\n  util.assert(method === 'bilinear' || method === 'nearest', function () {\n    return \"method must be bilinear or nearest, but was \".concat(method);\n  });\n\n  var forward = function forward(backend) {\n    return backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);\n  };\n\n  var inputs = {\n    image: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  };\n  var attrs = {\n    method: method,\n    extrapolationValue: extrapolationValue,\n    cropSize: cropSize\n  };\n  var res = ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , CropAndResize, attrs);\n  return res;\n}\n\nexport var cropAndResize = op({\n  cropAndResize_: cropAndResize_\n});","map":null,"metadata":{},"sourceType":"module"}