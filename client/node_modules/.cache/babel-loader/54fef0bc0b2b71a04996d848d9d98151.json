{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Rect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { mobileNetV1 } from './mobileNetV1';\nimport { nonMaxSuppression } from './nonMaxSuppression';\nimport { outputLayer } from './outputLayer';\nimport { predictionLayer } from './predictionLayer';\nimport { SsdMobilenetv1Options } from './SsdMobilenetv1Options';\n\nvar SsdMobilenetv1 =\n/** @class */\nfunction (_super) {\n  __extends(SsdMobilenetv1, _super);\n\n  function SsdMobilenetv1() {\n    return _super.call(this, 'SsdMobilenetv1') || this;\n  }\n\n  SsdMobilenetv1.prototype.forwardInput = function (input) {\n    var params = this.params;\n\n    if (!params) {\n      throw new Error('SsdMobilenetv1 - load model before inference');\n    }\n\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(512, false).toFloat();\n      var x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1));\n      var features = mobileNetV1(x, params.mobilenetv1);\n\n      var _a = predictionLayer(features.out, features.conv11, params.prediction_layer),\n          boxPredictions = _a.boxPredictions,\n          classPredictions = _a.classPredictions;\n\n      return outputLayer(boxPredictions, classPredictions, params.output_layer);\n    });\n  };\n\n  SsdMobilenetv1.prototype.forward = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  SsdMobilenetv1.prototype.locateFaces = function (input, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _a = new SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _e.sent();\n            _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;\n            boxes = _boxes[0];\n            scores = _scores[0];\n\n            for (i = 1; i < _boxes.length; i++) {\n              _boxes[i].dispose();\n\n              _scores[i].dispose();\n            }\n\n            _d = (_c = Array).from;\n            return [4\n            /*yield*/\n            , scores.data()];\n\n          case 2:\n            scoresData = _d.apply(_c, [_e.sent()]);\n            iouThreshold = 0.5;\n            indices = nonMaxSuppression(boxes, scoresData, maxResults, iouThreshold, minConfidence);\n            reshapedDims = netInput.getReshapedInputDimensions(0);\n            inputSize = netInput.inputSize;\n            padX = inputSize / reshapedDims.width;\n            padY = inputSize / reshapedDims.height;\n            boxesData = boxes.arraySync();\n            results = indices.map(function (idx) {\n              var _a = [Math.max(0, boxesData[idx][0]), Math.min(1.0, boxesData[idx][2])].map(function (val) {\n                return val * padY;\n              }),\n                  top = _a[0],\n                  bottom = _a[1];\n\n              var _b = [Math.max(0, boxesData[idx][1]), Math.min(1.0, boxesData[idx][3])].map(function (val) {\n                return val * padX;\n              }),\n                  left = _b[0],\n                  right = _b[1];\n\n              return new FaceDetection(scoresData[idx], new Rect(left, top, right - left, bottom - top), {\n                height: netInput.getInputHeight(0),\n                width: netInput.getInputWidth(0)\n              });\n            });\n            boxes.dispose();\n            scores.dispose();\n            return [2\n            /*return*/\n            , results];\n        }\n      });\n    });\n  };\n\n  SsdMobilenetv1.prototype.getDefaultModelName = function () {\n    return 'ssd_mobilenetv1_model';\n  };\n\n  SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  };\n\n  SsdMobilenetv1.prototype.extractParams = function (weights) {\n    return extractParams(weights);\n  };\n\n  return SsdMobilenetv1;\n}(NeuralNetwork);\n\nexport { SsdMobilenetv1 };","map":{"version":3,"sources":["../../../src/ssdMobilenetv1/SsdMobilenetv1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { Rect } from '../classes';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { toNetInput } from '../dom';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\r\nimport { mobileNetV1 } from './mobileNetV1';\r\nimport { nonMaxSuppression } from './nonMaxSuppression';\r\nimport { outputLayer } from './outputLayer';\r\nimport { predictionLayer } from './predictionLayer';\r\nimport { SsdMobilenetv1Options } from './SsdMobilenetv1Options';\r\nvar SsdMobilenetv1 = /** @class */ (function (_super) {\r\n    __extends(SsdMobilenetv1, _super);\r\n    function SsdMobilenetv1() {\r\n        return _super.call(this, 'SsdMobilenetv1') || this;\r\n    }\r\n    SsdMobilenetv1.prototype.forwardInput = function (input) {\r\n        var params = this.params;\r\n        if (!params) {\r\n            throw new Error('SsdMobilenetv1 - load model before inference');\r\n        }\r\n        return tf.tidy(function () {\r\n            var batchTensor = input.toBatchTensor(512, false).toFloat();\r\n            var x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1));\r\n            var features = mobileNetV1(x, params.mobilenetv1);\r\n            var _a = predictionLayer(features.out, features.conv11, params.prediction_layer), boxPredictions = _a.boxPredictions, classPredictions = _a.classPredictions;\r\n            return outputLayer(boxPredictions, classPredictions, params.output_layer);\r\n        });\r\n    };\r\n    SsdMobilenetv1.prototype.forward = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SsdMobilenetv1.prototype.locateFaces = function (input, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        _a = new SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _e.sent();\r\n                        _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;\r\n                        boxes = _boxes[0];\r\n                        scores = _scores[0];\r\n                        for (i = 1; i < _boxes.length; i++) {\r\n                            _boxes[i].dispose();\r\n                            _scores[i].dispose();\r\n                        }\r\n                        _d = (_c = Array).from;\r\n                        return [4 /*yield*/, scores.data()];\r\n                    case 2:\r\n                        scoresData = _d.apply(_c, [_e.sent()]);\r\n                        iouThreshold = 0.5;\r\n                        indices = nonMaxSuppression(boxes, scoresData, maxResults, iouThreshold, minConfidence);\r\n                        reshapedDims = netInput.getReshapedInputDimensions(0);\r\n                        inputSize = netInput.inputSize;\r\n                        padX = inputSize / reshapedDims.width;\r\n                        padY = inputSize / reshapedDims.height;\r\n                        boxesData = boxes.arraySync();\r\n                        results = indices\r\n                            .map(function (idx) {\r\n                            var _a = [\r\n                                Math.max(0, boxesData[idx][0]),\r\n                                Math.min(1.0, boxesData[idx][2])\r\n                            ].map(function (val) { return val * padY; }), top = _a[0], bottom = _a[1];\r\n                            var _b = [\r\n                                Math.max(0, boxesData[idx][1]),\r\n                                Math.min(1.0, boxesData[idx][3])\r\n                            ].map(function (val) { return val * padX; }), left = _b[0], right = _b[1];\r\n                            return new FaceDetection(scoresData[idx], new Rect(left, top, right - left, bottom - top), {\r\n                                height: netInput.getInputHeight(0),\r\n                                width: netInput.getInputWidth(0)\r\n                            });\r\n                        });\r\n                        boxes.dispose();\r\n                        scores.dispose();\r\n                        return [2 /*return*/, results];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SsdMobilenetv1.prototype.getDefaultModelName = function () {\r\n        return 'ssd_mobilenetv1_model';\r\n    };\r\n    SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {\r\n        return extractParamsFromWeigthMap(weightMap);\r\n    };\r\n    SsdMobilenetv1.prototype.extractParams = function (weights) {\r\n        return extractParams(weights);\r\n    };\r\n    return SsdMobilenetv1;\r\n}(NeuralNetwork));\r\nexport { SsdMobilenetv1 };\r\n//# sourceMappingURL=SsdMobilenetv1.js.map"]},"metadata":{},"sourceType":"module"}