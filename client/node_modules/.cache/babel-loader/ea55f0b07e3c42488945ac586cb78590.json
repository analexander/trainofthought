{"ast":null,"code":"'use strict'; // tar -x\n\nvar hlo = require('./high-level-opt.js');\n\nvar Unpack = require('./unpack.js');\n\nvar fs = require('fs');\n\nvar fsm = require('fs-minipass');\n\nvar path = require('path');\n\nvar x = module.exports = function (opt_, files, cb) {\n  if (typeof opt_ === 'function') cb = opt_, files = null, opt_ = {};else if (Array.isArray(opt_)) files = opt_, opt_ = {};\n  if (typeof files === 'function') cb = files, files = null;\n  if (!files) files = [];else files = Array.from(files);\n  var opt = hlo(opt_);\n  if (opt.sync && typeof cb === 'function') throw new TypeError('callback not supported for sync tar functions');\n  if (!opt.file && typeof cb === 'function') throw new TypeError('callback only supported with file option');\n  if (files.length) filesFilter(opt, files);\n  return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);\n}; // construct a filter that limits the file entries listed\n// include child entries if a dir is included\n\n\nvar filesFilter = function filesFilter(opt, files) {\n  var map = new Map(files.map(function (f) {\n    return [f.replace(/\\/+$/, ''), true];\n  }));\n  var filter = opt.filter;\n\n  var mapHas = function mapHas(file, r) {\n    var root = r || path.parse(file).root || '.';\n    var ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);\n    map.set(file, ret);\n    return ret;\n  };\n\n  opt.filter = filter ? function (file, entry) {\n    return filter(file, entry) && mapHas(file.replace(/\\/+$/, ''));\n  } : function (file) {\n    return mapHas(file.replace(/\\/+$/, ''));\n  };\n};\n\nvar extractFileSync = function extractFileSync(opt) {\n  var u = new Unpack.Sync(opt);\n  var file = opt.file;\n  var threw = true;\n  var fd;\n  var stat = fs.statSync(file); // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n\n  var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  var stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  });\n  stream.pipe(u);\n};\n\nvar extractFile = function extractFile(opt, cb) {\n  var u = new Unpack(opt);\n  var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  var file = opt.file;\n  var p = new Promise(function (resolve, reject) {\n    u.on('error', reject);\n    u.on('close', resolve); // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n\n    fs.stat(file, function (er, stat) {\n      if (er) reject(er);else {\n        var stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        });\n        stream.on('error', reject);\n        stream.pipe(u);\n      }\n    });\n  });\n  return cb ? p.then(cb, cb) : p;\n};\n\nvar extractSync = function extractSync(opt) {\n  return new Unpack.Sync(opt);\n};\n\nvar extract = function extract(opt) {\n  return new Unpack(opt);\n};","map":null,"metadata":{},"sourceType":"script"}