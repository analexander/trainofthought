{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Point } from '../classes';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { toNetInput } from '../dom';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { isEven } from '../utils';\n\nvar FaceLandmark68NetBase =\n/** @class */\nfunction (_super) {\n  __extends(FaceLandmark68NetBase, _super);\n\n  function FaceLandmark68NetBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {\n    var inputDimensions = originalDimensions.map(function (_a) {\n      var width = _a.width,\n          height = _a.height;\n      var scale = inputSize / Math.max(height, width);\n      return {\n        width: width * scale,\n        height: height * scale\n      };\n    });\n    var batchSize = inputDimensions.length;\n    return tf.tidy(function () {\n      var createInterleavedTensor = function createInterleavedTensor(fillX, fillY) {\n        return tf.stack([tf.fill([68], fillX), tf.fill([68], fillY)], 1).as2D(1, 136).as1D();\n      };\n\n      var getPadding = function getPadding(batchIdx, cond) {\n        var _a = inputDimensions[batchIdx],\n            width = _a.width,\n            height = _a.height;\n        return cond(width, height) ? Math.abs(width - height) / 2 : 0;\n      };\n\n      var getPaddingX = function getPaddingX(batchIdx) {\n        return getPadding(batchIdx, function (w, h) {\n          return w < h;\n        });\n      };\n\n      var getPaddingY = function getPaddingY(batchIdx) {\n        return getPadding(batchIdx, function (w, h) {\n          return h < w;\n        });\n      };\n\n      var landmarkTensors = output.mul(tf.fill([batchSize, 136], inputSize)).sub(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {\n        return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));\n      }))).div(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {\n        return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);\n      })));\n      return landmarkTensors;\n    });\n  };\n\n  FaceLandmark68NetBase.prototype.forwardInput = function (input) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var out = _this.runNet(input);\n\n      return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {\n        var height = _a[0],\n            width = _a[1];\n        return {\n          height: height,\n          width: width\n        };\n      }));\n    });\n  };\n\n  FaceLandmark68NetBase.prototype.forward = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var netInput, landmarkTensors, landmarksForBatch;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _a.sent();\n            landmarkTensors = tf.tidy(function () {\n              return tf.unstack(_this.forwardInput(netInput));\n            });\n            return [4\n            /*yield*/\n            , Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var landmarksArray, _a, _b, xCoords, yCoords;\n\n                return __generator(this, function (_c) {\n                  switch (_c.label) {\n                    case 0:\n                      _b = (_a = Array).from;\n                      return [4\n                      /*yield*/\n                      , landmarkTensor.data()];\n\n                    case 1:\n                      landmarksArray = _b.apply(_a, [_c.sent()]);\n                      xCoords = landmarksArray.filter(function (_, i) {\n                        return isEven(i);\n                      });\n                      yCoords = landmarksArray.filter(function (_, i) {\n                        return !isEven(i);\n                      });\n                      return [2\n                      /*return*/\n                      , new FaceLandmarks68(Array(68).fill(0).map(function (_, i) {\n                        return new Point(xCoords[i], yCoords[i]);\n                      }), {\n                        height: netInput.getInputHeight(batchIdx),\n                        width: netInput.getInputWidth(batchIdx)\n                      })];\n                  }\n                });\n              });\n            }))];\n\n          case 2:\n            landmarksForBatch = _a.sent();\n            landmarkTensors.forEach(function (t) {\n              return t.dispose();\n            });\n            return [2\n            /*return*/\n            , netInput.isBatchInput ? landmarksForBatch : landmarksForBatch[0]];\n        }\n      });\n    });\n  };\n\n  FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {\n    return 136;\n  };\n\n  return FaceLandmark68NetBase;\n}(FaceProcessor);\n\nexport { FaceLandmark68NetBase };","map":{"version":3,"sources":["../../../src/faceLandmarkNet/FaceLandmark68NetBase.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { Point } from '../classes';\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { toNetInput } from '../dom';\r\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\r\nimport { isEven } from '../utils';\r\nvar FaceLandmark68NetBase = /** @class */ (function (_super) {\r\n    __extends(FaceLandmark68NetBase, _super);\r\n    function FaceLandmark68NetBase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {\r\n        var inputDimensions = originalDimensions.map(function (_a) {\r\n            var width = _a.width, height = _a.height;\r\n            var scale = inputSize / Math.max(height, width);\r\n            return {\r\n                width: width * scale,\r\n                height: height * scale\r\n            };\r\n        });\r\n        var batchSize = inputDimensions.length;\r\n        return tf.tidy(function () {\r\n            var createInterleavedTensor = function (fillX, fillY) {\r\n                return tf.stack([\r\n                    tf.fill([68], fillX),\r\n                    tf.fill([68], fillY)\r\n                ], 1).as2D(1, 136).as1D();\r\n            };\r\n            var getPadding = function (batchIdx, cond) {\r\n                var _a = inputDimensions[batchIdx], width = _a.width, height = _a.height;\r\n                return cond(width, height) ? Math.abs(width - height) / 2 : 0;\r\n            };\r\n            var getPaddingX = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return w < h; }); };\r\n            var getPaddingY = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return h < w; }); };\r\n            var landmarkTensors = output\r\n                .mul(tf.fill([batchSize, 136], inputSize))\r\n                .sub(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {\r\n                return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));\r\n            })))\r\n                .div(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {\r\n                return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);\r\n            })));\r\n            return landmarkTensors;\r\n        });\r\n    };\r\n    FaceLandmark68NetBase.prototype.forwardInput = function (input) {\r\n        var _this = this;\r\n        return tf.tidy(function () {\r\n            var out = _this.runNet(input);\r\n            return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {\r\n                var height = _a[0], width = _a[1];\r\n                return ({ height: height, width: width });\r\n            }));\r\n        });\r\n    };\r\n    FaceLandmark68NetBase.prototype.forward = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var netInput, landmarkTensors, landmarksForBatch;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _a.sent();\r\n                        landmarkTensors = tf.tidy(function () { return tf.unstack(_this.forwardInput(netInput)); });\r\n                        return [4 /*yield*/, Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) { return __awaiter(_this, void 0, void 0, function () {\r\n                                var landmarksArray, _a, _b, xCoords, yCoords;\r\n                                return __generator(this, function (_c) {\r\n                                    switch (_c.label) {\r\n                                        case 0:\r\n                                            _b = (_a = Array).from;\r\n                                            return [4 /*yield*/, landmarkTensor.data()];\r\n                                        case 1:\r\n                                            landmarksArray = _b.apply(_a, [_c.sent()]);\r\n                                            xCoords = landmarksArray.filter(function (_, i) { return isEven(i); });\r\n                                            yCoords = landmarksArray.filter(function (_, i) { return !isEven(i); });\r\n                                            return [2 /*return*/, new FaceLandmarks68(Array(68).fill(0).map(function (_, i) { return new Point(xCoords[i], yCoords[i]); }), {\r\n                                                    height: netInput.getInputHeight(batchIdx),\r\n                                                    width: netInput.getInputWidth(batchIdx),\r\n                                                })];\r\n                                    }\r\n                                });\r\n                            }); }))];\r\n                    case 2:\r\n                        landmarksForBatch = _a.sent();\r\n                        landmarkTensors.forEach(function (t) { return t.dispose(); });\r\n                        return [2 /*return*/, netInput.isBatchInput\r\n                                ? landmarksForBatch\r\n                                : landmarksForBatch[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {\r\n        return 136;\r\n    };\r\n    return FaceLandmark68NetBase;\r\n}(FaceProcessor));\r\nexport { FaceLandmark68NetBase };\r\n//# sourceMappingURL=FaceLandmark68NetBase.js.map"]},"metadata":{},"sourceType":"module"}