{"ast":null,"code":"'use strict'; // Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar bundleWalk = require('npm-bundled');\n\nvar BundleWalker = bundleWalk.BundleWalker;\nvar BundleWalkerSync = bundleWalk.BundleWalkerSync;\n\nvar ignoreWalk = require('ignore-walk');\n\nvar IgnoreWalker = ignoreWalk.Walker;\nvar IgnoreWalkerSync = ignoreWalk.WalkerSync;\nvar rootBuiltinRules = Symbol('root-builtin-rules');\nvar packageNecessaryRules = Symbol('package-necessary-rules');\n\nvar path = require('path');\n\nvar normalizePackageBin = require('npm-normalize-package-bin');\n\nvar defaultRules = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '**/.DS_Store/**', '._*', '**/._*/**', '*.orig', '/package-lock.json', '/yarn.lock', 'archived-packages/**', 'core', '!core/', '!**/core/', '*.core', '*.vgcore', 'vgcore.*', 'core.+([0-9])']; // There may be others, but :?|<> are handled by node-tar\n\nvar nameIsBadForWindows = function nameIsBadForWindows(file) {\n  return /\\*/.test(file);\n}; // a decorator that applies our custom rules to an ignore walker\n\n\nvar npmWalker = function npmWalker(Class) {\n  return /*#__PURE__*/function (_Class) {\n    _inherits(Walker, _Class);\n\n    function Walker(opt) {\n      var _thisSuper, _this;\n\n      _classCallCheck(this, Walker);\n\n      opt = opt || {}; // the order in which rules are applied.\n\n      opt.ignoreFiles = [rootBuiltinRules, 'package.json', '.npmignore', '.gitignore', packageNecessaryRules];\n      opt.includeEmpty = false;\n      opt.path = opt.path || process.cwd();\n      var dirName = path.basename(opt.path);\n      var parentName = path.basename(path.dirname(opt.path));\n      opt.follow = dirName === 'node_modules' || parentName === 'node_modules' && /^@/.test(dirName);\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Walker).call(this, opt)); // ignore a bunch of things by default at the root level.\n      // also ignore anything in node_modules, except bundled dependencies\n\n      if (!_this.parent) {\n        _this.bundled = opt.bundled || [];\n        _this.bundledScopes = Array.from(new Set(_this.bundled.filter(function (f) {\n          return /^@/.test(f);\n        }).map(function (f) {\n          return f.split('/')[0];\n        })));\n        var rules = defaultRules.join('\\n') + '\\n';\n        _this.packageJsonCache = opt.packageJsonCache || new Map();\n\n        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Walker.prototype)), \"onReadIgnoreFile\", _thisSuper).call(_thisSuper, rootBuiltinRules, rules, function (_) {\n          return _;\n        });\n      } else {\n        _this.bundled = [];\n        _this.bundledScopes = [];\n        _this.packageJsonCache = _this.parent.packageJsonCache;\n      }\n\n      return _this;\n    }\n\n    _createClass(Walker, [{\n      key: \"onReaddir\",\n      value: function onReaddir(entries) {\n        var _this2 = this;\n\n        if (!this.parent) {\n          entries = entries.filter(function (e) {\n            return e !== '.git' && !(e === 'node_modules' && _this2.bundled.length === 0);\n          });\n        }\n\n        return _get(_getPrototypeOf(Walker.prototype), \"onReaddir\", this).call(this, entries);\n      }\n    }, {\n      key: \"filterEntry\",\n      value: function filterEntry(entry, partial) {\n        // get the partial path from the root of the walk\n        var p = this.path.substr(this.root.length + 1);\n        var pkgre = /^node_modules\\/(@[^\\/]+\\/?[^\\/]+|[^\\/]+)(\\/.*)?$/;\n        var isRoot = !this.parent;\n        var pkg = isRoot && pkgre.test(entry) ? entry.replace(pkgre, '$1') : null;\n        var rootNM = isRoot && entry === 'node_modules';\n        var rootPJ = isRoot && entry === 'package.json';\n        return (// if we're in a bundled package, check with the parent.\n          /^node_modules($|\\/)/i.test(p) ? this.parent.filterEntry(this.basename + '/' + entry, partial) // if package is bundled, all files included\n          // also include @scope dirs for bundled scoped deps\n          // they'll be ignored if no files end up in them.\n          // However, this only matters if we're in the root.\n          // node_modules folders elsewhere, like lib/node_modules,\n          // should be included normally unless ignored.\n          : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg) // only walk top node_modules if we want to bundle something\n          : rootNM ? !!this.bundled.length // always include package.json at the root.\n          : rootPJ ? true // otherwise, follow ignore-walk's logic\n          : _get(_getPrototypeOf(Walker.prototype), \"filterEntry\", this).call(this, entry, partial)\n        );\n      }\n    }, {\n      key: \"filterEntries\",\n      value: function filterEntries() {\n        if (this.ignoreRules['package.json']) this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null;else if (this.ignoreRules['.npmignore']) this.ignoreRules['.gitignore'] = null;\n        this.filterEntries = _get(_getPrototypeOf(Walker.prototype), \"filterEntries\", this);\n\n        _get(_getPrototypeOf(Walker.prototype), \"filterEntries\", this).call(this);\n      }\n    }, {\n      key: \"addIgnoreFile\",\n      value: function addIgnoreFile(file, then) {\n        var ig = path.resolve(this.path, file);\n        if (this.packageJsonCache.has(ig)) this.onPackageJson(ig, this.packageJsonCache.get(ig), then);else _get(_getPrototypeOf(Walker.prototype), \"addIgnoreFile\", this).call(this, file, then);\n      }\n    }, {\n      key: \"onPackageJson\",\n      value: function onPackageJson(ig, pkg, then) {\n        this.packageJsonCache.set(ig, pkg); // if there's a bin, browser or main, make sure we don't ignore it\n        // also, don't ignore the package.json itself!\n        //\n        // Weird side-effect of this: a readme (etc) file will be included\n        // if it exists anywhere within a folder with a package.json file.\n        // The original intent was only to include these files in the root,\n        // but now users in the wild are dependent on that behavior for\n        // localized documentation and other use cases.  Adding a `/` to\n        // these rules, while tempting and arguably more \"correct\", is a\n        // breaking change.\n\n        var rules = [pkg.browser ? '!' + pkg.browser : '', pkg.main ? '!' + pkg.main : '', '!package.json', '!npm-shrinkwrap.json', '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}'];\n\n        if (pkg.bin) {\n          // always an object, because normalized already\n          for (var key in pkg.bin) {\n            rules.push('!' + pkg.bin[key]);\n          }\n        }\n\n        var data = rules.filter(function (f) {\n          return f;\n        }).join('\\n') + '\\n';\n\n        _get(_getPrototypeOf(Walker.prototype), \"onReadIgnoreFile\", this).call(this, packageNecessaryRules, data, function (_) {\n          return _;\n        });\n\n        if (Array.isArray(pkg.files)) _get(_getPrototypeOf(Walker.prototype), \"onReadIgnoreFile\", this).call(this, 'package.json', '*\\n' + pkg.files.map(function (f) {\n          return '!' + f + '\\n!' + f.replace(/\\/+$/, '') + '/**';\n        }).join('\\n') + '\\n', then);else then();\n      } // override parent stat function to completely skip any filenames\n      // that will break windows entirely.\n      // XXX(isaacs) Next major version should make this an error instead.\n\n    }, {\n      key: \"stat\",\n      value: function stat(entry, file, dir, then) {\n        if (nameIsBadForWindows(entry)) then();else _get(_getPrototypeOf(Walker.prototype), \"stat\", this).call(this, entry, file, dir, then);\n      } // override parent onstat function to nix all symlinks\n\n    }, {\n      key: \"onstat\",\n      value: function onstat(st, entry, file, dir, then) {\n        if (st.isSymbolicLink()) then();else _get(_getPrototypeOf(Walker.prototype), \"onstat\", this).call(this, st, entry, file, dir, then);\n      }\n    }, {\n      key: \"onReadIgnoreFile\",\n      value: function onReadIgnoreFile(file, data, then) {\n        if (file === 'package.json') try {\n          var ig = path.resolve(this.path, file);\n          this.onPackageJson(ig, normalizePackageBin(JSON.parse(data)), then);\n        } catch (er) {\n          // ignore package.json files that are not json\n          then();\n        } else _get(_getPrototypeOf(Walker.prototype), \"onReadIgnoreFile\", this).call(this, file, data, then);\n      }\n    }, {\n      key: \"sort\",\n      value: function sort(a, b) {\n        return _sort(a, b);\n      }\n    }]);\n\n    return Walker;\n  }(Class);\n};\n\nvar Walker = /*#__PURE__*/function (_npmWalker) {\n  _inherits(Walker, _npmWalker);\n\n  function Walker() {\n    _classCallCheck(this, Walker);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Walker).apply(this, arguments));\n  }\n\n  _createClass(Walker, [{\n    key: \"walker\",\n    value: function walker(entry, then) {\n      new Walker(this.walkerOpt(entry)).on('done', then).start();\n    }\n  }]);\n\n  return Walker;\n}(npmWalker(IgnoreWalker));\n\nvar WalkerSync = /*#__PURE__*/function (_npmWalker2) {\n  _inherits(WalkerSync, _npmWalker2);\n\n  function WalkerSync() {\n    _classCallCheck(this, WalkerSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WalkerSync).apply(this, arguments));\n  }\n\n  _createClass(WalkerSync, [{\n    key: \"walker\",\n    value: function walker(entry, then) {\n      new WalkerSync(this.walkerOpt(entry)).start();\n      then();\n    }\n  }]);\n\n  return WalkerSync;\n}(npmWalker(IgnoreWalkerSync));\n\nvar walk = function walk(options, callback) {\n  options = options || {};\n  var p = new Promise(function (resolve, reject) {\n    var bw = new BundleWalker(options);\n    bw.on('done', function (bundled) {\n      options.bundled = bundled;\n      options.packageJsonCache = bw.packageJsonCache;\n      new Walker(options).on('done', resolve).on('error', reject).start();\n    });\n    bw.start();\n  });\n  return callback ? p.then(function (res) {\n    return callback(null, res);\n  }, callback) : p;\n};\n\nvar walkSync = function walkSync(options) {\n  options = options || {};\n  var bw = new BundleWalkerSync(options).start();\n  options.bundled = bw.result;\n  options.packageJsonCache = bw.packageJsonCache;\n  var walker = new WalkerSync(options);\n  walker.start();\n  return walker.result;\n}; // optimize for compressibility\n// extname, then basename, then locale alphabetically\n// https://twitter.com/isntitvacant/status/1131094910923231232\n\n\nvar _sort = function _sort(a, b) {\n  var exta = path.extname(a).toLowerCase();\n  var extb = path.extname(b).toLowerCase();\n  var basea = path.basename(a).toLowerCase();\n  var baseb = path.basename(b).toLowerCase();\n  return exta.localeCompare(extb) || basea.localeCompare(baseb) || a.localeCompare(b);\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":null,"metadata":{},"sourceType":"script"}