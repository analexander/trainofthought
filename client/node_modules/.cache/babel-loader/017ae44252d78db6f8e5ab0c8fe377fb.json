{"ast":null,"code":"'use strict'; // walk the tree of deps starting from the top level list of bundled deps\n// Any deps at the top level that are depended on by a bundled dep that\n// does not have that dep in its own node_modules folder are considered\n// bundled deps as well.  This list of names can be passed to npm-packlist\n// as the \"bundled\" argument.  Additionally, packageJsonCache is shared so\n// packlist doesn't have to re-read files already consumed in this pass\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar EE = require('events').EventEmitter; // we don't care about the package bins, but we share a pj cache\n// with other modules that DO care about it, so keep it nice.\n\n\nvar normalizePackageBin = require('npm-normalize-package-bin');\n\nvar BundleWalker = /*#__PURE__*/function (_EE) {\n  _inherits(BundleWalker, _EE);\n\n  function BundleWalker(opt) {\n    var _this;\n\n    _classCallCheck(this, BundleWalker);\n\n    opt = opt || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BundleWalker).call(this, opt));\n    _this.path = path.resolve(opt.path || process.cwd());\n    _this.parent = opt.parent || null;\n\n    if (_this.parent) {\n      _this.result = _this.parent.result; // only collect results in node_modules folders at the top level\n      // since the node_modules in a bundled dep is included always\n\n      if (!_this.parent.parent) {\n        var base = path.basename(_this.path);\n        var scope = path.basename(path.dirname(_this.path));\n\n        _this.result.add(/^@/.test(scope) ? scope + '/' + base : base);\n      }\n\n      _this.root = _this.parent.root;\n      _this.packageJsonCache = _this.parent.packageJsonCache;\n    } else {\n      _this.result = new Set();\n      _this.root = _this.path;\n      _this.packageJsonCache = opt.packageJsonCache || new Map();\n    }\n\n    _this.seen = new Set();\n    _this.didDone = false;\n    _this.children = 0;\n    _this.node_modules = [];\n    _this.package = null;\n    _this.bundle = null;\n    return _this;\n  }\n\n  _createClass(BundleWalker, [{\n    key: \"addListener\",\n    value: function addListener(ev, fn) {\n      return this.on(ev, fn);\n    }\n  }, {\n    key: \"on\",\n    value: function on(ev, fn) {\n      var ret = _get(_getPrototypeOf(BundleWalker.prototype), \"on\", this).call(this, ev, fn);\n\n      if (ev === 'done' && this.didDone) {\n        this.emit('done', this.result);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      if (!this.didDone) {\n        this.didDone = true;\n\n        if (!this.parent) {\n          var res = Array.from(this.result);\n          this.result = res;\n          this.emit('done', res);\n        } else {\n          this.emit('done');\n        }\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var pj = path.resolve(this.path, 'package.json');\n      if (this.packageJsonCache.has(pj)) this.onPackage(this.packageJsonCache.get(pj));else this.readPackageJson(pj);\n      return this;\n    }\n  }, {\n    key: \"readPackageJson\",\n    value: function readPackageJson(pj) {\n      var _this2 = this;\n\n      fs.readFile(pj, function (er, data) {\n        return er ? _this2.done() : _this2.onPackageJson(pj, data);\n      });\n    }\n  }, {\n    key: \"onPackageJson\",\n    value: function onPackageJson(pj, data) {\n      try {\n        this.package = normalizePackageBin(JSON.parse(data + ''));\n      } catch (er) {\n        return this.done();\n      }\n\n      this.packageJsonCache.set(pj, this.package);\n      this.onPackage(this.package);\n    }\n  }, {\n    key: \"allDepsBundled\",\n    value: function allDepsBundled(pkg) {\n      return Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {}));\n    }\n  }, {\n    key: \"onPackage\",\n    value: function onPackage(pkg) {\n      // all deps are bundled if we got here as a child.\n      // otherwise, only bundle bundledDeps\n      // Get a unique-ified array with a short-lived Set\n      var bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [];\n      var bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : bdRaw === true ? this.allDepsBundled(pkg) : Object.keys(bdRaw)));\n      if (!bd.length) return this.done();\n      this.bundle = bd;\n      var nm = this.path + '/node_modules';\n      this.readModules();\n    }\n  }, {\n    key: \"readModules\",\n    value: function readModules() {\n      var _this3 = this;\n\n      readdirNodeModules(this.path + '/node_modules', function (er, nm) {\n        return er ? _this3.onReaddir([]) : _this3.onReaddir(nm);\n      });\n    }\n  }, {\n    key: \"onReaddir\",\n    value: function onReaddir(nm) {\n      var _this4 = this;\n\n      // keep track of what we have, in case children need it\n      this.node_modules = nm;\n      this.bundle.forEach(function (dep) {\n        return _this4.childDep(dep);\n      });\n      if (this.children === 0) this.done();\n    }\n  }, {\n    key: \"childDep\",\n    value: function childDep(dep) {\n      if (this.node_modules.indexOf(dep) !== -1 && !this.seen.has(dep)) {\n        this.seen.add(dep);\n        this.child(dep);\n      } else if (this.parent) {\n        this.parent.childDep(dep);\n      }\n    }\n  }, {\n    key: \"child\",\n    value: function child(dep) {\n      var _this5 = this;\n\n      var p = this.path + '/node_modules/' + dep;\n      this.children += 1;\n      var child = new BundleWalker({\n        path: p,\n        parent: this\n      });\n      child.on('done', function (_) {\n        if (--_this5.children === 0) _this5.done();\n      });\n      child.start();\n    }\n  }]);\n\n  return BundleWalker;\n}(EE);\n\nvar BundleWalkerSync = /*#__PURE__*/function (_BundleWalker) {\n  _inherits(BundleWalkerSync, _BundleWalker);\n\n  function BundleWalkerSync(opt) {\n    _classCallCheck(this, BundleWalkerSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BundleWalkerSync).call(this, opt));\n  }\n\n  _createClass(BundleWalkerSync, [{\n    key: \"start\",\n    value: function start() {\n      _get(_getPrototypeOf(BundleWalkerSync.prototype), \"start\", this).call(this);\n\n      this.done();\n      return this;\n    }\n  }, {\n    key: \"readPackageJson\",\n    value: function readPackageJson(pj) {\n      try {\n        this.onPackageJson(pj, fs.readFileSync(pj));\n      } catch (er) {}\n\n      return this;\n    }\n  }, {\n    key: \"readModules\",\n    value: function readModules() {\n      try {\n        this.onReaddir(readdirNodeModulesSync(this.path + '/node_modules'));\n      } catch (er) {\n        this.onReaddir([]);\n      }\n    }\n  }, {\n    key: \"child\",\n    value: function child(dep) {\n      new BundleWalkerSync({\n        path: this.path + '/node_modules/' + dep,\n        parent: this\n      }).start();\n    }\n  }]);\n\n  return BundleWalkerSync;\n}(BundleWalker);\n\nvar readdirNodeModules = function readdirNodeModules(nm, cb) {\n  fs.readdir(nm, function (er, set) {\n    if (er) cb(er);else {\n      var scopes = set.filter(function (f) {\n        return /^@/.test(f);\n      });\n      if (!scopes.length) cb(null, set);else {\n        var unscoped = set.filter(function (f) {\n          return !/^@/.test(f);\n        });\n        var count = scopes.length;\n        scopes.forEach(function (scope) {\n          fs.readdir(nm + '/' + scope, function (er, pkgs) {\n            if (er || !pkgs.length) unscoped.push(scope);else unscoped.push.apply(unscoped, pkgs.map(function (p) {\n              return scope + '/' + p;\n            }));\n            if (--count === 0) cb(null, unscoped);\n          });\n        });\n      }\n    }\n  });\n};\n\nvar readdirNodeModulesSync = function readdirNodeModulesSync(nm) {\n  var set = fs.readdirSync(nm);\n  var unscoped = set.filter(function (f) {\n    return !/^@/.test(f);\n  });\n  var scopes = set.filter(function (f) {\n    return /^@/.test(f);\n  }).map(function (scope) {\n    try {\n      var pkgs = fs.readdirSync(nm + '/' + scope);\n      return pkgs.length ? pkgs.map(function (p) {\n        return scope + '/' + p;\n      }) : [scope];\n    } catch (er) {\n      return [scope];\n    }\n  }).reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n  return unscoped.concat(scopes);\n};\n\nvar walk = function walk(options, callback) {\n  var p = new Promise(function (resolve, reject) {\n    new BundleWalker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(function (res) {\n    return callback(null, res);\n  }, callback) : p;\n};\n\nvar walkSync = function walkSync(options) {\n  return new BundleWalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.BundleWalker = BundleWalker;\nwalk.BundleWalkerSync = BundleWalkerSync;","map":null,"metadata":{},"sourceType":"script"}