{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { toNetInput } from '../dom';\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { FaceExpressions } from './FaceExpressions';\n\nvar FaceExpressionNet =\n/** @class */\nfunction (_super) {\n  __extends(FaceExpressionNet, _super);\n\n  function FaceExpressionNet(faceFeatureExtractor) {\n    if (faceFeatureExtractor === void 0) {\n      faceFeatureExtractor = new FaceFeatureExtractor();\n    }\n\n    return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;\n  }\n\n  FaceExpressionNet.prototype.forwardInput = function (input) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tf.softmax(_this.runNet(input));\n    });\n  };\n\n  FaceExpressionNet.prototype.forward = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  FaceExpressionNet.prototype.predictExpressions = function (input) {\n    return __awaiter(this, void 0, void 0, function () {\n      var netInput, out, probabilitesByBatch, predictionsByBatch;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _a.sent();\n            return [4\n            /*yield*/\n            , this.forwardInput(netInput)];\n\n          case 2:\n            out = _a.sent();\n            return [4\n            /*yield*/\n            , Promise.all(tf.unstack(out).map(function (t) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var data;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , t.data()];\n\n                    case 1:\n                      data = _a.sent();\n                      t.dispose();\n                      return [2\n                      /*return*/\n                      , data];\n                  }\n                });\n              });\n            }))];\n\n          case 3:\n            probabilitesByBatch = _a.sent();\n            out.dispose();\n            predictionsByBatch = probabilitesByBatch.map(function (probabilites) {\n              return new FaceExpressions(probabilites);\n            });\n            return [2\n            /*return*/\n            , netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];\n        }\n      });\n    });\n  };\n\n  FaceExpressionNet.prototype.getDefaultModelName = function () {\n    return 'face_expression_model';\n  };\n\n  FaceExpressionNet.prototype.getClassifierChannelsIn = function () {\n    return 256;\n  };\n\n  FaceExpressionNet.prototype.getClassifierChannelsOut = function () {\n    return 7;\n  };\n\n  return FaceExpressionNet;\n}(FaceProcessor);\n\nexport { FaceExpressionNet };","map":{"version":3,"sources":["../../../src/faceExpressionNet/FaceExpressionNet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { toNetInput } from '../dom';\r\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\r\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\r\nimport { FaceExpressions } from './FaceExpressions';\r\nvar FaceExpressionNet = /** @class */ (function (_super) {\r\n    __extends(FaceExpressionNet, _super);\r\n    function FaceExpressionNet(faceFeatureExtractor) {\r\n        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new FaceFeatureExtractor(); }\r\n        return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;\r\n    }\r\n    FaceExpressionNet.prototype.forwardInput = function (input) {\r\n        var _this = this;\r\n        return tf.tidy(function () { return tf.softmax(_this.runNet(input)); });\r\n    };\r\n    FaceExpressionNet.prototype.forward = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceExpressionNet.prototype.predictExpressions = function (input) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var netInput, out, probabilitesByBatch, predictionsByBatch;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _a.sent();\r\n                        return [4 /*yield*/, this.forwardInput(netInput)];\r\n                    case 2:\r\n                        out = _a.sent();\r\n                        return [4 /*yield*/, Promise.all(tf.unstack(out).map(function (t) { return __awaiter(_this, void 0, void 0, function () {\r\n                                var data;\r\n                                return __generator(this, function (_a) {\r\n                                    switch (_a.label) {\r\n                                        case 0: return [4 /*yield*/, t.data()];\r\n                                        case 1:\r\n                                            data = _a.sent();\r\n                                            t.dispose();\r\n                                            return [2 /*return*/, data];\r\n                                    }\r\n                                });\r\n                            }); }))];\r\n                    case 3:\r\n                        probabilitesByBatch = _a.sent();\r\n                        out.dispose();\r\n                        predictionsByBatch = probabilitesByBatch\r\n                            .map(function (probabilites) { return new FaceExpressions(probabilites); });\r\n                        return [2 /*return*/, netInput.isBatchInput\r\n                                ? predictionsByBatch\r\n                                : predictionsByBatch[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceExpressionNet.prototype.getDefaultModelName = function () {\r\n        return 'face_expression_model';\r\n    };\r\n    FaceExpressionNet.prototype.getClassifierChannelsIn = function () {\r\n        return 256;\r\n    };\r\n    FaceExpressionNet.prototype.getClassifierChannelsOut = function () {\r\n        return 7;\r\n    };\r\n    return FaceExpressionNet;\r\n}(FaceProcessor));\r\nexport { FaceExpressionNet };\r\n//# sourceMappingURL=FaceExpressionNet.js.map"]},"metadata":{},"sourceType":"module"}