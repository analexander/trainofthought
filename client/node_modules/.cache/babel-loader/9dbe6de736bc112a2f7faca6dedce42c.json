{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\nimport { makeZerosTypedArray } from '../util';\nimport { tensor1d } from './tensor1d';\nimport { zeros } from './zeros';\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\n\nexport function range(start, stop) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var dtype = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'float32';\n\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  var forward = function forward() {\n    var sameStartStop = start === stop;\n    var increasingRangeNegativeStep = start < stop && step < 0;\n    var decreasingRangePositiveStep = stop < start && step > 1;\n\n    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n      return zeros([0], dtype);\n    }\n\n    var numElements = Math.abs(Math.ceil((stop - start) / step));\n    var values = makeZerosTypedArray(numElements, dtype);\n\n    if (stop < start && step === 1) {\n      // Auto adjust the step's sign if it hasn't been set\n      // (or was set to 1)\n      step = -1;\n    }\n\n    values[0] = start;\n\n    for (var i = 1; i < values.length; i++) {\n      values[i] = values[i - 1] + step;\n    }\n\n    return tensor1d(values, dtype);\n  };\n\n  var attrs = {\n    start: start,\n    stop: stop,\n    step: step,\n    dtype: dtype\n  };\n  return ENGINE.runKernelFunc(forward, {}\n  /* inputs */\n  , null\n  /* grad */\n  , Range, attrs);\n}","map":null,"metadata":{},"sourceType":"module"}