{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\n\nfunction inTopKAsync_(_x, _x2) {\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nfunction _inTopKAsync_() {\n  _inTopKAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(predictions, targets) {\n    var k,\n        $predictions,\n        $targets,\n        lastDim,\n        predictionsVals,\n        targetsVals,\n        batch,\n        size,\n        precision,\n        b,\n        offset,\n        vals,\n        valAndInd,\n        i,\n        _i,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            k = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;\n            $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n            $targets = convertToTensor(targets, 'targets', 'inTopK');\n            assert($predictions.rank > 1, function () {\n              return 'inTopK() expects the predictions to be of rank 2 or higher, ' + \"but got \".concat($predictions.rank);\n            });\n            assert($predictions.rank - 1 === $targets.rank, function () {\n              return \"predictions rank should be 1 larger than \" + \"targets rank, but got predictions rank \" + \"\".concat($predictions.rank, \" and targets rank \").concat($targets.rank);\n            });\n            assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, \"predictions's shape should be align with the targets' shape, \" + 'except the last dimension.');\n            lastDim = $predictions.shape[$predictions.shape.length - 1];\n            assert(k > 0 && k <= lastDim, function () {\n              return \"'k' passed to inTopK() must be > 0 && <= the predictions last \" + \"dimension (\".concat(lastDim, \"), but got \").concat(k);\n            });\n            _context.next = 10;\n            return $predictions.data();\n\n          case 10:\n            predictionsVals = _context.sent;\n            _context.next = 13;\n            return $targets.data();\n\n          case 13:\n            targetsVals = _context.sent;\n            // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n            // and look up topK along lastDim.\n            batch = predictionsVals.length / lastDim, size = lastDim;\n            precision = getTypedArrayFromDType('bool', batch);\n            b = 0;\n\n          case 17:\n            if (!(b < batch)) {\n              _context.next = 35;\n              break;\n            }\n\n            offset = b * size;\n            vals = predictionsVals.subarray(offset, offset + size);\n            valAndInd = [];\n\n            for (i = 0; i < vals.length; i++) {\n              valAndInd.push({\n                value: vals[i],\n                index: i\n              });\n            }\n\n            valAndInd.sort(function (a, b) {\n              return b.value - a.value;\n            });\n            precision[b] = 0;\n            _i = 0;\n\n          case 25:\n            if (!(_i < k)) {\n              _context.next = 32;\n              break;\n            }\n\n            if (!(valAndInd[_i].index === targetsVals[b])) {\n              _context.next = 29;\n              break;\n            }\n\n            precision[b] = 1;\n            return _context.abrupt(\"break\", 32);\n\n          case 29:\n            _i++;\n            _context.next = 25;\n            break;\n\n          case 32:\n            b++;\n            _context.next = 17;\n            break;\n\n          case 35:\n            if (predictions !== $predictions) {\n              $predictions.dispose();\n            }\n\n            if (targets !== $targets) {\n              $targets.dispose();\n            } // Output precision has the same shape as targets.\n\n\n            return _context.abrupt(\"return\", tensor(precision, $targets.shape, 'bool'));\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nexport var inTopKAsync = inTopKAsync_;","map":null,"metadata":{},"sourceType":"module"}