{"ast":null,"code":"/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error('tf.sparseToDense() expects the indices to be int32 type,' + \" but the dtype was \".concat(sparseIndices.dtype, \".\"));\n  }\n\n  if (sparseIndices.rank > 2) {\n    throw new Error('sparseIndices should be a scalar, vector, or matrix,' + \" but got shape \".concat(sparseIndices.shape, \".\"));\n  }\n\n  var numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  var numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error('outputShape has incorrect number of elements:,' + \" \".concat(outputShape.length, \", should be: \").concat(numDims, \".\"));\n  }\n\n  var numValues = sparseValues.size;\n\n  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error('sparseValues has incorrect shape ' + \"\".concat(sparseValues.shape, \", should be [] or [\").concat(numElems, \"]\"));\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}