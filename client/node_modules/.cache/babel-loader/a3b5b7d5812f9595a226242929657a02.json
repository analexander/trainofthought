{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { extractFaces, extractFaceTensors } from '../dom';\nimport { extendWithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { nets } from './nets';\nimport { PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask } from './PredictAgeAndGenderTask';\nimport { PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask } from './PredictFaceExpressionsTask';\n\nvar DetectFaceLandmarksTaskBase =\n/** @class */\nfunction (_super) {\n  __extends(DetectFaceLandmarksTaskBase, _super);\n\n  function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {\n    var _this = _super.call(this) || this;\n\n    _this.parentTask = parentTask;\n    _this.input = input;\n    _this.useTinyLandmarkNet = useTinyLandmarkNet;\n    return _this;\n  }\n\n  Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, \"landmarkNet\", {\n    get: function get() {\n      return this.useTinyLandmarkNet ? nets.faceLandmark68TinyNet : nets.faceLandmark68Net;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DetectFaceLandmarksTaskBase;\n}(ComposableTask);\n\nexport { DetectFaceLandmarksTaskBase };\n\nvar DetectAllFaceLandmarksTask =\n/** @class */\nfunction (_super) {\n  __extends(DetectAllFaceLandmarksTask, _super);\n\n  function DetectAllFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DetectAllFaceLandmarksTask.prototype.run = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var parentResults, detections, faces, _a, faceLandmarksByFace;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResults = _b.sent();\n            detections = parentResults.map(function (res) {\n              return res.detection;\n            });\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, detections)];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, detections)];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , Promise.all(faces.map(function (face) {\n              return _this.landmarkNet.detectLandmarks(face);\n            }))];\n\n          case 6:\n            faceLandmarksByFace = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , parentResults.map(function (parentResult, i) {\n              return extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i]);\n            })];\n        }\n      });\n    });\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\n  };\n\n  return DetectAllFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\n\nexport { DetectAllFaceLandmarksTask };\n\nvar DetectSingleFaceLandmarksTask =\n/** @class */\nfunction (_super) {\n  __extends(DetectSingleFaceLandmarksTask, _super);\n\n  function DetectSingleFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DetectSingleFaceLandmarksTask.prototype.run = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var parentResult, detection, faces, _a, landmarks;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResult = _b.sent();\n\n            if (!parentResult) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            detection = parentResult.detection;\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, [detection])];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, [detection])];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , this.landmarkNet.detectLandmarks(faces[0])];\n\n          case 6:\n            landmarks = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , extendWithFaceLandmarks(parentResult, landmarks)];\n        }\n      });\n    });\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\n  };\n\n  return DetectSingleFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\n\nexport { DetectSingleFaceLandmarksTask };","map":{"version":3,"sources":["../../../src/globalApi/DetectFaceLandmarksTasks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { extractFaces, extractFaceTensors } from '../dom';\r\nimport { extendWithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\r\nimport { nets } from './nets';\r\nimport { PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask, } from './PredictAgeAndGenderTask';\r\nimport { PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask, } from './PredictFaceExpressionsTask';\r\nvar DetectFaceLandmarksTaskBase = /** @class */ (function (_super) {\r\n    __extends(DetectFaceLandmarksTaskBase, _super);\r\n    function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {\r\n        var _this = _super.call(this) || this;\r\n        _this.parentTask = parentTask;\r\n        _this.input = input;\r\n        _this.useTinyLandmarkNet = useTinyLandmarkNet;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, \"landmarkNet\", {\r\n        get: function () {\r\n            return this.useTinyLandmarkNet\r\n                ? nets.faceLandmark68TinyNet\r\n                : nets.faceLandmark68Net;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DetectFaceLandmarksTaskBase;\r\n}(ComposableTask));\r\nexport { DetectFaceLandmarksTaskBase };\r\nvar DetectAllFaceLandmarksTask = /** @class */ (function (_super) {\r\n    __extends(DetectAllFaceLandmarksTask, _super);\r\n    function DetectAllFaceLandmarksTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DetectAllFaceLandmarksTask.prototype.run = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var parentResults, detections, faces, _a, faceLandmarksByFace;\r\n            var _this = this;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResults = _b.sent();\r\n                        detections = parentResults.map(function (res) { return res.detection; });\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, detections)];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, detections)];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        faces = _a;\r\n                        return [4 /*yield*/, Promise.all(faces.map(function (face) { return _this.landmarkNet.detectLandmarks(face); }))];\r\n                    case 6:\r\n                        faceLandmarksByFace = _b.sent();\r\n                        faces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, parentResults.map(function (parentResult, i) {\r\n                                return extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i]);\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {\r\n        return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n    };\r\n    DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {\r\n        return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n    };\r\n    DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {\r\n        return new ComputeAllFaceDescriptorsTask(this, this.input);\r\n    };\r\n    return DetectAllFaceLandmarksTask;\r\n}(DetectFaceLandmarksTaskBase));\r\nexport { DetectAllFaceLandmarksTask };\r\nvar DetectSingleFaceLandmarksTask = /** @class */ (function (_super) {\r\n    __extends(DetectSingleFaceLandmarksTask, _super);\r\n    function DetectSingleFaceLandmarksTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DetectSingleFaceLandmarksTask.prototype.run = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var parentResult, detection, faces, _a, landmarks;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResult = _b.sent();\r\n                        if (!parentResult) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        detection = parentResult.detection;\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, [detection])];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, [detection])];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        faces = _a;\r\n                        return [4 /*yield*/, this.landmarkNet.detectLandmarks(faces[0])];\r\n                    case 6:\r\n                        landmarks = _b.sent();\r\n                        faces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, extendWithFaceLandmarks(parentResult, landmarks)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {\r\n        return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n    };\r\n    DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {\r\n        return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n    };\r\n    DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {\r\n        return new ComputeSingleFaceDescriptorTask(this, this.input);\r\n    };\r\n    return DetectSingleFaceLandmarksTask;\r\n}(DetectFaceLandmarksTaskBase));\r\nexport { DetectSingleFaceLandmarksTask };\r\n//# sourceMappingURL=DetectFaceLandmarksTasks.js.map"]},"metadata":{},"sourceType":"module"}