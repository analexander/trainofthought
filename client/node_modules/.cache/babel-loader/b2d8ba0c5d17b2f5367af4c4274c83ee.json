{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, Multiply } from '@tensorflow/tfjs-core';\nimport * as binaryop_complex_gpu from '../binaryop_complex_gpu';\nimport { BinaryOpComplexProgram } from '../binaryop_complex_gpu';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { multiplyImplCPU as cpuMultiply } from '../kernel_utils/shared';\nimport { complex } from './Complex';\nvar MUL = 'return a * b;';\nexport function multiply(args) {\n  var inputs = args.inputs,\n      backend = args.backend;\n  var a = inputs.a,\n      b = inputs.b;\n  var dtype = backend_util.upcastType(a.dtype, b.dtype);\n\n  if (a.dtype === 'complex64') {\n    var aData = backend.texData.get(a.dataId);\n    var bData = backend.texData.get(b.dataId);\n    var realProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n    var imagProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n    var _inputs = [{\n      dataId: aData.complexTensorInfos.real.dataId,\n      dtype: aData.complexTensorInfos.real.dtype,\n      shape: a.shape\n    }, {\n      dataId: aData.complexTensorInfos.imag.dataId,\n      dtype: aData.complexTensorInfos.imag.dtype,\n      shape: a.shape\n    }, {\n      dataId: bData.complexTensorInfos.real.dataId,\n      dtype: bData.complexTensorInfos.real.dtype,\n      shape: b.shape\n    }, {\n      dataId: bData.complexTensorInfos.imag.dataId,\n      dtype: bData.complexTensorInfos.imag.dtype,\n      shape: b.shape\n    }];\n    var realPart = backend.runWebGLProgram(realProgram, _inputs, 'float32');\n    var imagPart = backend.runWebGLProgram(imagProgram, _inputs, 'float32');\n    var complexOutput = complex({\n      inputs: {\n        real: realPart,\n        imag: imagPart\n      },\n      backend: backend\n    });\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart); // TODO(annxingyuan): CPU forwarding for complex inputs.\n\n    return complexOutput;\n  }\n\n  if (backend.shouldExecuteOnCPU([a, b])) {\n    var _aData = backend.texData.get(a.dataId);\n\n    var _bData = backend.texData.get(b.dataId);\n\n    var _cpuMultiply = cpuMultiply(a.shape, b.shape, _aData.values, _bData.values, dtype),\n        _cpuMultiply2 = _slicedToArray(_cpuMultiply, 2),\n        outValues = _cpuMultiply2[0],\n        outShape = _cpuMultiply2[1];\n\n    var out = backend.makeTensorInfo(outShape, dtype);\n    var outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n    return out;\n  }\n\n  var program;\n\n  if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n    program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n  } else {\n    program = new BinaryOpProgram(MUL, a.shape, b.shape);\n  }\n\n  return backend.runWebGLProgram(program, [a, b], dtype);\n}\nexport var multiplyConfig = {\n  kernelName: Multiply,\n  backendName: 'webgl',\n  kernelFunc: multiply\n};","map":null,"metadata":{},"sourceType":"module"}