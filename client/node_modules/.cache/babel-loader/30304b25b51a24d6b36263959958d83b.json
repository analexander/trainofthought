{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nvar CODE_QUOTE = '\"';\nvar STATE_OUT = Symbol('out');\nvar STATE_FIELD = Symbol('field');\nvar STATE_QUOTE = Symbol('quote');\nvar STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nvar STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\n\nexport var CSVDataset = /*#__PURE__*/function (_Dataset) {\n  _inherits(CSVDataset, _Dataset);\n\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  function CSVDataset(input, csvConfig) {\n    var _this;\n\n    _classCallCheck(this, CSVDataset);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CSVDataset).call(this));\n    _this.input = input;\n    _this.hasHeader = true;\n    _this.fullColumnNames = null;\n    _this.columnNamesValidated = false;\n    _this.columnConfigs = null;\n    _this.configuredColumnsOnly = false;\n    _this.delimiter = ',';\n    _this.delimWhitespace = false;\n    _this.base = new TextLineDataset(input);\n\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n\n    _this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    _this.fullColumnNames = csvConfig.columnNames;\n    _this.columnConfigs = csvConfig.columnConfigs;\n    _this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n\n    if (csvConfig.delimWhitespace) {\n      util.assert(csvConfig.delimiter == null, function () {\n        return 'Delimiter should not be provided when delimWhitespace is true.';\n      });\n      _this.delimWhitespace = true;\n      _this.delimiter = ' ';\n    } else {\n      _this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n\n    return _this;\n  }\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n\n\n  _createClass(CSVDataset, [{\n    key: \"columnNames\",\n    value: function () {\n      var _columnNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.columnNamesValidated) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.setColumnNames();\n\n              case 3:\n                return _context.abrupt(\"return\", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function columnNames() {\n        return _columnNames.apply(this, arguments);\n      }\n\n      return columnNames;\n    }()\n    /* 1) If `columnNames` is provided as string[], use this string[] as output\n     * keys in corresponding order. The length must match the number of inferred\n     * columns if `hasHeader` is true .\n     * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n     * hasHeader is true. If `hasHeader` is false, throw an error.\n     * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n     * exist in parsed `columnNames`.\n     */\n\n  }, {\n    key: \"setColumnNames\",\n    value: function () {\n      var _setColumnNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var columnNamesFromFile, counts, duplicateNames, _i, _Object$keys, key, index;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.maybeReadHeaderLine();\n\n              case 2:\n                columnNamesFromFile = _context2.sent;\n\n                if (!(!this.fullColumnNames && !columnNamesFromFile)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error('Column names must be provided if there is no header line.');\n\n              case 7:\n                if (this.fullColumnNames && columnNamesFromFile) {\n                  // Check provided columnNames match header line.\n                  util.assert(columnNamesFromFile.length === this.fullColumnNames.length, function () {\n                    return 'The length of provided columnNames (' + _this2.fullColumnNames.length.toString() + ') does not match the length of the header line read from ' + 'file (' + columnNamesFromFile.length.toString() + ').';\n                  });\n                }\n\n              case 8:\n                if (!this.fullColumnNames) {\n                  this.fullColumnNames = columnNamesFromFile;\n                } // Check if there are duplicate column names.\n\n\n                counts = this.fullColumnNames.reduce(function (countAcc, name) {\n                  countAcc[name] = countAcc[name] + 1 || 1;\n                  return countAcc;\n                }, {});\n                duplicateNames = Object.keys(counts).filter(function (name) {\n                  return counts[name] > 1;\n                });\n                util.assert(duplicateNames.length === 0, function () {\n                  return 'Duplicate column names found: ' + duplicateNames.toString();\n                }); // Check if keys in columnConfigs match columnNames.\n\n                if (!this.columnConfigs) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                _i = 0, _Object$keys = Object.keys(this.columnConfigs);\n\n              case 14:\n                if (!(_i < _Object$keys.length)) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                key = _Object$keys[_i];\n                index = this.fullColumnNames.indexOf(key);\n\n                if (!(index === -1)) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                throw new Error('The key \"' + key + '\" provided in columnConfigs does not match any of the column ' + 'names (' + this.fullColumnNames.toString() + ').');\n\n              case 19:\n                _i++;\n                _context2.next = 14;\n                break;\n\n              case 22:\n                this.columnNamesValidated = true;\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function setColumnNames() {\n        return _setColumnNames.apply(this, arguments);\n      }\n\n      return setColumnNames;\n    }()\n  }, {\n    key: \"maybeReadHeaderLine\",\n    value: function () {\n      var _maybeReadHeaderLine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var iter, firstElement, firstLine, headers;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.hasHeader) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.base.iterator();\n\n              case 3:\n                iter = _context3.sent;\n                _context3.next = 6;\n                return iter.next();\n\n              case 6:\n                firstElement = _context3.sent;\n\n                if (!firstElement.done) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw new Error('No data was found for CSV parsing.');\n\n              case 9:\n                firstLine = firstElement.value;\n                headers = this.parseRow(firstLine, false);\n                return _context3.abrupt(\"return\", headers);\n\n              case 14:\n                return _context3.abrupt(\"return\", null);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function maybeReadHeaderLine() {\n        return _maybeReadHeaderLine.apply(this, arguments);\n      }\n\n      return maybeReadHeaderLine;\n    }()\n  }, {\n    key: \"iterator\",\n    value: function () {\n      var _iterator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this3 = this;\n\n        var lines;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.columnNamesValidated) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                _context4.next = 3;\n                return this.setColumnNames();\n\n              case 3:\n                _context4.next = 5;\n                return this.base.iterator();\n\n              case 5:\n                lines = _context4.sent;\n\n                if (this.hasHeader) {\n                  // We previously read the first line to get the columnNames.\n                  // Now that we're providing data, skip it.\n                  lines = lines.skip(1);\n                }\n\n                return _context4.abrupt(\"return\", lines.map(function (x) {\n                  return _this3.makeDataElement(x);\n                }));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function iterator() {\n        return _iterator.apply(this, arguments);\n      }\n\n      return iterator;\n    }()\n  }, {\n    key: \"makeDataElement\",\n    value: function makeDataElement(line) {\n      var values = this.parseRow(line);\n      var features = {};\n      var labels = {};\n\n      for (var i = 0; i < this.fullColumnNames.length; i++) {\n        var key = this.fullColumnNames[i];\n        var config = this.columnConfigs ? this.columnConfigs[key] : null;\n\n        if (this.configuredColumnsOnly && !config) {\n          // This column is not selected.\n          continue;\n        } else {\n          var value = values[i];\n          var parsedValue = null;\n\n          if (value === '') {\n            // If default value is provided, use it. If default value is not\n            // provided, set as undefined.\n            if (config && config.default !== undefined) {\n              parsedValue = config.default;\n            } else if (config && (config.required || config.isLabel)) {\n              throw new Error(\"Required column \".concat(key, \" is empty in this line: \").concat(line));\n            } else {\n              parsedValue = undefined;\n            }\n          } else {\n            // A value is present, so parse it based on type\n            var valueAsNum = Number(value);\n\n            if (isNaN(valueAsNum)) {\n              // The value is a string and this column is declared as boolean\n              // in config, parse it as boolean.\n              if (config && config.dtype === 'bool') {\n                parsedValue = this.getBoolean(value);\n              } else {\n                // Set value as string\n                parsedValue = value;\n              }\n            } else if (!config || !config.dtype) {\n              // If this value is a number and no type config is provided, return\n              // it as number.\n              parsedValue = valueAsNum;\n            } else {\n              // If this value is a number and data type is provided, parse it\n              // according to provided data type.\n              switch (config.dtype) {\n                case 'float32':\n                  parsedValue = valueAsNum;\n                  break;\n\n                case 'int32':\n                  parsedValue = Math.floor(valueAsNum);\n                  break;\n\n                case 'bool':\n                  parsedValue = this.getBoolean(value);\n                  break;\n\n                default:\n                  parsedValue = valueAsNum;\n              }\n            }\n          } // Check if this column is label.\n\n\n          config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;\n        }\n      } // If label exists, return an object of features and labels as {xs:features,\n      // ys:labels}, otherwise return features only.\n\n\n      if (Object.keys(labels).length === 0) {\n        return features;\n      } else {\n        return {\n          xs: features,\n          ys: labels\n        };\n      }\n    }\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean(value) {\n      if (value === '1' || value.toLowerCase() === 'true') {\n        return 1;\n      } else {\n        return 0;\n      }\n    } // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n\n  }, {\n    key: \"parseRow\",\n    value: function parseRow(line) {\n      var validateElementCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var result = [];\n      var readOffset = 0;\n      var readLength = line.length;\n      var currentState = STATE_OUT; // Goes through the line to parse quote.\n\n      for (var i = 0; i < readLength; i++) {\n        switch (currentState) {\n          // Before enter a new field\n          case STATE_OUT:\n            switch (line.charAt(i)) {\n              // Enter a quoted field\n              case CODE_QUOTE:\n                readOffset = i + 1;\n                currentState = STATE_QUOTE;\n                break;\n              // Read an empty field\n\n              case this.delimiter:\n                readOffset = i + 1; // If delimiter is white space and configured to collapse\n                // multiple white spaces, ignore this white space.\n\n                if (this.delimiter === ' ' && this.delimWhitespace) {\n                  break;\n                }\n\n                result.push('');\n                currentState = STATE_OUT;\n                break;\n              // Enter an unquoted field\n\n              default:\n                currentState = STATE_FIELD;\n                readOffset = i;\n                break;\n            }\n\n            break;\n          // In an unquoted field\n\n          case STATE_FIELD:\n            switch (line.charAt(i)) {\n              // Exit an unquoted field, add it to result\n              case this.delimiter:\n                result.push(line.substring(readOffset, i));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n\n              default:\n            }\n\n            break;\n          // In a quoted field\n\n          case STATE_QUOTE:\n            switch (line.charAt(i)) {\n              // Read a quote after a quote\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE_AFTER_QUOTE;\n                break;\n\n              default:\n            }\n\n            break;\n          // This state means it's right after a second quote in a field\n\n          case STATE_QUOTE_AFTER_QUOTE:\n            switch (line.charAt(i)) {\n              // Finished a quoted field\n              case this.delimiter:\n                result.push(line.substring(readOffset, i - 1));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n              // Finished a quoted part in a quoted field\n\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n              // In a quoted part in a quoted field\n\n              default:\n                currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                break;\n            }\n\n            break;\n\n          case STATE_WITHIN_QUOTE_IN_QUOTE:\n            switch (line.charAt(i)) {\n              // Exit a quoted part in a quoted field\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n\n              default:\n            }\n\n            break;\n\n          default:\n        }\n      } // Adds last item based on if it is quoted.\n\n\n      if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n        result.push(line.substring(readOffset, readLength - 1));\n      } else {\n        result.push(line.substring(readOffset));\n      } // Check if each row has the same number of elements as column names.\n\n\n      if (validateElementCount && result.length !== this.fullColumnNames.length) {\n        throw new Error(\"Invalid row in csv file. Should have \".concat(this.fullColumnNames.length, \" elements in a row, but got \").concat(result));\n      }\n\n      return result;\n    }\n  }]);\n\n  return CSVDataset;\n}(Dataset); // TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()","map":null,"metadata":{},"sourceType":"module"}