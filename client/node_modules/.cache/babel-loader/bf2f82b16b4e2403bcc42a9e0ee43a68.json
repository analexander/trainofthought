{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\n\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad) {\n  var dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NHWC';\n  var dilations = arguments.length > 5 ? arguments[5] : undefined;\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  var inputChannels = inputShape[3];\n  var $filterShape = [].concat(_toConsumableArray(filterShape), [inputChannels]);\n  var $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null\n  /* roundingMode */\n  , null\n  /* depthWise */\n  , $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n\n  var _parseTupleParam = parseTupleParam(filterSize),\n      _parseTupleParam2 = _slicedToArray(_parseTupleParam, 2),\n      filterHeight = _parseTupleParam2[0],\n      filterWidth = _parseTupleParam2[1];\n\n  var filterShape;\n\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\n\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'NDHWC';\n\n  var _parse3TupleParam = parse3TupleParam(filterSize),\n      _parse3TupleParam2 = _slicedToArray(_parse3TupleParam, 3),\n      filterDepth = _parse3TupleParam2[0],\n      filterHeight = _parse3TupleParam2[1],\n      filterWidth = _parse3TupleParam2[2];\n\n  var filterShape;\n  var $dataFormat;\n\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\n\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode) {\n  var depthwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var dataFormat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'channelsLast';\n  var batchSize = -1,\n      inHeight = -1,\n      inWidth = -1,\n      inChannels = -1;\n\n  if (dataFormat === 'channelsLast') {\n    var _inShape = _slicedToArray(inShape, 4);\n\n    batchSize = _inShape[0];\n    inHeight = _inShape[1];\n    inWidth = _inShape[2];\n    inChannels = _inShape[3];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape2 = _slicedToArray(inShape, 4);\n\n    batchSize = _inShape2[0];\n    inChannels = _inShape2[1];\n    inHeight = _inShape2[2];\n    inWidth = _inShape2[3];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  var _filterShape = _slicedToArray(filterShape, 4),\n      filterHeight = _filterShape[0],\n      filterWidth = _filterShape[1],\n      filterChannels = _filterShape[3];\n\n  var _parseTupleParam3 = parseTupleParam(strides),\n      _parseTupleParam4 = _slicedToArray(_parseTupleParam3, 2),\n      strideHeight = _parseTupleParam4[0],\n      strideWidth = _parseTupleParam4[1];\n\n  var _parseTupleParam5 = parseTupleParam(dilations),\n      _parseTupleParam6 = _slicedToArray(_parseTupleParam5, 2),\n      dilationHeight = _parseTupleParam6[0],\n      dilationWidth = _parseTupleParam6[1];\n\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n\n  var _getPadAndOutInfo = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat),\n      padInfo = _getPadAndOutInfo.padInfo,\n      outHeight = _getPadAndOutInfo.outHeight,\n      outWidth = _getPadAndOutInfo.outWidth;\n\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\n\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad) {\n  var depthwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  var roundingMode = arguments.length > 7 ? arguments[7] : undefined;\n  var batchSize = -1,\n      inDepth = -1,\n      inHeight = -1,\n      inWidth = -1,\n      inChannels = -1;\n\n  if (dataFormat === 'channelsLast') {\n    var _inShape3 = _slicedToArray(inShape, 5);\n\n    batchSize = _inShape3[0];\n    inDepth = _inShape3[1];\n    inHeight = _inShape3[2];\n    inWidth = _inShape3[3];\n    inChannels = _inShape3[4];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape4 = _slicedToArray(inShape, 5);\n\n    batchSize = _inShape4[0];\n    inChannels = _inShape4[1];\n    inDepth = _inShape4[2];\n    inHeight = _inShape4[3];\n    inWidth = _inShape4[4];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  var _filterShape2 = _slicedToArray(filterShape, 5),\n      filterDepth = _filterShape2[0],\n      filterHeight = _filterShape2[1],\n      filterWidth = _filterShape2[2],\n      filterChannels = _filterShape2[4];\n\n  var _parse3TupleParam3 = parse3TupleParam(strides),\n      _parse3TupleParam4 = _slicedToArray(_parse3TupleParam3, 3),\n      strideDepth = _parse3TupleParam4[0],\n      strideHeight = _parse3TupleParam4[1],\n      strideWidth = _parse3TupleParam4[2];\n\n  var _parse3TupleParam5 = parse3TupleParam(dilations),\n      _parse3TupleParam6 = _slicedToArray(_parse3TupleParam5, 3),\n      dilationDepth = _parse3TupleParam6[0],\n      dilationHeight = _parse3TupleParam6[1],\n      dilationWidth = _parse3TupleParam6[2];\n\n  var effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n\n  var _get3DPadAndOutInfo = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode),\n      padInfo = _get3DPadAndOutInfo.padInfo,\n      outDepth = _get3DPadAndOutInfo.outDepth,\n      outHeight = _get3DPadAndOutInfo.outHeight,\n      outWidth = _get3DPadAndOutInfo.outWidth;\n\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inDepth: inDepth,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideDepth: strideDepth,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterDepth: filterDepth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterDepth: effectiveFilterDepth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationDepth: dilationDepth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  var inputRows = inShape[0];\n  var inputCols = inShape[1];\n  var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputRows), function () {\n    return \"The output # of rows (\".concat(outputRows, \") must be an integer. \") + \"Change the stride and/or zero pad parameters\";\n  });\n  var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputCols), function () {\n    return \"The output # of columns (\".concat(outputCols, \") must be an integer. \") + \"Change the stride and/or zero pad parameters\";\n  });\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  var inputDepth = inShape[0];\n  var inputRows = inShape[1];\n  var inputCols = inShape[2];\n  var outputDepths = conditionalRound((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputDepths), function () {\n    return \"The output # of depths (\".concat(outputDepths, \") must be an integer. \") + \"Change the stride and/or zero pad parameters\";\n  });\n  var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputRows), function () {\n    return \"The output # of rows (\".concat(outputRows, \") must be an integer. \") + \"Change the stride and/or zero pad parameters\";\n  });\n  var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputCols), function () {\n    return \"The output # of columns (\".concat(outputCols, \") must be an integer. \") + \"Change the stride and/or zero pad parameters\";\n  });\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(inputShape, fieldSize, stride) {\n  var dilation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n\n  return param;\n}\n\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\n\n\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  var padInfo;\n  var outHeight;\n  var outWidth;\n\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    var padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    var _top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n\n    var _bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n\n    var _left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n\n    var _right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n\n    var _padType = _top === 0 && _bottom === 0 && _left === 0 && _right === 0 ? 'VALID' : 'EXPLICIT';\n\n    padInfo = {\n      top: _top,\n      bottom: _bottom,\n      left: _left,\n      right: _right,\n      type: _padType\n    };\n    outHeight = conditionalRound((inHeight - filterHeight + _top + _bottom) / strideHeight + 1, roundingMode);\n    outWidth = conditionalRound((inWidth - filterWidth + _left + _right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n\n  return {\n    padInfo: padInfo,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  var padInfo;\n  var outDepth;\n  var outHeight;\n  var outWidth;\n\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    var front = Math.floor(padAlongDepth / 2);\n    var back = padAlongDepth - front;\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      front: front,\n      back: back,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n\n  return {\n    padInfo: padInfo,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode\n */\n\n\nfunction conditionalRound(value, roundingMode) {\n  if (!roundingMode) {\n    return value;\n  }\n\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n\n    case 'floor':\n      return Math.floor(value);\n\n    default:\n      throw new Error(\"Unknown roundingMode \".concat(roundingMode));\n  }\n}\n\nexport function tupleValuesAreOne(param) {\n  var _parseTupleParam7 = parseTupleParam(param),\n      _parseTupleParam8 = _slicedToArray(_parseTupleParam7, 3),\n      dimA = _parseTupleParam8[0],\n      dimB = _parseTupleParam8[1],\n      dimC = _parseTupleParam8[2];\n\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\n\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n}","map":null,"metadata":{},"sourceType":"module"}