{"ast":null,"code":"//////////////////////////////////////////\n// Needle -- HTTP Client for Node.js\n// Written by Tom√°s Pollak <tomas@forkhq.com>\n// (c) 2012-2020 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\nvar fs = require('fs'),\n    http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    stream = require('stream'),\n    debug = require('debug')('needle'),\n    stringify = require('./querystring').build,\n    multipart = require('./multipart'),\n    auth = require('./auth'),\n    cookies = require('./cookies'),\n    parsers = require('./parsers'),\n    decoder = require('./decoder'); //////////////////////////////////////////\n// variabilia\n\n\nvar version = require('../package.json').version;\n\nvar user_agent = 'Needle/' + version;\nuser_agent += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\nvar tls_options = 'agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity family'; // older versions of node (< 0.11.4) prevent the runtime from exiting\n// because of connections in keep-alive state. so if this is the case\n// we'll default new requests to set a Connection: close header.\n\nvar close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity; // see if we have Object.assign. otherwise fall back to util._extend\n\nvar extend = Object.assign ? Object.assign : require('util')._extend; // these are the status codes that Needle interprets as redirects.\n\nvar redirect_codes = [301, 302, 303, 307, 308]; //////////////////////////////////////////\n// decompressors for gzip/deflate/br bodies\n\nfunction bind_opts(fn, options) {\n  return fn.bind(null, options);\n}\n\nvar decompressors = {};\n\ntry {\n  var zlib = require('zlib'); // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)\n\n\n  var zlib_options = {\n    flush: zlib.Z_SYNC_FLUSH,\n    finishFlush: zlib.Z_SYNC_FLUSH\n  };\n  var br_options = {\n    flush: zlib.BROTLI_OPERATION_FLUSH,\n    finishFlush: zlib.BROTLI_OPERATION_FLUSH\n  };\n  decompressors['x-deflate'] = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['deflate'] = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['x-gzip'] = bind_opts(zlib.Gunzip, zlib_options);\n  decompressors['gzip'] = bind_opts(zlib.Gunzip, zlib_options);\n\n  if (typeof zlib.BrotliDecompress === 'function') {\n    decompressors['br'] = bind_opts(zlib.BrotliDecompress, br_options);\n  }\n} catch (e) {\n  /* zlib not available */\n} //////////////////////////////////////////\n// options and aliases\n\n\nvar defaults = {\n  // data\n  boundary: '--------------------NODENEEDLEHTTPCLIENT',\n  encoding: 'utf8',\n  parse_response: 'all',\n  // same as true. valid options: 'json', 'xml' or false/null\n  proxy: null,\n  // headers\n  headers: {},\n  accept: '*/*',\n  user_agent: user_agent,\n  // numbers\n  open_timeout: 10000,\n  response_timeout: 0,\n  read_timeout: 0,\n  follow_max: 0,\n  stream_length: -1,\n  // booleans\n  compressed: false,\n  decode_response: true,\n  parse_cookies: true,\n  follow_set_cookies: false,\n  follow_set_referer: false,\n  follow_keep_method: false,\n  follow_if_same_host: false,\n  follow_if_same_protocol: false,\n  follow_if_same_location: false\n};\nvar aliased = {\n  options: {\n    decode: 'decode_response',\n    parse: 'parse_response',\n    timeout: 'open_timeout',\n    follow: 'follow_max'\n  },\n  inverted: {}\n}; // only once, invert aliased keys so we can get passed options.\n\nObject.keys(aliased.options).map(function (k) {\n  var value = aliased.options[k];\n  aliased.inverted[value] = k;\n}); //////////////////////////////////////////\n// helpers\n\nfunction keys_by_type(type) {\n  return Object.keys(defaults).map(function (el) {\n    if (defaults[el] !== null && defaults[el].constructor == type) return el;\n  }).filter(function (el) {\n    return el;\n  });\n}\n\nfunction parse_content_type(header) {\n  if (!header || header === '') return {};\n  var found,\n      charset = 'utf8',\n      arr = header.split(';');\n  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/))) charset = found[1];\n  return {\n    type: arr[0],\n    charset: charset\n  };\n}\n\nfunction is_stream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction get_stream_length(stream, given_length, cb) {\n  if (given_length > 0) return cb(given_length);\n  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0) return cb(stream.end + 1 - (stream.start || 0));\n  fs.stat(stream.path, function (err, stat) {\n    cb(stat ? stat.size - (stream.start || 0) : null);\n  });\n} //////////////////////////////////////////\n// the main act\n\n\nfunction Needle(method, uri, data, options, callback) {\n  // if (!(this instanceof Needle)) {\n  //   return new Needle(method, uri, data, options, callback);\n  // }\n  if (typeof uri !== 'string') throw new TypeError('URL must be a string, not ' + uri);\n  this.method = method;\n  this.uri = uri;\n  this.data = data;\n\n  if (typeof options == 'function') {\n    this.callback = options;\n    this.options = {};\n  } else {\n    this.callback = callback;\n    this.options = options;\n  }\n}\n\nNeedle.prototype.setup = function (uri, options) {\n  function get_option(key, fallback) {\n    // if original is in options, return that value\n    if (typeof options[key] != 'undefined') return options[key]; // otherwise, return value from alias or fallback/undefined\n\n    return typeof options[aliased.inverted[key]] != 'undefined' ? options[aliased.inverted[key]] : fallback;\n  }\n\n  function check_value(expected, key) {\n    var value = get_option(key),\n        type = typeof value;\n    if (type != 'undefined' && type != expected) throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);\n    return type == expected ? value : defaults[key];\n  } //////////////////////////////////////////////////\n  // the basics\n\n\n  var config = {\n    http_opts: {\n      localAddress: get_option('localAddress', undefined)\n    },\n    // passed later to http.request() directly\n    headers: {},\n    output: options.output,\n    proxy: get_option('proxy', defaults.proxy),\n    parser: get_option('parse_response', defaults.parse_response),\n    encoding: options.encoding || (options.multipart ? 'binary' : defaults.encoding)\n  };\n  keys_by_type(Boolean).forEach(function (key) {\n    config[key] = check_value('boolean', key);\n  });\n  keys_by_type(Number).forEach(function (key) {\n    config[key] = check_value('number', key);\n  }); // populate http_opts with given TLS options\n\n  tls_options.split(' ').forEach(function (key) {\n    if (typeof options[key] != 'undefined') {\n      config.http_opts[key] = options[key];\n      if (typeof options.agent == 'undefined') config.http_opts.agent = false; // otherwise tls options are skipped\n    }\n  }); //////////////////////////////////////////////////\n  // headers, cookies\n\n  for (var key in defaults.headers) {\n    config.headers[key] = defaults.headers[key];\n  }\n\n  config.headers['accept'] = options.accept || defaults.accept;\n  config.headers['user-agent'] = options.user_agent || defaults.user_agent;\n  if (options.content_type) config.headers['content-type'] = options.content_type; // set connection header if opts.connection was passed, or if node < 0.11.4 (close)\n\n  if (options.connection || close_by_default) config.headers['connection'] = options.connection || 'close';\n  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined') config.headers['accept-encoding'] = decompressors['br'] ? 'gzip, deflate, br' : 'gzip, deflate';\n  if (options.cookies) config.headers['cookie'] = cookies.write(options.cookies); //////////////////////////////////////////////////\n  // basic/digest auth\n\n  if (uri.match(/[^\\/]@/)) {\n    // url contains user:pass@host, so parse it.\n    var parts = (url.parse(uri).auth || '').split(':');\n    options.username = parts[0];\n    options.password = parts[1];\n  }\n\n  if (options.username) {\n    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n      config.credentials = [options.username, options.password];\n    } else {\n      config.headers['authorization'] = auth.basic(options.username, options.password);\n    }\n  } // if proxy is present, set auth header from either url or proxy_user option.\n\n\n  if (config.proxy) {\n    if (config.proxy.indexOf('http') === -1) config.proxy = 'http://' + config.proxy;\n\n    if (config.proxy.indexOf('@') !== -1) {\n      var proxy = (url.parse(config.proxy).auth || '').split(':');\n      options.proxy_user = proxy[0];\n      options.proxy_pass = proxy[1];\n    }\n\n    if (options.proxy_user) config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);\n  } // now that all our headers are set, overwrite them if instructed.\n\n\n  for (var h in options.headers) {\n    config.headers[h.toLowerCase()] = options.headers[h];\n  }\n\n  config.uri_modifier = get_option('uri_modifier', null);\n  return config;\n};\n\nNeedle.prototype.start = function () {\n  var out = new stream.PassThrough({\n    objectMode: false\n  }),\n      uri = this.uri,\n      data = this.data,\n      method = this.method,\n      callback = typeof this.options == 'function' ? this.options : this.callback,\n      options = this.options || {}; // if no 'http' is found on URL, prepend it.\n\n  if (uri.indexOf('http') === -1) uri = uri.replace(/^(\\/\\/)?/, 'http://');\n  var self = this,\n      body,\n      waiting = false,\n      config = this.setup(uri, options); // unless options.json was set to false, assume boss also wants JSON if content-type matches.\n\n  var json = options.json || options.json !== false && config.headers['content-type'] == 'application/json';\n\n  if (data) {\n    if (options.multipart) {\n      // boss says we do multipart. so we do it.\n      var boundary = options.boundary || defaults.boundary;\n      waiting = true;\n      multipart.build(data, boundary, function (err, parts) {\n        if (err) throw err;\n        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;\n        next(parts);\n      });\n    } else if (is_stream(data)) {\n      if (method.toUpperCase() == 'GET') throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');\n\n      if (config.stream_length > 0 || config.stream_length === 0 && data.path) {\n        // ok, let's get the stream's length and set it as the content-length header.\n        // this prevents some servers from cutting us off before all the data is sent.\n        waiting = true;\n        get_stream_length(data, config.stream_length, function (length) {\n          data.length = length;\n          next(data);\n        });\n      } else {\n        // if the boss doesn't want us to get the stream's length, or if it doesn't\n        // have a file descriptor for that purpose, then just head on.\n        body = data;\n      }\n    } else if (Buffer.isBuffer(data)) {\n      body = data; // use the raw buffer as request body.\n    } else if (method.toUpperCase() == 'GET' && !json) {\n      // append the data to the URI as a querystring.\n      uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n    } else {\n      // string or object data, no multipart.\n      // if string, leave it as it is, otherwise, stringify.\n      body = typeof data === 'string' ? data : json ? JSON.stringify(data) : stringify(data); // ensure we have a buffer so bytecount is correct.\n\n      body = Buffer.from(body, config.encoding);\n    }\n  }\n\n  function next(body) {\n    if (body) {\n      if (body.length) config.headers['content-length'] = body.length; // if no content-type was passed, determine if json or not.\n\n      if (!config.headers['content-type']) {\n        config.headers['content-type'] = json ? 'application/json; charset=utf-8' : 'application/x-www-form-urlencoded'; // no charset says W3 spec.\n      }\n    } // unless a specific accept header was set, assume json: true wants JSON back.\n\n\n    if (options.json && !options.accept && !(options.headers || {}).accept) config.headers['accept'] = 'application/json';\n    self.send_request(1, method, uri, config, body, out, callback);\n  }\n\n  if (!waiting) next(body);\n  return out;\n};\n\nNeedle.prototype.get_request_opts = function (method, uri, config) {\n  var opts = config.http_opts,\n      proxy = config.proxy,\n      remote = proxy ? url.parse(proxy) : url.parse(uri);\n  opts.protocol = remote.protocol;\n  opts.host = remote.hostname;\n  opts.port = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n  opts.path = proxy ? uri : remote.pathname + (remote.search || '');\n  opts.method = method;\n  opts.headers = config.headers;\n\n  if (!opts.headers['host']) {\n    // if using proxy, make sure the host header shows the final destination\n    var target = proxy ? url.parse(uri) : remote;\n    opts.headers['host'] = target.hostname; // and if a non standard port was passed, append it to the port header\n\n    if (target.port && [80, 443].indexOf(target.port) === -1) {\n      opts.headers['host'] += ':' + target.port;\n    }\n  }\n\n  return opts;\n};\n\nNeedle.prototype.should_follow = function (location, config, original) {\n  if (!location) return false; // returns true if location contains matching property (host or protocol)\n\n  function matches(property) {\n    var property = original[property];\n    return location.indexOf(property) !== -1;\n  } // first, check whether the requested location is actually different from the original\n\n\n  if (!config.follow_if_same_location && location === original) return false;\n  if (config.follow_if_same_host && !matches('host')) return false; // host does not match, so not following\n\n  if (config.follow_if_same_protocol && !matches('protocol')) return false; // procotol does not match, so not following\n\n  return true;\n};\n\nNeedle.prototype.send_request = function (count, method, uri, config, post_data, out, callback) {\n  if (typeof config.uri_modifier === 'function') {\n    var modified_uri = config.uri_modifier(uri);\n    debug('Modifying request URI', uri + ' => ' + modified_uri);\n    uri = modified_uri;\n  }\n\n  var timer,\n      returned = 0,\n      self = this,\n      request_opts = this.get_request_opts(method, uri, config),\n      protocol = request_opts.protocol == 'https:' ? https : http;\n\n  function done(err, resp) {\n    if (returned++ > 0) return debug('Already finished, stopping here.');\n    if (timer) clearTimeout(timer);\n    request.removeListener('error', had_error);\n    if (callback) return callback(err, resp, resp ? resp.body : undefined); // NOTE: this event used to be called 'end', but the behaviour was confusing\n    // when errors ocurred, because the stream would still emit an 'end' event.\n\n    out.emit('done', err);\n  }\n\n  function had_error(err) {\n    debug('Request error', err);\n    out.emit('err', err);\n    done(err || new Error('Unknown error when making request.'));\n  }\n\n  function set_timeout(type, milisecs) {\n    if (timer) clearTimeout(timer);\n    if (milisecs <= 0) return;\n    timer = setTimeout(function () {\n      out.emit('timeout', type);\n      request.abort(); // also invoke done() to terminate job on read_timeout\n\n      if (type == 'read') done(new Error(type + ' timeout'));\n    }, milisecs);\n  } // handle errors on the underlying socket, that may be closed while writing\n  // for an example case, see test/long_string_spec.js. we make sure this\n  // scenario ocurred by verifying the socket's writable & destroyed states.\n\n\n  function on_socket_end() {\n    if (returned && !this.writable && this.destroyed === false) {\n      this.destroy();\n      had_error(new Error('Remote end closed socket abruptly.'));\n    }\n  }\n\n  debug('Making request #' + count, request_opts);\n  var request = protocol.request(request_opts, function (resp) {\n    var headers = resp.headers;\n    debug('Got response', resp.statusCode, headers);\n    out.emit('response', resp);\n    set_timeout('read', config.read_timeout); // if we got cookies, parse them unless we were instructed not to. make sure to include any\n    // cookies that might have been set on previous redirects.\n\n    if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {\n      resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));\n      debug('Got cookies', resp.cookies);\n    } // if redirect code is found, determine if we should follow it according to the given options.\n\n\n    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {\n      // clear timer before following redirects to prevent unexpected setTimeout consequence\n      clearTimeout(timer);\n\n      if (count <= config.follow_max) {\n        out.emit('redirect', headers.location); // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.\n\n        if (!config.follow_keep_method) {\n          method = 'GET';\n          post_data = null;\n          delete config.headers['content-length']; // in case the original was a multipart POST request.\n        } // if follow_set_cookies is true, insert cookies in the next request's headers.\n        // we set both the original request cookies plus any response cookies we might have received.\n\n\n        if (config.follow_set_cookies) {\n          var request_cookies = cookies.read(config.headers['cookie']);\n          config.previous_resp_cookies = resp.cookies;\n\n          if (Object.keys(request_cookies).length || Object.keys(resp.cookies || {}).length) {\n            config.headers['cookie'] = cookies.write(extend(request_cookies, resp.cookies));\n          }\n        } else if (config.headers['cookie']) {\n          debug('Clearing original request cookie', config.headers['cookie']);\n          delete config.headers['cookie'];\n        }\n\n        if (config.follow_set_referer) config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.\n\n        config.headers['host'] = null; // clear previous Host header to avoid conflicts.\n\n        debug('Redirecting to ' + url.resolve(uri, headers.location));\n        return self.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);\n      } else if (config.follow_max > 0) {\n        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n      }\n    } // if auth is requested and credentials were not passed, resend request, provided we have user/pass.\n\n\n    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n      if (!config.headers['authorization']) {\n        // only if authentication hasn't been sent\n        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);\n\n        if (auth_header) {\n          config.headers['authorization'] = auth_header;\n          return self.send_request(count, method, uri, config, post_data, out, callback);\n        }\n      }\n    } // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.\n\n\n    out.emit('header', resp.statusCode, headers);\n    out.emit('headers', headers);\n    var pipeline = [],\n        mime = parse_content_type(headers['content-type']),\n        text_response = mime.type && mime.type.indexOf('text/') != -1; // To start, if our body is compressed and we're able to inflate it, do it.\n\n    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n      var decompressor = decompressors[headers['content-encoding']](); // make sure we catch errors triggered by the decompressor.\n\n      decompressor.on('error', had_error);\n      pipeline.push(decompressor);\n    } // If parse is enabled and we have a parser for it, then go for it.\n\n\n    if (config.parser && parsers[mime.type]) {\n      // If a specific parser was requested, make sure we don't parse other types.\n      var parser_name = config.parser.toString().toLowerCase();\n\n      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {\n        // OK, so either we're parsing all content types or the one requested matches.\n        out.parser = parsers[mime.type].name;\n        pipeline.push(parsers[mime.type].fn()); // Set objectMode on out stream to improve performance.\n\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true;\n      } // If we're not parsing, and unless decoding was disabled, we'll try\n      // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n\n    } else if (text_response && config.decode_response && mime.charset) {\n      pipeline.push(decoder(mime.charset));\n    } // And `out` is the stream we finally push the decoded/parsed output to.\n\n\n    pipeline.push(out); // Now, release the kraken!\n\n    var tmp = resp;\n\n    while (pipeline.length) {\n      tmp = tmp.pipe(pipeline.shift());\n    } // If the user has requested and output file, pipe the output stream to it.\n    // In stream mode, we will still get the response stream to play with.\n\n\n    if (config.output && resp.statusCode == 200) {\n      // for some reason, simply piping resp to the writable stream doesn't\n      // work all the time (stream gets cut in the middle with no warning).\n      // so we'll manually need to do the readable/write(chunk) trick.\n      var file = fs.createWriteStream(config.output);\n      file.on('error', had_error);\n      out.on('end', function () {\n        if (file.writable) file.end();\n      });\n      file.on('close', function () {\n        delete out.file;\n      });\n      out.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) !== null) {\n          if (file.writable) file.write(chunk); // if callback was requested, also push it to resp.body\n\n          if (resp.body) resp.body.push(chunk);\n        }\n      });\n      out.file = file;\n    } // Only aggregate the full body if a callback was requested.\n\n\n    if (callback) {\n      resp.raw = [];\n      resp.body = [];\n      resp.bytes = 0; // Gather and count the amount of (raw) bytes using a PassThrough stream.\n\n      var clean_pipe = new stream.PassThrough();\n      resp.pipe(clean_pipe);\n      clean_pipe.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) != null) {\n          resp.bytes += chunk.length;\n          resp.raw.push(chunk);\n        }\n      }); // Listen on the 'readable' event to aggregate the chunks, but only if\n      // file output wasn't requested. Otherwise we'd have two stream readers.\n\n      if (!config.output || resp.statusCode != 200) {\n        out.on('readable', function () {\n          var chunk;\n\n          while ((chunk = this.read()) !== null) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = Buffer.from(chunk); // Push all chunks to resp.body. We'll bind them in resp.end().\n\n            resp.body.push(chunk);\n          }\n        });\n      }\n    } // And set the .body property once all data is in.\n\n\n    out.on('end', function () {\n      if (resp.body) {\n        // callback mode\n        // we want to be able to access to the raw data later, so keep a reference.\n        resp.raw = Buffer.concat(resp.raw); // if parse was successful, we should have an array with one object\n\n        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {\n          // that's our body right there.\n          resp.body = resp.body[0]; // set the parser property on our response. we may want to check.\n\n          if (out.parser) resp.parser = out.parser;\n        } else {\n          // we got one or several buffers. string or binary.\n          resp.body = Buffer.concat(resp.body); // if we're here and parsed is true, it means we tried to but it didn't work.\n          // so given that we got a text response, let's stringify it.\n\n          if (text_response || out.parser) {\n            resp.body = resp.body.toString();\n          }\n        }\n      } // if an output file is being written to, make sure the callback\n      // is triggered after all data has been written to it.\n\n\n      if (out.file) {\n        out.file.on('close', function () {\n          done(null, resp, resp.body);\n        });\n      } else {\n        // elvis has left the building.\n        done(null, resp, resp.body);\n      }\n    });\n  }); // end request call\n  // unless open_timeout was disabled, set a timeout to abort the request.\n\n  set_timeout('open', config.open_timeout); // handle errors on the request object. things might get bumpy.\n\n  request.on('error', had_error); // make sure timer is cleared if request is aborted (issue #257)\n\n  request.once('abort', function () {\n    if (timer) clearTimeout(timer);\n  }); // handle socket 'end' event to ensure we don't get delayed EPIPE errors.\n\n  request.once('socket', function (socket) {\n    if (socket.connecting) {\n      socket.once('connect', function () {\n        set_timeout('response', config.response_timeout);\n      });\n    } else {\n      set_timeout('response', config.response_timeout);\n    } // console.log(socket);\n\n\n    if (!socket.on_socket_end) {\n      socket.on_socket_end = on_socket_end;\n      socket.once('end', function () {\n        process.nextTick(on_socket_end.bind(socket));\n      });\n    }\n  });\n\n  if (post_data) {\n    if (is_stream(post_data)) {\n      post_data.pipe(request);\n    } else {\n      request.write(post_data, config.encoding);\n      request.end();\n    }\n  } else {\n    request.end();\n  }\n\n  out.request = request;\n  return out;\n}; //////////////////////////////////////////\n// exports\n\n\nif (typeof Promise !== 'undefined') {\n  module.exports = function () {\n    var verb,\n        args = [].slice.call(arguments);\n    if (args[0].match(/\\.|\\//)) // first argument looks like a URL\n      verb = args.length > 2 ? 'post' : 'get';else verb = args.shift();\n    if (verb.match(/get|head/) && args.length == 2) args.splice(1, 0, null); // assume no data if head/get with two args (url, options)\n\n    return new Promise(function (resolve, reject) {\n      module.exports.request(verb, args[0], args[1], args[2], function (err, resp) {\n        return err ? reject(err) : resolve(resp);\n      });\n    });\n  };\n}\n\nmodule.exports.version = version;\n\nmodule.exports.defaults = function (obj) {\n  for (var key in obj) {\n    var target_key = aliased.options[key] || key;\n\n    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {\n      if (target_key != 'parse_response' && target_key != 'proxy') {\n        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string\n        var valid_type = defaults[target_key].constructor.name;\n        if (obj[key].constructor.name != valid_type) throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);\n      }\n\n      defaults[target_key] = obj[key];\n    } else {\n      throw new Error('Invalid property for defaults:' + target_key);\n    }\n  }\n\n  return defaults;\n};\n\n'head get'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, options, callback) {\n    return new Needle(method, uri, null, options, callback).start();\n  };\n});\n'post put patch delete'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, data, options, callback) {\n    return new Needle(method, uri, data, options, callback).start();\n  };\n});\n\nmodule.exports.request = function (method, uri, data, opts, callback) {\n  return new Needle(method, uri, data, opts, callback).start();\n};","map":null,"metadata":{},"sourceType":"script"}