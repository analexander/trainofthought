{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nvar DATABASE_NAME = 'tensorflowjs';\nvar DATABASE_VERSION = 1; // Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\n\nvar MODEL_STORE_NAME = 'models_store'; // 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\n\nvar INFO_STORE_NAME = 'model_info_store';\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\n\nexport function deleteDatabase() {\n  return _deleteDatabase.apply(this, arguments);\n}\n\nfunction _deleteDatabase() {\n  _deleteDatabase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var idbFactory;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            idbFactory = getIndexedDBFactory();\n            return _context5.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n\n              deleteRequest.onsuccess = function () {\n                return resolve();\n              };\n\n              deleteRequest.onerror = function (error) {\n                return reject(error);\n              };\n            }));\n\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _deleteDatabase.apply(this, arguments);\n}\n\nfunction getIndexedDBFactory() {\n  if (!env().getBool('IS_BROWSER')) {\n    // TODO(cais): Add more info about what IOHandler subtypes are available.\n    //   Maybe point to a doc page on the web and/or automatically determine\n    //   the available IOHandlers and print them in the error message.\n    throw new Error('Failed to obtain IndexedDB factory because the current environment' + 'is not a web browser.');\n  } // tslint:disable-next-line:no-any\n\n\n  var theWindow = typeof window === 'undefined' ? self : window;\n  var factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;\n\n  if (factory == null) {\n    throw new Error('The current browser does not appear to support IndexedDB.');\n  }\n\n  return factory;\n}\n\nfunction setUpDatabase(openRequest) {\n  var db = openRequest.result;\n  db.createObjectStore(MODEL_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n  db.createObjectStore(INFO_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n}\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\n\n\nexport var BrowserIndexedDB = /*#__PURE__*/function () {\n  function BrowserIndexedDB(modelPath) {\n    _classCallCheck(this, BrowserIndexedDB);\n\n    this.indexedDB = getIndexedDBFactory();\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');\n    }\n\n    this.modelPath = modelPath;\n  }\n\n  _createClass(BrowserIndexedDB, [{\n    key: \"save\",\n    value: function () {\n      var _save = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(modelArtifacts) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(modelArtifacts.modelTopology instanceof ArrayBuffer)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('BrowserLocalStorage.save() does not support saving model topology ' + 'in binary formats yet.');\n\n              case 2:\n                return _context.abrupt(\"return\", this.databaseAction(this.modelPath, modelArtifacts));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function save(_x) {\n        return _save.apply(this, arguments);\n      }\n\n      return save;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.databaseAction(this.modelPath));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n    /**\n     * Perform database action to put model artifacts into or read model artifacts\n     * from IndexedDB object store.\n     *\n     * Whether the action is put or get depends on whether `modelArtifacts` is\n     * specified. If it is specified, the action will be put; otherwise the action\n     * will be get.\n     *\n     * @param modelPath A unique string path for the model.\n     * @param modelArtifacts If specified, it will be the model artifacts to be\n     *   stored in IndexedDB.\n     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n     *   of `ModelArtifacts`, if the action is get.\n     */\n\n  }, {\n    key: \"databaseAction\",\n    value: function databaseAction(modelPath, modelArtifacts) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n        openRequest.onupgradeneeded = function () {\n          return setUpDatabase(openRequest);\n        };\n\n        openRequest.onsuccess = function () {\n          var db = openRequest.result;\n\n          if (modelArtifacts == null) {\n            // Read model out from object store.\n            var modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n            var modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n            var getRequest = modelStore.get(_this.modelPath);\n\n            getRequest.onsuccess = function () {\n              if (getRequest.result == null) {\n                db.close();\n                return reject(new Error(\"Cannot find model with path '\".concat(_this.modelPath, \"' \") + \"in IndexedDB.\"));\n              } else {\n                resolve(getRequest.result.modelArtifacts);\n              }\n            };\n\n            getRequest.onerror = function (error) {\n              db.close();\n              return reject(getRequest.error);\n            };\n\n            modelTx.oncomplete = function () {\n              return db.close();\n            };\n          } else {\n            // Put model into object store.\n            var modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts); // First, put ModelArtifactsInfo into info store.\n\n            var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n            var infoStore = infoTx.objectStore(INFO_STORE_NAME);\n            var putInfoRequest = infoStore.put({\n              modelPath: _this.modelPath,\n              modelArtifactsInfo: modelArtifactsInfo\n            });\n\n            var _modelTx;\n\n            putInfoRequest.onsuccess = function () {\n              // Second, put model data into model store.\n              _modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n\n              var modelStore = _modelTx.objectStore(MODEL_STORE_NAME);\n\n              var putModelRequest = modelStore.put({\n                modelPath: _this.modelPath,\n                modelArtifacts: modelArtifacts,\n                modelArtifactsInfo: modelArtifactsInfo\n              });\n\n              putModelRequest.onsuccess = function () {\n                return resolve({\n                  modelArtifactsInfo: modelArtifactsInfo\n                });\n              };\n\n              putModelRequest.onerror = function (error) {\n                // If the put-model request fails, roll back the info entry as\n                // well.\n                infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                var deleteInfoRequest = infoStore.delete(_this.modelPath);\n\n                deleteInfoRequest.onsuccess = function () {\n                  db.close();\n                  return reject(putModelRequest.error);\n                };\n\n                deleteInfoRequest.onerror = function (error) {\n                  db.close();\n                  return reject(putModelRequest.error);\n                };\n              };\n            };\n\n            putInfoRequest.onerror = function (error) {\n              db.close();\n              return reject(putInfoRequest.error);\n            };\n\n            infoTx.oncomplete = function () {\n              if (_modelTx == null) {\n                db.close();\n              } else {\n                _modelTx.oncomplete = function () {\n                  return db.close();\n                };\n              }\n            };\n          }\n        };\n\n        openRequest.onerror = function (error) {\n          return reject(openRequest.error);\n        };\n      });\n    }\n  }]);\n\n  return BrowserIndexedDB;\n}();\nBrowserIndexedDB.URL_SCHEME = 'indexeddb://';\nexport var indexedDBRouter = function indexedDBRouter(url) {\n  if (!env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\nIORouterRegistry.registerSaveRouter(indexedDBRouter);\nIORouterRegistry.registerLoadRouter(indexedDBRouter);\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\n\nexport function browserIndexedDB(modelPath) {\n  return new BrowserIndexedDB(modelPath);\n}\n\nfunction maybeStripScheme(key) {\n  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;\n}\n\nexport var BrowserIndexedDBManager = /*#__PURE__*/function () {\n  function BrowserIndexedDBManager() {\n    _classCallCheck(this, BrowserIndexedDBManager);\n\n    this.indexedDB = getIndexedDBFactory();\n  }\n\n  _createClass(BrowserIndexedDBManager, [{\n    key: \"listModels\",\n    value: function () {\n      var _listModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var openRequest = _this2.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n                  openRequest.onupgradeneeded = function () {\n                    return setUpDatabase(openRequest);\n                  };\n\n                  openRequest.onsuccess = function () {\n                    var db = openRequest.result;\n                    var tx = db.transaction(INFO_STORE_NAME, 'readonly');\n                    var store = tx.objectStore(INFO_STORE_NAME); // tslint:disable:max-line-length\n                    // Need to cast `store` as `any` here because TypeScript's DOM\n                    // library does not have the `getAll()` method even though the\n                    // method is supported in the latest version of most mainstream\n                    // browsers:\n                    // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    // tslint:enable:max-line-length\n                    // tslint:disable-next-line:no-any\n\n                    var getAllInfoRequest = store.getAll();\n\n                    getAllInfoRequest.onsuccess = function () {\n                      var out = {};\n\n                      var _iterator = _createForOfIteratorHelper(getAllInfoRequest.result),\n                          _step;\n\n                      try {\n                        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                          var item = _step.value;\n                          out[item.modelPath] = item.modelArtifactsInfo;\n                        }\n                      } catch (err) {\n                        _iterator.e(err);\n                      } finally {\n                        _iterator.f();\n                      }\n\n                      resolve(out);\n                    };\n\n                    getAllInfoRequest.onerror = function (error) {\n                      db.close();\n                      return reject(getAllInfoRequest.error);\n                    };\n\n                    tx.oncomplete = function () {\n                      return db.close();\n                    };\n                  };\n\n                  openRequest.onerror = function (error) {\n                    return reject(openRequest.error);\n                  };\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function listModels() {\n        return _listModels.apply(this, arguments);\n      }\n\n      return listModels;\n    }()\n  }, {\n    key: \"removeModel\",\n    value: function () {\n      var _removeModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                path = maybeStripScheme(path);\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var openRequest = _this3.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n                  openRequest.onupgradeneeded = function () {\n                    return setUpDatabase(openRequest);\n                  };\n\n                  openRequest.onsuccess = function () {\n                    var db = openRequest.result;\n                    var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n                    var infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                    var getInfoRequest = infoStore.get(path);\n                    var modelTx;\n\n                    getInfoRequest.onsuccess = function () {\n                      if (getInfoRequest.result == null) {\n                        db.close();\n                        return reject(new Error(\"Cannot find model with path '\".concat(path, \"' \") + \"in IndexedDB.\"));\n                      } else {\n                        // First, delete the entry in the info store.\n                        var deleteInfoRequest = infoStore.delete(path);\n\n                        var deleteModelData = function deleteModelData() {\n                          // Second, delete the entry in the model store.\n                          modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                          var modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                          var deleteModelRequest = modelStore.delete(path);\n\n                          deleteModelRequest.onsuccess = function () {\n                            return resolve(getInfoRequest.result.modelArtifactsInfo);\n                          };\n\n                          deleteModelRequest.onerror = function (error) {\n                            return reject(getInfoRequest.error);\n                          };\n                        }; // Proceed with deleting model data regardless of whether deletion\n                        // of info data succeeds or not.\n\n\n                        deleteInfoRequest.onsuccess = deleteModelData;\n\n                        deleteInfoRequest.onerror = function (error) {\n                          deleteModelData();\n                          db.close();\n                          return reject(getInfoRequest.error);\n                        };\n                      }\n                    };\n\n                    getInfoRequest.onerror = function (error) {\n                      db.close();\n                      return reject(getInfoRequest.error);\n                    };\n\n                    infoTx.oncomplete = function () {\n                      if (modelTx == null) {\n                        db.close();\n                      } else {\n                        modelTx.oncomplete = function () {\n                          return db.close();\n                        };\n                      }\n                    };\n                  };\n\n                  openRequest.onerror = function (error) {\n                    return reject(openRequest.error);\n                  };\n                }));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function removeModel(_x2) {\n        return _removeModel.apply(this, arguments);\n      }\n\n      return removeModel;\n    }()\n  }]);\n\n  return BrowserIndexedDBManager;\n}();","map":null,"metadata":{},"sourceType":"module"}