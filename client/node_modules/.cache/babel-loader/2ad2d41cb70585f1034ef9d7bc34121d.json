{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n * Returns true if the axis specifies the inner most dimensions of the\n * array.\n */\n\nexport function axesAreInnerMostDims(axes, rank) {\n  for (var i = 0; i < axes.length; ++i) {\n    if (axes[axes.length - i - 1] !== rank - 1 - i) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function combineLocations(outputLoc, reduceLoc, axes) {\n  var rank = outputLoc.length + reduceLoc.length;\n  var loc = [];\n  var outIdx = 0;\n  var reduceIdx = 0;\n\n  for (var dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      loc.push(outputLoc[outIdx++]);\n    } else {\n      loc.push(reduceLoc[reduceIdx++]);\n    }\n  }\n\n  return loc;\n}\nexport function computeOutAndReduceShapes(aShape, axes) {\n  var outShape = [];\n  var rank = aShape.length;\n\n  for (var dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      outShape.push(aShape[dim]);\n    }\n  }\n\n  var reduceShape = axes.map(function (dim) {\n    return aShape[dim];\n  });\n  return [outShape, reduceShape];\n}\nexport function expandShapeToKeepDim(shape, axes) {\n  var reduceSubShape = axes.map(function (x) {\n    return 1;\n  });\n  return combineLocations(shape, reduceSubShape, axes);\n}\nexport function assertAxesAreInnerMostDims(msg, axes, rank) {\n  util.assert(axesAreInnerMostDims(axes, rank), function () {\n    return \"\".concat(msg, \" supports only inner-most axes for now. \") + \"Got axes \".concat(axes, \" and rank-\").concat(rank, \" input.\");\n  });\n}\n/**\n * Returns the axes permutation to be used with `tf.transpose`, if such\n * permutation is necessary. Otherwise it returns null. This method is used by\n * operations that operate only on inner-most axes.\n */\n\nexport function getAxesPermutation(axes, rank) {\n  if (axesAreInnerMostDims(axes, rank)) {\n    return null;\n  }\n\n  var result = [];\n\n  for (var i = 0; i < rank; ++i) {\n    if (axes.indexOf(i) === -1) {\n      result.push(i);\n    }\n  }\n\n  axes.forEach(function (axis) {\n    return result.push(axis);\n  });\n  return result;\n}\n/** Returns the axes permutation that undoes the original permutation. */\n\nexport function getUndoAxesPermutation(axes) {\n  return axes.map(function (axis, i) {\n    return [i, axis];\n  }).sort(function (a, b) {\n    return a[1] - b[1];\n  }).map(function (x) {\n    return x[0];\n  });\n}\nexport function getInnerMostAxes(numAxes, rank) {\n  var res = [];\n\n  for (var i = rank - numAxes; i < rank; ++i) {\n    res.push(i);\n  }\n\n  return res;\n}","map":null,"metadata":{},"sourceType":"module"}