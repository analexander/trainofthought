{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var CropAndResizeProgram = function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {\n  _classCallCheck(this, CropAndResizeProgram);\n\n  this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n  this.outputShape = [];\n\n  var _imageShape = _slicedToArray(imageShape, 4),\n      batch = _imageShape[0],\n      imageHeight = _imageShape[1],\n      imageWidth = _imageShape[2],\n      depth = _imageShape[3];\n\n  var _boxShape = _slicedToArray(boxShape, 1),\n      numBoxes = _boxShape[0];\n\n  var _cropSize = _slicedToArray(cropSize, 2),\n      cropHeight = _cropSize[0],\n      cropWidth = _cropSize[1];\n\n  this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n  var methodId = method === 'bilinear' ? 1 : 0;\n  var inputHeightFloat = \"\".concat(imageHeight - 1, \".0\"),\n      inputWidthFloat = \"\".concat(imageWidth - 1, \".0\");\n\n  var _ref = cropHeight > 1 ? [\"\".concat((imageHeight - 1) / (cropHeight - 1)), '(y2-y1) * height_ratio', \"y1*\".concat(inputHeightFloat, \" + float(y)*(height_scale)\")] : ['0.0', '0.0', \"0.5 * (y1+y2) * \".concat(inputHeightFloat)],\n      _ref2 = _slicedToArray(_ref, 3),\n      heightRatio = _ref2[0],\n      heightScale = _ref2[1],\n      inY = _ref2[2];\n\n  var _ref3 = cropWidth > 1 ? [\"\".concat((imageWidth - 1) / (cropWidth - 1)), '(x2-x1) * width_ratio', \"x1*\".concat(inputWidthFloat, \" + float(x)*(width_scale)\")] : ['0.0', '0.0', \"0.5 * (x1+x2) * \".concat(inputWidthFloat)],\n      _ref4 = _slicedToArray(_ref3, 3),\n      widthRatio = _ref4[0],\n      widthScale = _ref4[1],\n      inX = _ref4[2]; // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n\n\n  this.userCode = \"\\n      const float height_ratio = float(\".concat(heightRatio, \");\\n      const float width_ratio = float(\").concat(widthRatio, \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \").concat(batch, \") {\\n          return;\\n        }\\n\\n        float height_scale = \").concat(heightScale, \";\\n        float width_scale = \").concat(widthScale, \";\\n\\n        float in_y = \").concat(inY, \";\\n        if( in_y < 0.0 || in_y > \").concat(inputHeightFloat, \" ) {\\n          setOutput(float(\").concat(extrapolationValue, \"));\\n          return;\\n        }\\n        float in_x = \").concat(inX, \";\\n        if( in_x < 0.0 || in_x > \").concat(inputWidthFloat, \" ) {\\n          setOutput(float(\").concat(extrapolationValue, \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\").concat(methodId, \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \");\n};","map":null,"metadata":{},"sourceType":"module"}