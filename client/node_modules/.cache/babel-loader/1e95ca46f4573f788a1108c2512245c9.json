{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\n\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(\"Cannot construct a complex64 tensor directly. \" + \"Please use tf.complex(real, imag).\");\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    var providedSize = sizeFromShape(shape);\n    var inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, function () {\n      return \"Based on the provided shape, [\".concat(shape, \"], the tensor should have \") + \"\".concat(providedSize, \" values but has \").concat(inferredSize);\n    });\n\n    for (var i = 0; i < inferredShape.length; ++i) {\n      var inferred = inferredShape[i];\n      var flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, function () {\n        return \"Error creating a new Tensor. Inferred shape \" + \"(\".concat(inferredShape, \") does not match the provided \") + \"shape (\".concat(shape, \"). \");\n      });\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":null,"metadata":{},"sourceType":"module"}