{"ast":null,"code":"import _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var SegmentOpProgram = function SegmentOpProgram(segOpInfo, segOpType) {\n  _classCallCheck(this, SegmentOpProgram);\n\n  this.variableNames = ['x', 'segmentIds'];\n  var windowSize = segOpInfo.windowSize;\n  var batchSize = segOpInfo.batchSize;\n  var inSize = segOpInfo.inSize;\n  var numSegments = segOpInfo.numSegments;\n  var outSize = numSegments * Math.ceil(inSize / windowSize);\n  this.outputShape = [batchSize, outSize];\n  var initializationValue = '0.0';\n  var returnValue = \"sumValue\";\n  var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n  var windowSizeVec4Remainder = windowSize % 4;\n  var updateSnippet = \"\\n        sumValue += dot(values, segFilter);\\n    \";\n  var checkValueOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkValueOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return initializationValue;\\n        }\\n      \");\n  }\n\n  var checkSegmentIdOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkSegmentIdOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return -1.0;\\n        }\\n      \");\n  }\n\n  this.userCode = \"\\n      const float initializationValue = \".concat(initializationValue, \";\\n\\n      float getValue(int batch, int inIdx) {\\n        \").concat(checkValueOutOfBounds, \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \").concat(checkSegmentIdOutOfBounds, \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \").concat(numSegments, \")) * float(\").concat(windowSize, \"));\\n        int currentSeg = int(mod(float(outIdx), float(\").concat(numSegments, \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \").concat(windowSizeNearestVec4, \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n\\n        int inIdx = inOffset + \").concat(windowSizeNearestVec4, \";\\n        if (\").concat(windowSizeVec4Remainder === 1, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 2, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 3, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n};","map":null,"metadata":{},"sourceType":"module"}