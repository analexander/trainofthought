{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tile } from '../kernel_names';\nimport { add } from '../ops/add';\nimport { slice } from '../ops/slice';\nimport { zerosLike } from '../ops/zeros_like';\nexport var tileGradConfig = {\n  kernelName: Tile,\n  inputsToSave: ['x'],\n  gradFunc: function gradFunc(dy, saved, attrs) {\n    var _saved = _slicedToArray(saved, 1),\n        x = _saved[0];\n\n    var reps = attrs.reps;\n\n    var derX = function derX() {\n      var xGrad = zerosLike(x); // TODO(cais): Maybe reduce memory footprint by avoiding repeated\n      // slicing.\n\n      if (x.rank === 1) {\n        for (var i = 0; i < reps[0]; ++i) {\n          xGrad = add(xGrad, slice(dy, [i * x.shape[0]], [x.shape[0]]));\n        }\n      } else if (x.rank === 2) {\n        for (var _i = 0; _i < reps[0]; ++_i) {\n          for (var j = 0; j < reps[1]; ++j) {\n            xGrad = add(xGrad, slice(dy, [_i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]));\n          }\n        }\n      } else if (x.rank === 3) {\n        for (var _i2 = 0; _i2 < reps[0]; ++_i2) {\n          for (var _j = 0; _j < reps[1]; ++_j) {\n            for (var k = 0; k < reps[2]; ++k) {\n              xGrad = add(xGrad, slice(dy, [_i2 * x.shape[0], _j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));\n            }\n          }\n        }\n      } else if (x.rank === 4) {\n        for (var _i3 = 0; _i3 < reps[0]; ++_i3) {\n          for (var _j2 = 0; _j2 < reps[1]; ++_j2) {\n            for (var _k = 0; _k < reps[2]; ++_k) {\n              for (var l = 0; l < reps[3]; ++l) {\n                xGrad = add(xGrad, slice(dy, [_i3 * x.shape[0], _j2 * x.shape[1], _k * x.shape[2], l * x.shape[3]], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));\n              }\n            }\n          }\n        }\n      } else {\n        throw new Error(\"Gradient for tile operation is not implemented for rank-\" + \"\".concat(x.rank, \" tensors yet.\"));\n      }\n\n      return xGrad;\n    };\n\n    return {\n      x: derX\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module"}