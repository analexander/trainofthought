{"ast":null,"code":"import { FaceMatch } from '../classes/FaceMatch';\nimport { LabeledFaceDescriptors } from '../classes/LabeledFaceDescriptors';\nimport { euclideanDistance } from '../euclideanDistance';\n\nvar FaceMatcher =\n/** @class */\nfunction () {\n  function FaceMatcher(inputs, distanceThreshold) {\n    if (distanceThreshold === void 0) {\n      distanceThreshold = 0.6;\n    }\n\n    this._distanceThreshold = distanceThreshold;\n    var inputArray = Array.isArray(inputs) ? inputs : [inputs];\n\n    if (!inputArray.length) {\n      throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");\n    }\n\n    var count = 1;\n\n    var createUniqueLabel = function createUniqueLabel() {\n      return \"person \" + count++;\n    };\n\n    this._labeledDescriptors = inputArray.map(function (desc) {\n      if (desc instanceof LabeledFaceDescriptors) {\n        return desc;\n      }\n\n      if (desc instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);\n      }\n\n      if (desc.descriptor && desc.descriptor instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\n      }\n\n      throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\");\n    });\n  }\n\n  Object.defineProperty(FaceMatcher.prototype, \"labeledDescriptors\", {\n    get: function get() {\n      return this._labeledDescriptors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceMatcher.prototype, \"distanceThreshold\", {\n    get: function get() {\n      return this._distanceThreshold;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {\n    return descriptors.map(function (d) {\n      return euclideanDistance(d, queryDescriptor);\n    }).reduce(function (d1, d2) {\n      return d1 + d2;\n    }, 0) / (descriptors.length || 1);\n  };\n\n  FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {\n    var _this = this;\n\n    return this.labeledDescriptors.map(function (_a) {\n      var descriptors = _a.descriptors,\n          label = _a.label;\n      return new FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));\n    }).reduce(function (best, curr) {\n      return best.distance < curr.distance ? best : curr;\n    });\n  };\n\n  FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {\n    var bestMatch = this.matchDescriptor(queryDescriptor);\n    return bestMatch.distance < this.distanceThreshold ? bestMatch : new FaceMatch('unknown', bestMatch.distance);\n  };\n\n  FaceMatcher.prototype.toJSON = function () {\n    return {\n      distanceThreshold: this.distanceThreshold,\n      labeledDescriptors: this.labeledDescriptors.map(function (ld) {\n        return ld.toJSON();\n      })\n    };\n  };\n\n  FaceMatcher.fromJSON = function (json) {\n    var labeledDescriptors = json.labeledDescriptors.map(function (ld) {\n      return LabeledFaceDescriptors.fromJSON(ld);\n    });\n    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\n  };\n\n  return FaceMatcher;\n}();\n\nexport { FaceMatcher };","map":{"version":3,"sources":["../../../src/globalApi/FaceMatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { FaceMatch } from '../classes/FaceMatch';\r\nimport { LabeledFaceDescriptors } from '../classes/LabeledFaceDescriptors';\r\nimport { euclideanDistance } from '../euclideanDistance';\r\nvar FaceMatcher = /** @class */ (function () {\r\n    function FaceMatcher(inputs, distanceThreshold) {\r\n        if (distanceThreshold === void 0) { distanceThreshold = 0.6; }\r\n        this._distanceThreshold = distanceThreshold;\r\n        var inputArray = Array.isArray(inputs) ? inputs : [inputs];\r\n        if (!inputArray.length) {\r\n            throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");\r\n        }\r\n        var count = 1;\r\n        var createUniqueLabel = function () { return \"person \" + count++; };\r\n        this._labeledDescriptors = inputArray.map(function (desc) {\r\n            if (desc instanceof LabeledFaceDescriptors) {\r\n                return desc;\r\n            }\r\n            if (desc instanceof Float32Array) {\r\n                return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);\r\n            }\r\n            if (desc.descriptor && desc.descriptor instanceof Float32Array) {\r\n                return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\r\n            }\r\n            throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\");\r\n        });\r\n    }\r\n    Object.defineProperty(FaceMatcher.prototype, \"labeledDescriptors\", {\r\n        get: function () { return this._labeledDescriptors; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceMatcher.prototype, \"distanceThreshold\", {\r\n        get: function () { return this._distanceThreshold; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {\r\n        return descriptors\r\n            .map(function (d) { return euclideanDistance(d, queryDescriptor); })\r\n            .reduce(function (d1, d2) { return d1 + d2; }, 0)\r\n            / (descriptors.length || 1);\r\n    };\r\n    FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {\r\n        var _this = this;\r\n        return this.labeledDescriptors\r\n            .map(function (_a) {\r\n            var descriptors = _a.descriptors, label = _a.label;\r\n            return new FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));\r\n        })\r\n            .reduce(function (best, curr) { return best.distance < curr.distance ? best : curr; });\r\n    };\r\n    FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {\r\n        var bestMatch = this.matchDescriptor(queryDescriptor);\r\n        return bestMatch.distance < this.distanceThreshold\r\n            ? bestMatch\r\n            : new FaceMatch('unknown', bestMatch.distance);\r\n    };\r\n    FaceMatcher.prototype.toJSON = function () {\r\n        return {\r\n            distanceThreshold: this.distanceThreshold,\r\n            labeledDescriptors: this.labeledDescriptors.map(function (ld) { return ld.toJSON(); })\r\n        };\r\n    };\r\n    FaceMatcher.fromJSON = function (json) {\r\n        var labeledDescriptors = json.labeledDescriptors\r\n            .map(function (ld) { return LabeledFaceDescriptors.fromJSON(ld); });\r\n        return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\r\n    };\r\n    return FaceMatcher;\r\n}());\r\nexport { FaceMatcher };\r\n//# sourceMappingURL=FaceMatcher.js.map"]},"metadata":{},"sourceType":"module"}