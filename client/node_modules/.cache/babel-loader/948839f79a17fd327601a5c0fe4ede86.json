{"ast":null,"code":"import _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\n\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  var usedNodes = new Set();\n  var missingInputs = [];\n  var dynamicNode = null;\n  var syncInputs = null; // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n\n  var seen = new Set();\n  var inputNodeNames = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  });\n  var initNodeNames = [];\n\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(function (node) {\n      return parseNodeName(node.name)[0];\n    });\n  }\n\n  var frontier = _toConsumableArray(outputs);\n\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(function (child) {\n          return child.name;\n        }).filter(function (name) {\n          return usedNodes.has(name);\n        });\n      }\n    }\n\n    usedNodes.add(node.name); // Weights are dead end since we already have their values.\n\n    if (weightMap[node.name] != null) {\n      continue;\n    } // This node is a dead end since it's one of the user-provided inputs.\n\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    } // This node is a dead end since it doesn't have any inputs.\n\n\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(function (input) {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    usedNodes: usedNodes,\n    missingInputs: missingInputs,\n    dynamicNode: dynamicNode,\n    syncInputs: syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\n\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  var usedNodes = executionInfo.usedNodes,\n      inputs = executionInfo.inputs;\n  var frontier = [];\n  var inputNodes = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  }).map(function (name) {\n    return graph.nodes[name];\n  });\n  var initNodes = graph.initNodes;\n  inputNodes.forEach(function (input) {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(function (weight) {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n\n  if (initNodes != null) {\n    initNodes.forEach(function (node) {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n\n  var seen = new Set();\n  var orderedNodes = [];\n\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(function (child) {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(function (input) {\n        return seen.has(input.name);\n      })) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nvar CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nvar DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nvar HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":null,"metadata":{},"sourceType":"module"}