{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n  if (real.length !== imag.length) {\n    throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + \"\".concat(real.length, \", imag: \").concat(imag.length, \".\"));\n  }\n\n  var result = new Float32Array(real.length * 2);\n\n  for (var i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n\n  return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\n\nexport function splitRealAndImagArrays(complex) {\n  var real = new Float32Array(complex.length / 2);\n  var imag = new Float32Array(complex.length / 2);\n\n  for (var i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n\n  return {\n    real: real,\n    imag: imag\n  };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithEvenIndex(complex) {\n  var len = Math.ceil(complex.length / 4);\n  var real = new Float32Array(len);\n  var imag = new Float32Array(len);\n\n  for (var i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real: real,\n    imag: imag\n  };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithOddIndex(complex) {\n  var len = Math.floor(complex.length / 4);\n  var real = new Float32Array(len);\n  var imag = new Float32Array(len);\n\n  for (var i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real: real,\n    imag: imag\n  };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\n\nexport function getComplexWithIndex(complex, index) {\n  var real = complex[index * 2];\n  var imag = complex[index * 2 + 1];\n  return {\n    real: real,\n    imag: imag\n  };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\n\nexport function assignToTypedArray(data, real, imag, index) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\n\nexport function exponents(n, inverse) {\n  var real = new Float32Array(n / 2);\n  var imag = new Float32Array(n / 2);\n\n  for (var i = 0; i < Math.ceil(n / 2); i++) {\n    var x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n\n  return {\n    real: real,\n    imag: imag\n  };\n}\n/**\n * Make the exponent term used by FFT.\n */\n\nexport function exponent(k, n, inverse) {\n  var x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  var real = Math.cos(x);\n  var imag = Math.sin(x);\n  return {\n    real: real,\n    imag: imag\n  };\n}","map":null,"metadata":{},"sourceType":"module"}