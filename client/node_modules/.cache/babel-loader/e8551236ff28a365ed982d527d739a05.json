{"ast":null,"code":"'use strict';\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _assertThisInitialized = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Buffer = require('./buffer.js');\n\nvar MiniPass = require('minipass');\n\nvar Pax = require('./pax.js');\n\nvar Header = require('./header.js');\n\nvar ReadEntry = require('./read-entry.js');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar types = require('./types.js');\n\nvar maxReadSize = 16 * 1024 * 1024;\nvar PROCESS = Symbol('process');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar HEADER = Symbol('header');\nvar READ = Symbol('read');\nvar LSTAT = Symbol('lstat');\nvar ONLSTAT = Symbol('onlstat');\nvar ONREAD = Symbol('onread');\nvar ONREADLINK = Symbol('onreadlink');\nvar OPENFILE = Symbol('openfile');\nvar ONOPENFILE = Symbol('onopenfile');\nvar CLOSE = Symbol('close');\nvar MODE = Symbol('mode');\n\nvar warner = require('./warn-mixin.js');\n\nvar winchars = require('./winchars.js');\n\nvar modeFix = require('./mode-fix.js');\n\nvar WriteEntry = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(WriteEntry, _MiniPass);\n\n  function WriteEntry(p, opt) {\n    var _this;\n\n    _classCallCheck(this, WriteEntry);\n\n    opt = opt || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntry).call(this, opt));\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    _this.path = p; // suppress atime, ctime, uid, gid, uname, gname\n\n    _this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    _this.myuid = process.getuid && process.getuid();\n    _this.myuser = process.env.USER || '';\n    _this.maxReadSize = opt.maxReadSize || maxReadSize;\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.preservePaths = !!opt.preservePaths;\n    _this.cwd = opt.cwd || process.cwd();\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n\n    if (!_this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      var parsed = path.win32.parse(p);\n\n      _this.warn('stripping ' + parsed.root + ' from absolute path', p);\n\n      _this.path = p.substr(parsed.root.length);\n    }\n\n    _this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (_this.win32) {\n      _this.path = winchars.decode(_this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    _this.absolute = opt.absolute || path.resolve(_this.cwd, p);\n    if (_this.path === '') _this.path = './';\n    if (_this.statCache.has(_this.absolute)) _this[ONLSTAT](_this.statCache.get(_this.absolute));else _this[LSTAT]();\n    return _this;\n  }\n\n  _createClass(WriteEntry, [{\n    key: LSTAT,\n    value: function value() {\n      var _this2 = this;\n\n      fs.lstat(this.absolute, function (er, stat) {\n        if (er) return _this2.emit('error', er);\n\n        _this2[ONLSTAT](stat);\n      });\n    }\n  }, {\n    key: ONLSTAT,\n    value: function value(stat) {\n      this.statCache.set(this.absolute, stat);\n      this.stat = stat;\n      if (!stat.isFile()) stat.size = 0;\n      this.type = getType(stat);\n      this.emit('stat', stat);\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      switch (this.type) {\n        case 'File':\n          return this[FILE]();\n\n        case 'Directory':\n          return this[DIRECTORY]();\n\n        case 'SymbolicLink':\n          return this[SYMLINK]();\n        // unsupported types are ignored.\n\n        default:\n          return this.end();\n      }\n    }\n  }, {\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory');\n    }\n  }, {\n    key: HEADER,\n    value: function value() {\n      if (this.type === 'Directory' && this.portable) this.noMtime = true;\n      this.header = new Header({\n        path: this.path,\n        linkpath: this.linkpath,\n        // only the permissions and setuid/setgid/sticky bitflags\n        // not the higher-order bits that specify file type\n        mode: this[MODE](this.stat.mode),\n        uid: this.portable ? null : this.stat.uid,\n        gid: this.portable ? null : this.stat.gid,\n        size: this.stat.size,\n        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n        type: this.type,\n        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n        atime: this.portable ? null : this.stat.atime,\n        ctime: this.portable ? null : this.stat.ctime\n      });\n      if (this.header.encode() && !this.noPax) this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode());\n      this.write(this.header.block);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value() {\n      if (this.path.substr(-1) !== '/') this.path += '/';\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      var _this3 = this;\n\n      fs.readlink(this.absolute, function (er, linkpath) {\n        if (er) return _this3.emit('error', er);\n\n        _this3[ONREADLINK](linkpath);\n      });\n    }\n  }, {\n    key: ONREADLINK,\n    value: function value(linkpath) {\n      this.linkpath = linkpath;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(linkpath) {\n      this.type = 'Link';\n      this.linkpath = path.relative(this.cwd, linkpath);\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: FILE,\n    value: function value() {\n      if (this.stat.nlink > 1) {\n        var linkKey = this.stat.dev + ':' + this.stat.ino;\n\n        if (this.linkCache.has(linkKey)) {\n          var linkpath = this.linkCache.get(linkKey);\n          if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n        }\n\n        this.linkCache.set(linkKey, this.absolute);\n      }\n\n      this[HEADER]();\n      if (this.stat.size === 0) return this.end();\n      this[OPENFILE]();\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      var _this4 = this;\n\n      fs.open(this.absolute, 'r', function (er, fd) {\n        if (er) return _this4.emit('error', er);\n\n        _this4[ONOPENFILE](fd);\n      });\n    }\n  }, {\n    key: ONOPENFILE,\n    value: function value(fd) {\n      var blockLen = 512 * Math.ceil(this.stat.size / 512);\n      var bufLen = Math.min(blockLen, this.maxReadSize);\n      var buf = Buffer.allocUnsafe(bufLen);\n      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);\n    }\n  }, {\n    key: READ,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {\n      var _this5 = this;\n\n      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {\n        if (er) return _this5[CLOSE](fd, function (_) {\n          return _this5.emit('error', er);\n        });\n\n        _this5[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n      });\n    }\n  }, {\n    key: CLOSE,\n    value: function value(fd, cb) {\n      fs.close(fd, cb);\n    }\n  }, {\n    key: ONREAD,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n      if (bytesRead <= 0 && remain > 0) {\n        var er = new Error('encountered unexpected EOF');\n        er.path = this.absolute;\n        er.syscall = 'read';\n        er.code = 'EOF';\n        this[CLOSE](fd, function (_) {\n          return _;\n        });\n        return this.emit('error', er);\n      }\n\n      if (bytesRead > remain) {\n        var _er = new Error('did not encounter expected EOF');\n\n        _er.path = this.absolute;\n        _er.syscall = 'read';\n        _er.code = 'EOF';\n        this[CLOSE](fd, function (_) {\n          return _;\n        });\n        return this.emit('error', _er);\n      } // null out the rest of the buffer, if we could fit the block padding\n\n\n      if (bytesRead === remain) {\n        for (var i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n          buf[i + offset] = 0;\n          bytesRead++;\n          remain++;\n        }\n      }\n\n      var writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);\n      remain -= bytesRead;\n      blockRemain -= bytesRead;\n      pos += bytesRead;\n      offset += bytesRead;\n      this.write(writeBuf);\n\n      if (!remain) {\n        if (blockRemain) this.write(Buffer.alloc(blockRemain));\n        this.end();\n        this[CLOSE](fd, function (_) {\n          return _;\n        });\n        return;\n      }\n\n      if (offset >= length) {\n        buf = Buffer.allocUnsafe(length);\n        offset = 0;\n      }\n\n      length = buf.length - offset;\n      this[READ](fd, buf, offset, length, pos, remain, blockRemain);\n    }\n  }]);\n\n  return WriteEntry;\n}(MiniPass));\n\nvar WriteEntrySync = /*#__PURE__*/function (_WriteEntry) {\n  _inherits(WriteEntrySync, _WriteEntry);\n\n  function WriteEntrySync(path, opt) {\n    _classCallCheck(this, WriteEntrySync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WriteEntrySync).call(this, path, opt));\n  }\n\n  _createClass(WriteEntrySync, [{\n    key: LSTAT,\n    value: function value() {\n      this[ONLSTAT](fs.lstatSync(this.absolute));\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      this[ONREADLINK](fs.readlinkSync(this.absolute));\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n    }\n  }, {\n    key: READ,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {\n      var threw = true;\n\n      try {\n        var bytesRead = fs.readSync(fd, buf, offset, length, pos);\n        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n        threw = false;\n      } finally {\n        if (threw) try {\n          this[CLOSE](fd);\n        } catch (er) {}\n      }\n    }\n  }, {\n    key: CLOSE,\n    value: function value(fd) {\n      fs.closeSync(fd);\n    }\n  }]);\n\n  return WriteEntrySync;\n}(WriteEntry);\n\nvar WriteEntryTar = warner( /*#__PURE__*/function (_MiniPass2) {\n  _inherits(WriteEntryTar, _MiniPass2);\n\n  function WriteEntryTar(readEntry, opt) {\n    var _thisSuper, _thisSuper2, _this6;\n\n    _classCallCheck(this, WriteEntryTar);\n\n    opt = opt || {};\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntryTar).call(this, opt));\n    _this6.preservePaths = !!opt.preservePaths;\n    _this6.portable = !!opt.portable;\n    _this6.strict = !!opt.strict;\n    _this6.noPax = !!opt.noPax;\n    _this6.noMtime = !!opt.noMtime;\n    _this6.readEntry = readEntry;\n    _this6.type = readEntry.type;\n    if (_this6.type === 'Directory' && _this6.portable) _this6.noMtime = true;\n    _this6.path = readEntry.path;\n    _this6.mode = _this6[MODE](readEntry.mode);\n    _this6.uid = _this6.portable ? null : readEntry.uid;\n    _this6.gid = _this6.portable ? null : readEntry.gid;\n    _this6.uname = _this6.portable ? null : readEntry.uname;\n    _this6.gname = _this6.portable ? null : readEntry.gname;\n    _this6.size = readEntry.size;\n    _this6.mtime = _this6.noMtime ? null : opt.mtime || readEntry.mtime;\n    _this6.atime = _this6.portable ? null : readEntry.atime;\n    _this6.ctime = _this6.portable ? null : readEntry.ctime;\n    _this6.linkpath = readEntry.linkpath;\n    if (typeof opt.onwarn === 'function') _this6.on('warn', opt.onwarn);\n\n    if (path.isAbsolute(_this6.path) && !_this6.preservePaths) {\n      var parsed = path.parse(_this6.path);\n\n      _this6.warn('stripping ' + parsed.root + ' from absolute path', _this6.path);\n\n      _this6.path = _this6.path.substr(parsed.root.length);\n    }\n\n    _this6.remain = readEntry.size;\n    _this6.blockRemain = readEntry.startBlockSize;\n    _this6.header = new Header({\n      path: _this6.path,\n      linkpath: _this6.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: _this6.mode,\n      uid: _this6.portable ? null : _this6.uid,\n      gid: _this6.portable ? null : _this6.gid,\n      size: _this6.size,\n      mtime: _this6.noMtime ? null : _this6.mtime,\n      type: _this6.type,\n      uname: _this6.portable ? null : _this6.uname,\n      atime: _this6.portable ? null : _this6.atime,\n      ctime: _this6.portable ? null : _this6.ctime\n    });\n    if (_this6.header.encode() && !_this6.noPax) _get((_thisSuper = _assertThisInitialized(_this6), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper).call(_thisSuper, new Pax({\n      atime: _this6.portable ? null : _this6.atime,\n      ctime: _this6.portable ? null : _this6.ctime,\n      gid: _this6.portable ? null : _this6.gid,\n      mtime: _this6.noMtime ? null : _this6.mtime,\n      path: _this6.path,\n      linkpath: _this6.linkpath,\n      size: _this6.size,\n      uid: _this6.portable ? null : _this6.uid,\n      uname: _this6.portable ? null : _this6.uname,\n      dev: _this6.portable ? null : _this6.readEntry.dev,\n      ino: _this6.portable ? null : _this6.readEntry.ino,\n      nlink: _this6.portable ? null : _this6.readEntry.nlink\n    }).encode());\n\n    _get((_thisSuper2 = _assertThisInitialized(_this6), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper2).call(_thisSuper2, _this6.header.block);\n\n    readEntry.pipe(_assertThisInitialized(_assertThisInitialized(_this6)));\n    return _this6;\n  }\n\n  _createClass(WriteEntryTar, [{\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory');\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n      this.blockRemain -= writeLen;\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"write\", this).call(this, data);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"end\", this).call(this);\n    }\n  }]);\n\n  return WriteEntryTar;\n}(MiniPass));\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nvar getType = function getType(stat) {\n  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n};\n\nmodule.exports = WriteEntry;","map":null,"metadata":{},"sourceType":"script"}