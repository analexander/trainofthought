{"ast":null,"code":"'use strict'; // parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Buffer = require('./buffer.js');\n\nvar types = require('./types.js');\n\nvar pathModule = require('path').posix;\n\nvar large = require('./large-numbers.js');\n\nvar SLURP = Symbol('slurp');\nvar TYPE = Symbol('type');\n\nvar Header = /*#__PURE__*/function () {\n  function Header(data, off, ex, gex) {\n    _classCallCheck(this, Header);\n\n    this.cksumValid = false;\n    this.needPax = false;\n    this.nullBlock = false;\n    this.block = null;\n    this.path = null;\n    this.mode = null;\n    this.uid = null;\n    this.gid = null;\n    this.size = null;\n    this.mtime = null;\n    this.cksum = null;\n    this[TYPE] = '0';\n    this.linkpath = null;\n    this.uname = null;\n    this.gname = null;\n    this.devmaj = 0;\n    this.devmin = 0;\n    this.atime = null;\n    this.ctime = null;\n    if (Buffer.isBuffer(data)) this.decode(data, off || 0, ex, gex);else if (data) this.set(data);\n  }\n\n  _createClass(Header, [{\n    key: \"decode\",\n    value: function decode(buf, off, ex, gex) {\n      if (!off) off = 0;\n      if (!buf || !(buf.length >= off + 512)) throw new Error('need 512 bytes for header');\n      this.path = decString(buf, off, 100);\n      this.mode = decNumber(buf, off + 100, 8);\n      this.uid = decNumber(buf, off + 108, 8);\n      this.gid = decNumber(buf, off + 116, 8);\n      this.size = decNumber(buf, off + 124, 12);\n      this.mtime = decDate(buf, off + 136, 12);\n      this.cksum = decNumber(buf, off + 148, 12); // if we have extended or global extended headers, apply them now\n      // See https://github.com/npm/node-tar/pull/187\n\n      this[SLURP](ex);\n      this[SLURP](gex, true); // old tar versions marked dirs as a file with a trailing /\n\n      this[TYPE] = decString(buf, off + 156, 1);\n      if (this[TYPE] === '') this[TYPE] = '0';\n      if (this[TYPE] === '0' && this.path.substr(-1) === '/') this[TYPE] = '5'; // tar implementations sometimes incorrectly put the stat(dir).size\n      // as the size in the tarball, even though Directory entries are\n      // not able to have any body at all.  In the very rare chance that\n      // it actually DOES have a body, we weren't going to do anything with\n      // it anyway, and it'll just be a warning about an invalid header.\n\n      if (this[TYPE] === '5') this.size = 0;\n      this.linkpath = decString(buf, off + 157, 100);\n\n      if (buf.slice(off + 257, off + 265).toString() === \"ustar\\x0000\") {\n        this.uname = decString(buf, off + 265, 32);\n        this.gname = decString(buf, off + 297, 32);\n        this.devmaj = decNumber(buf, off + 329, 8);\n        this.devmin = decNumber(buf, off + 337, 8);\n\n        if (buf[off + 475] !== 0) {\n          // definitely a prefix, definitely >130 chars.\n          var prefix = decString(buf, off + 345, 155);\n          this.path = prefix + '/' + this.path;\n        } else {\n          var _prefix = decString(buf, off + 345, 130);\n\n          if (_prefix) this.path = _prefix + '/' + this.path;\n          this.atime = decDate(buf, off + 476, 12);\n          this.ctime = decDate(buf, off + 488, 12);\n        }\n      }\n\n      var sum = 8 * 0x20;\n\n      for (var i = off; i < off + 148; i++) {\n        sum += buf[i];\n      }\n\n      for (var _i = off + 156; _i < off + 512; _i++) {\n        sum += buf[_i];\n      }\n\n      this.cksumValid = sum === this.cksum;\n      if (this.cksum === null && sum === 8 * 0x20) this.nullBlock = true;\n    }\n  }, {\n    key: SLURP,\n    value: function value(ex, global) {\n      for (var k in ex) {\n        // we slurp in everything except for the path attribute in\n        // a global extended header, because that's weird.\n        if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) this[k] = ex[k];\n      }\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(buf, off) {\n      if (!buf) {\n        buf = this.block = Buffer.alloc(512);\n        off = 0;\n      }\n\n      if (!off) off = 0;\n      if (!(buf.length >= off + 512)) throw new Error('need 512 bytes for header');\n      var prefixSize = this.ctime || this.atime ? 130 : 155;\n      var split = splitPrefix(this.path || '', prefixSize);\n      var path = split[0];\n      var prefix = split[1];\n      this.needPax = split[2];\n      this.needPax = encString(buf, off, 100, path) || this.needPax;\n      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;\n      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n      buf[off + 156] = this[TYPE].charCodeAt(0);\n      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n      buf.write(\"ustar\\x0000\", off + 257, 8);\n      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;\n      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;\n      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n      if (buf[off + 475] !== 0) this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;else {\n        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;\n        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;\n        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n      }\n      var sum = 8 * 0x20;\n\n      for (var i = off; i < off + 148; i++) {\n        sum += buf[i];\n      }\n\n      for (var _i2 = off + 156; _i2 < off + 512; _i2++) {\n        sum += buf[_i2];\n      }\n\n      this.cksum = sum;\n      encNumber(buf, off + 148, 8, this.cksum);\n      this.cksumValid = true;\n      return this.needPax;\n    }\n  }, {\n    key: \"set\",\n    value: function set(data) {\n      for (var i in data) {\n        if (data[i] !== null && data[i] !== undefined) this[i] = data[i];\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return types.name.get(this[TYPE]) || this[TYPE];\n    },\n    set: function set(type) {\n      if (types.code.has(type)) this[TYPE] = types.code.get(type);else this[TYPE] = type;\n    }\n  }, {\n    key: \"typeKey\",\n    get: function get() {\n      return this[TYPE];\n    }\n  }]);\n\n  return Header;\n}();\n\nvar splitPrefix = function splitPrefix(p, prefixSize) {\n  var pathSize = 100;\n  var pp = p;\n  var prefix = '';\n  var ret;\n  var root = pathModule.parse(p).root || '.';\n  if (Buffer.byteLength(pp) < pathSize) ret = [pp, prefix, false];else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp);\n    pp = pathModule.basename(pp);\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [pp, prefix, false]; // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [pp.substr(0, pathSize - 1), prefix, true];else {\n          // make path take a bit from prefix\n          pp = pathModule.join(pathModule.basename(prefix), pp);\n          prefix = pathModule.dirname(prefix);\n        }\n    } while (prefix !== root && !ret); // at this point, found no resolution, just truncate\n\n\n    if (!ret) ret = [p.substr(0, pathSize - 1), '', true];\n  }\n  return ret;\n};\n\nvar decString = function decString(buf, off, size) {\n  return buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '');\n};\n\nvar decDate = function decDate(buf, off, size) {\n  return numToDate(decNumber(buf, off, size));\n};\n\nvar numToDate = function numToDate(num) {\n  return num === null ? null : new Date(num * 1000);\n};\n\nvar decNumber = function decNumber(buf, off, size) {\n  return buf[off] & 0x80 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);\n};\n\nvar nanNull = function nanNull(value) {\n  return isNaN(value) ? null : value;\n};\n\nvar decSmallNumber = function decSmallNumber(buf, off, size) {\n  return nanNull(parseInt(buf.slice(off, off + size).toString('utf8').replace(/\\0.*$/, '').trim(), 8));\n}; // the maximum encodable as a null-terminated octal, by field size\n\n\nvar MAXNUM = {\n  12: 8589934591,\n  8: 2097151\n};\n\nvar encNumber = function encNumber(buf, off, size, number) {\n  return number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);\n};\n\nvar encSmallNumber = function encSmallNumber(buf, off, size, number) {\n  return buf.write(octalString(number, size), off, size, 'ascii');\n};\n\nvar octalString = function octalString(number, size) {\n  return padOctal(Math.floor(number).toString(8), size);\n};\n\nvar padOctal = function padOctal(string, size) {\n  return (string.length === size - 1 ? string : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0';\n};\n\nvar encDate = function encDate(buf, off, size, date) {\n  return date === null ? false : encNumber(buf, off, size, date.getTime() / 1000);\n}; // enough to fill the longest string we've got\n\n\nvar NULLS = new Array(156).join('\\0'); // pad with nulls, return true if it's longer or non-ascii\n\nvar encString = function encString(buf, off, size, string) {\n  return string === null ? false : (buf.write(string + NULLS, off, size, 'utf8'), string.length !== Buffer.byteLength(string) || string.length > size);\n};\n\nmodule.exports = Header;","map":null,"metadata":{},"sourceType":"script"}