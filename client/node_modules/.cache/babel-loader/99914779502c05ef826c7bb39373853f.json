{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { divConfig } from '../kernels/Div';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\n\nexport function fftBatch(input, inverse, cpuBackend) {\n  var inputShape = input.shape;\n  var batch = inputShape[0];\n  var innerDim = inputShape[1];\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var real2D = inputVals.complexTensorInfos.real;\n  var imag2D = inputVals.complexTensorInfos.imag; // Collects real and imaginary values separately.\n\n  var resultShape = [batch, innerDim];\n  var resultSize = util.sizeFromShape(resultShape);\n  var resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  var resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (var b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    var r = slice({\n      inputs: {\n        x: real2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    var i = slice({\n      inputs: {\n        x: imag2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n\n    var _input = complex({\n      inputs: {\n        real: r,\n        imag: i\n      },\n      backend: cpuBackend\n    }); // Run FFT by batch element.\n\n\n    var _fftImpl = fftImpl(_input, inverse, cpuBackend),\n        _real = _fftImpl.real,\n        _imag = _fftImpl.imag;\n\n    var res = backend_util.mergeRealAndImagArrays(_real, _imag);\n\n    for (var d = 0; d < innerDim; d++) {\n      var c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(_input);\n  }\n\n  var $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  var $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n  var result = complex({\n    inputs: {\n      real: $realInfo,\n      imag: $imagInfo\n    },\n    backend: cpuBackend\n  });\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n  return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n  var inputSize = util.sizeFromShape(input.shape);\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n  var imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n\n  if (isExponentOf2(inputSize)) {\n    var result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n    var resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      var realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      var imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n      var sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n      var sizeInfoCopy = identity({\n        inputs: {\n          x: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divRealInfo = divConfig.kernelFunc({\n        inputs: {\n          a: realInfo,\n          b: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divImagInfo = divConfig.kernelFunc({\n        inputs: {\n          a: imagInfo,\n          b: sizeInfoCopy\n        },\n        backend: cpuBackend\n      });\n      var divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n      var divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n      return {\n        real: divRealVals,\n        imag: divImagVals\n      };\n    }\n\n    return result;\n  } else {\n    var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    var rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size) {\n  return (size & size - 1) === 0;\n} // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n\n\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n  if (size === 1) {\n    return {\n      real: realVals,\n      imag: imagVals\n    };\n  }\n\n  var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n  var half = size / 2;\n  var evenComplex = backend_util.complexWithEvenIndex(data);\n  var evenRealVals = evenComplex.real;\n  var evenImagVals = evenComplex.imag;\n  var evenShape = [evenRealVals.length];\n  var evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  var evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n  var evenTensorInfo = complex({\n    inputs: {\n      real: evenRealInfo,\n      imag: evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var oddComplex = backend_util.complexWithOddIndex(data);\n  var oddRealVals = oddComplex.real;\n  var oddImagVals = oddComplex.imag;\n  var oddShape = [oddRealVals.length];\n  var oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  var oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n  var oddTensorInfo = complex({\n    inputs: {\n      real: oddRealInfo,\n      imag: oddImagInfo\n    },\n    backend: cpuBackend\n  }); // Recursive call for half part of original input.\n\n  var $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n  var $evenRealVals = $evenComplex.real;\n  var $evenImagVals = $evenComplex.imag;\n  var $evenShape = [$evenRealVals.length];\n  var $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  var $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n  var $evenTensorInfo = complex({\n    inputs: {\n      real: $evenRealInfo,\n      imag: $evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n  var $oddRealVals = $oddComplex.real;\n  var $oddImagVals = $oddComplex.imag;\n  var $oddShape = [$oddRealVals.length];\n  var $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  var $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n  var $oddTensorInfo = complex({\n    inputs: {\n      real: $oddRealInfo,\n      imag: $oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  var e = backend_util.exponents(size, inverse);\n  var eShape = [e.real.length];\n  var eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  var eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n  var complexInfo = complex({\n    inputs: {\n      real: eRealInfo,\n      imag: eImagInfo\n    },\n    backend: cpuBackend\n  });\n  var exponentInfo = multiply({\n    inputs: {\n      a: complexInfo,\n      b: $oddTensorInfo\n    },\n    backend: cpuBackend\n  });\n  var addPart = add({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var subPart = sub({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var addPartReal = real({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartReal = real({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var addPartImag = imag({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartImag = imag({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var $real = concat({\n    inputs: [addPartReal, subPartReal],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $imag = concat({\n    inputs: [addPartImag, subPartImag],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $realVals = cpuBackend.data.get($real.dataId).values;\n  var $imagVals = cpuBackend.data.get($imag.dataId).values;\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n  return {\n    real: $realVals,\n    imag: $imagVals\n  };\n} // Calculate fourier transform by multplying sinusoid matrix.\n\n\nfunction fourierTransformByMatmul(data, size, inverse) {\n  var ret = new Float32Array(size * 2); // TODO: Use matmul instead once it supports complex64 type.\n\n  for (var r = 0; r < size; r++) {\n    var _real2 = 0.0;\n    var _imag2 = 0.0;\n\n    for (var c = 0; c < size; c++) {\n      var e = backend_util.exponent(r * c, size, inverse);\n      var term = backend_util.getComplexWithIndex(data, c);\n      _real2 += term.real * e.real - term.imag * e.imag;\n      _imag2 += term.real * e.imag + term.imag * e.real;\n    }\n\n    if (inverse) {\n      _real2 /= size;\n      _imag2 /= size;\n    }\n\n    backend_util.assignToTypedArray(ret, _real2, _imag2, r);\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}