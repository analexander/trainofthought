{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  var initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  var output = buffer(convInfo.outShape, dtype);\n  var outputVals = output.values;\n  var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  var outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  var outputColStrides = convInfo.outShape[3];\n\n  for (var b = 0; b < convInfo.batchSize; ++b) {\n    var outputBatchOffset = b * outputBatchStrides;\n    var inputBatchOffset = b * strides[0];\n\n    for (var d = 0; d < convInfo.inChannels; ++d) {\n      for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n        var xRCorner = yR * strideHeight - padTop;\n        var xRMin = Math.max(0, xRCorner);\n        var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        var outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n\n        for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n          var xCCorner = yC * strideWidth - padLeft;\n          var xCMin = Math.max(0, xCCorner);\n          var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          var minMaxValue = initialValue;\n          var avgValue = 0;\n          var count = 0;\n\n          for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            var xROffset = inputBatchOffset + xR * strides[1];\n\n            for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              var xCOffset = xROffset + xC * strides[2];\n              var pixel = xValues[xCOffset + d];\n\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n\n          var outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo) {\n  var flattenPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var includeBatchInIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var maxPositions = buffer(convInfo.outShape, 'int32');\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  var xBuf = buffer(xShape, dtype, xValues);\n\n  for (var b = 0; b < convInfo.batchSize; ++b) {\n    for (var d = 0; d < convInfo.inChannels; ++d) {\n      for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n        var xRCorner = yR * strideHeight - padTop;\n        var xRMin = xRCorner;\n\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        } // const xRMin = Math.max(0, xRCorner);\n\n\n        var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n\n        for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n          var xCCorner = yC * strideWidth - padLeft;\n          var xCMin = xCCorner;\n\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n\n          var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          var maxValue = Number.NEGATIVE_INFINITY;\n          var maxPosition = -1;\n\n          for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            var wR = xR - xRCorner;\n\n            for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              var wC = xC - xCCorner;\n              var pixel = xBuf.get(b, xR, xC, d);\n\n              if (pixel > maxValue) {\n                maxValue = pixel;\n\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}","map":null,"metadata":{},"sourceType":"module"}