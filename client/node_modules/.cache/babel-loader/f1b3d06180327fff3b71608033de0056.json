{"ast":null,"code":"import { minBbox } from '../ops';\nimport { getCenterPoint } from '../utils';\nimport { Box } from './Box';\nimport { Dimensions } from './Dimensions';\nimport { FaceDetection } from './FaceDetection';\nimport { Point } from './Point';\nimport { Rect } from './Rect'; // face alignment constants\n\nvar relX = 0.5;\nvar relY = 0.43;\nvar relScale = 0.45;\n\nvar FaceLandmarks =\n/** @class */\nfunction () {\n  function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\n    if (shift === void 0) {\n      shift = new Point(0, 0);\n    }\n\n    var width = imgDims.width,\n        height = imgDims.height;\n    this._imgDims = new Dimensions(width, height);\n    this._shift = shift;\n    this._positions = relativeFaceLandmarkPositions.map(function (pt) {\n      return pt.mul(new Point(width, height)).add(shift);\n    });\n  }\n\n  Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\n    get: function get() {\n      return new Point(this._shift.x, this._shift.y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\n    get: function get() {\n      return this._imgDims.width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\n    get: function get() {\n      return this._imgDims.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\n    get: function get() {\n      return this._positions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\n    get: function get() {\n      var _this = this;\n\n      return this._positions.map(function (pt) {\n        return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight));\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FaceLandmarks.prototype.forSize = function (width, height) {\n    return new this.constructor(this.relativePositions, {\n      width: width,\n      height: height\n    });\n  };\n\n  FaceLandmarks.prototype.shiftBy = function (x, y) {\n    return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\n  };\n\n  FaceLandmarks.prototype.shiftByPoint = function (pt) {\n    return this.shiftBy(pt.x, pt.y);\n  };\n  /**\r\n   * Aligns the face landmarks after face detection from the relative positions of the faces\r\n   * bounding box, or it's current shift. This function should be used to align the face images\r\n   * after face detection has been performed, before they are passed to the face recognition net.\r\n   * This will make the computed face descriptor more accurate.\r\n   *\r\n   * @param detection (optional) The bounding box of the face or the face detection result. If\r\n   * no argument was passed the position of the face landmarks are assumed to be relative to\r\n   * it's current shift.\r\n   * @returns The bounding box of the aligned face.\r\n   */\n\n\n  FaceLandmarks.prototype.align = function (detection, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (detection) {\n      var box = detection instanceof FaceDetection ? detection.box.floor() : new Box(detection);\n      return this.shiftBy(box.x, box.y).align(null, options);\n    }\n\n    var _a = Object.assign({}, {\n      useDlibAlignment: false,\n      minBoxPadding: 0.2\n    }, options),\n        useDlibAlignment = _a.useDlibAlignment,\n        minBoxPadding = _a.minBoxPadding;\n\n    if (useDlibAlignment) {\n      return this.alignDlib();\n    }\n\n    return this.alignMinBbox(minBoxPadding);\n  };\n\n  FaceLandmarks.prototype.alignDlib = function () {\n    var centers = this.getRefPointsForAlignment();\n    var leftEyeCenter = centers[0],\n        rightEyeCenter = centers[1],\n        mouthCenter = centers[2];\n\n    var distToMouth = function distToMouth(pt) {\n      return mouthCenter.sub(pt).magnitude();\n    };\n\n    var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n    var size = Math.floor(eyeToMouthDist / relScale);\n    var refPoint = getCenterPoint(centers); // TODO: pad in case rectangle is out of image bounds\n\n    var x = Math.floor(Math.max(0, refPoint.x - relX * size));\n    var y = Math.floor(Math.max(0, refPoint.y - relY * size));\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n  };\n\n  FaceLandmarks.prototype.alignMinBbox = function (padding) {\n    var box = minBbox(this.positions);\n    return box.pad(box.width * padding, box.height * padding);\n  };\n\n  FaceLandmarks.prototype.getRefPointsForAlignment = function () {\n    throw new Error('getRefPointsForAlignment not implemented by base class');\n  };\n\n  return FaceLandmarks;\n}();\n\nexport { FaceLandmarks };","map":{"version":3,"sources":["../../../src/classes/FaceLandmarks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { minBbox } from '../ops';\r\nimport { getCenterPoint } from '../utils';\r\nimport { Box } from './Box';\r\nimport { Dimensions } from './Dimensions';\r\nimport { FaceDetection } from './FaceDetection';\r\nimport { Point } from './Point';\r\nimport { Rect } from './Rect';\r\n// face alignment constants\r\nvar relX = 0.5;\r\nvar relY = 0.43;\r\nvar relScale = 0.45;\r\nvar FaceLandmarks = /** @class */ (function () {\r\n    function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\r\n        if (shift === void 0) { shift = new Point(0, 0); }\r\n        var width = imgDims.width, height = imgDims.height;\r\n        this._imgDims = new Dimensions(width, height);\r\n        this._shift = shift;\r\n        this._positions = relativeFaceLandmarkPositions.map(function (pt) { return pt.mul(new Point(width, height)).add(shift); });\r\n    }\r\n    Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\r\n        get: function () { return new Point(this._shift.x, this._shift.y); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\r\n        get: function () { return this._imgDims.width; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\r\n        get: function () { return this._imgDims.height; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\r\n        get: function () { return this._positions; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\r\n        get: function () {\r\n            var _this = this;\r\n            return this._positions.map(function (pt) { return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight)); });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FaceLandmarks.prototype.forSize = function (width, height) {\r\n        return new this.constructor(this.relativePositions, { width: width, height: height });\r\n    };\r\n    FaceLandmarks.prototype.shiftBy = function (x, y) {\r\n        return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\r\n    };\r\n    FaceLandmarks.prototype.shiftByPoint = function (pt) {\r\n        return this.shiftBy(pt.x, pt.y);\r\n    };\r\n    /**\r\n     * Aligns the face landmarks after face detection from the relative positions of the faces\r\n     * bounding box, or it's current shift. This function should be used to align the face images\r\n     * after face detection has been performed, before they are passed to the face recognition net.\r\n     * This will make the computed face descriptor more accurate.\r\n     *\r\n     * @param detection (optional) The bounding box of the face or the face detection result. If\r\n     * no argument was passed the position of the face landmarks are assumed to be relative to\r\n     * it's current shift.\r\n     * @returns The bounding box of the aligned face.\r\n     */\r\n    FaceLandmarks.prototype.align = function (detection, options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (detection) {\r\n            var box = detection instanceof FaceDetection\r\n                ? detection.box.floor()\r\n                : new Box(detection);\r\n            return this.shiftBy(box.x, box.y).align(null, options);\r\n        }\r\n        var _a = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options), useDlibAlignment = _a.useDlibAlignment, minBoxPadding = _a.minBoxPadding;\r\n        if (useDlibAlignment) {\r\n            return this.alignDlib();\r\n        }\r\n        return this.alignMinBbox(minBoxPadding);\r\n    };\r\n    FaceLandmarks.prototype.alignDlib = function () {\r\n        var centers = this.getRefPointsForAlignment();\r\n        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];\r\n        var distToMouth = function (pt) { return mouthCenter.sub(pt).magnitude(); };\r\n        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\r\n        var size = Math.floor(eyeToMouthDist / relScale);\r\n        var refPoint = getCenterPoint(centers);\r\n        // TODO: pad in case rectangle is out of image bounds\r\n        var x = Math.floor(Math.max(0, refPoint.x - (relX * size)));\r\n        var y = Math.floor(Math.max(0, refPoint.y - (relY * size)));\r\n        return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\r\n    };\r\n    FaceLandmarks.prototype.alignMinBbox = function (padding) {\r\n        var box = minBbox(this.positions);\r\n        return box.pad(box.width * padding, box.height * padding);\r\n    };\r\n    FaceLandmarks.prototype.getRefPointsForAlignment = function () {\r\n        throw new Error('getRefPointsForAlignment not implemented by base class');\r\n    };\r\n    return FaceLandmarks;\r\n}());\r\nexport { FaceLandmarks };\r\n//# sourceMappingURL=FaceLandmarks.js.map"]},"metadata":{},"sourceType":"module"}