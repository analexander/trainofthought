{"ast":null,"code":"import _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var ReduceProgram = function ReduceProgram(reduceInfo, reduceType) {\n  _classCallCheck(this, ReduceProgram);\n\n  this.variableNames = ['x'];\n  var windowSize = reduceInfo.windowSize,\n      batchSize = reduceInfo.batchSize,\n      inSize = reduceInfo.inSize,\n      outSize = reduceInfo.outSize;\n  this.outputShape = [batchSize, outSize];\n  var initializationValue = '0.0';\n  var compareOp = \"\";\n\n  if (reduceType === 'prod') {\n    initializationValue = '1.0';\n  } else if (reduceType === 'min') {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '1.0 / 1e-20';\n    compareOp = \"min\";\n  } else if (reduceType === 'max') {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '-1.0 / 1e-20';\n    compareOp = \"max\";\n  }\n\n  var returnValue = \"\".concat(reduceType, \"(\").concat(reduceType, \"(\").concat(reduceType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n  if (reduceType === 'sum') {\n    returnValue = \"sumValue\";\n  } else if (reduceType === 'prod') {\n    returnValue = \"prodValue\";\n  } else if (reduceType === 'all') {\n    returnValue = \"allValue\";\n  } else if (reduceType === 'any') {\n    returnValue = \"anyValue\";\n  }\n\n  var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n  var windowSizeVec4Remainder = windowSize % 4;\n  var updateSnippet = \"\\n      if (\".concat(reduceType === 'sum', \") {\\n        sumValue += dot(values, ones);\\n      } else if (\").concat(reduceType === 'prod', \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n  var vecType = \"vec4\";\n\n  if (reduceType === 'all') {\n    initializationValue = '1.0';\n    updateSnippet = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \";\n    vecType = \"bvec4\";\n  } else if (reduceType === 'any') {\n    initializationValue = '0.0';\n    updateSnippet = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \";\n    vecType = \"bvec4\";\n  }\n\n  var checkOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return initializationValue;\\n        }\\n      \");\n  }\n\n  this.userCode = \"\\n      const float initializationValue = \".concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \").concat(checkOutOfBounds, \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \").concat(windowSize, \";\\n\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \").concat(windowSizeNearestVec4, \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \").concat(vecType, \" values = \").concat(vecType, \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n\\n        int inIdx = inOffset + \").concat(windowSizeNearestVec4, \";\\n        if (\").concat(windowSizeVec4Remainder === 1, \") {\\n          \").concat(vecType, \" values = \").concat(vecType, \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 2, \") {\\n          \").concat(vecType, \" values = \").concat(vecType, \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 3, \") {\\n          \").concat(vecType, \" values = \").concat(vecType, \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n};","map":null,"metadata":{},"sourceType":"module"}