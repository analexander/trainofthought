{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\n\nfunction nmsParams(node, tensorMap, context) {\n  var boxes = getParamValue('boxes', node, tensorMap, context);\n  var scores = getParamValue('scores', node, tensorMap, context);\n  var maxOutputSize = getParamValue('maxOutputSize', node, tensorMap, context);\n  var iouThreshold = getParamValue('iouThreshold', node, tensorMap, context);\n  var scoreThreshold = getParamValue('scoreThreshold', node, tensorMap, context);\n  var softNmsSigma = getParamValue('softNmsSigma', node, tensorMap, context);\n  return {\n    boxes: boxes,\n    scores: scores,\n    maxOutputSize: maxOutputSize,\n    iouThreshold: iouThreshold,\n    scoreThreshold: scoreThreshold,\n    softNmsSigma: softNmsSigma\n  };\n}\n\nexport var executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node, tensorMap, context) {\n    var _nmsParams, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, result, _nmsParams2, _boxes, _scores, _maxOutputSize, _iouThreshold, _scoreThreshold, padToMaxOutputSize, _result, _nmsParams3, _boxes2, _scores2, _maxOutputSize2, _iouThreshold2, _scoreThreshold2, condition, _result2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = node.op;\n            _context.next = _context.t0 === 'NonMaxSuppressionV5' ? 3 : _context.t0 === 'NonMaxSuppressionV4' ? 8 : _context.t0 === 'NonMaxSuppressionV3' ? 14 : _context.t0 === 'NonMaxSuppressionV2' ? 14 : _context.t0 === 'Where' ? 19 : _context.t0 === 'ListDiff' ? 26 : 27;\n            break;\n\n          case 3:\n            _nmsParams = nmsParams(node, tensorMap, context), boxes = _nmsParams.boxes, scores = _nmsParams.scores, maxOutputSize = _nmsParams.maxOutputSize, iouThreshold = _nmsParams.iouThreshold, scoreThreshold = _nmsParams.scoreThreshold, softNmsSigma = _nmsParams.softNmsSigma;\n            _context.next = 6;\n            return tfOps.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n\n          case 6:\n            result = _context.sent;\n            return _context.abrupt(\"return\", [result.selectedIndices, result.selectedScores]);\n\n          case 8:\n            _nmsParams2 = nmsParams(node, tensorMap, context), _boxes = _nmsParams2.boxes, _scores = _nmsParams2.scores, _maxOutputSize = _nmsParams2.maxOutputSize, _iouThreshold = _nmsParams2.iouThreshold, _scoreThreshold = _nmsParams2.scoreThreshold;\n            padToMaxOutputSize = getParamValue('padToMaxOutputSize', node, tensorMap, context);\n            _context.next = 12;\n            return tfOps.image.nonMaxSuppressionPaddedAsync(_boxes, _scores, _maxOutputSize, _iouThreshold, _scoreThreshold, padToMaxOutputSize);\n\n          case 12:\n            _result = _context.sent;\n            return _context.abrupt(\"return\", [_result.selectedIndices, _result.validOutputs]);\n\n          case 14:\n            _nmsParams3 = nmsParams(node, tensorMap, context), _boxes2 = _nmsParams3.boxes, _scores2 = _nmsParams3.scores, _maxOutputSize2 = _nmsParams3.maxOutputSize, _iouThreshold2 = _nmsParams3.iouThreshold, _scoreThreshold2 = _nmsParams3.scoreThreshold;\n            _context.next = 17;\n            return tfOps.image.nonMaxSuppressionAsync(_boxes2, _scores2, _maxOutputSize2, _iouThreshold2, _scoreThreshold2);\n\n          case 17:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", [_context.t1]);\n\n          case 19:\n            condition = tfOps.cast(getParamValue('condition', node, tensorMap, context), 'bool');\n            _context.next = 22;\n            return tfOps.whereAsync(condition);\n\n          case 22:\n            _context.t2 = _context.sent;\n            _result2 = [_context.t2];\n            condition.dispose();\n            return _context.abrupt(\"return\", _result2);\n\n          case 26:\n            return _context.abrupt(\"return\", tfOps.setdiff1dAsync(getParamValue('x', node, tensorMap, context), getParamValue('y', node, tensorMap, context)));\n\n          case 27:\n            throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n\n          case 28:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var CATEGORY = 'dynamic';","map":null,"metadata":{},"sourceType":"module"}