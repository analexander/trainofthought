{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar assert = require('assert');\n\nvar EE = require('events').EventEmitter;\n\nvar Parser = require('./parse.js');\n\nvar fs = require('fs');\n\nvar fsm = require('fs-minipass');\n\nvar path = require('path');\n\nvar mkdir = require('./mkdir.js');\n\nvar mkdirSync = mkdir.sync;\n\nvar wc = require('./winchars.js');\n\nvar ONENTRY = Symbol('onEntry');\nvar CHECKFS = Symbol('checkFs');\nvar ISREUSABLE = Symbol('isReusable');\nvar MAKEFS = Symbol('makeFs');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar LINK = Symbol('link');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar UNSUPPORTED = Symbol('unsupported');\nvar UNKNOWN = Symbol('unknown');\nvar CHECKPATH = Symbol('checkPath');\nvar MKDIR = Symbol('mkdir');\nvar ONERROR = Symbol('onError');\nvar PENDING = Symbol('pending');\nvar PEND = Symbol('pend');\nvar UNPEND = Symbol('unpend');\nvar ENDED = Symbol('ended');\nvar MAYBECLOSE = Symbol('maybeClose');\nvar SKIP = Symbol('skip');\nvar DOCHOWN = Symbol('doChown');\nvar UID = Symbol('uid');\nvar GID = Symbol('gid');\n\nvar crypto = require('crypto'); // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\n\nvar unlinkFile = function unlinkFile(path, cb) {\n  if (process.platform !== 'win32') return fs.unlink(path, cb);\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, function (er) {\n    if (er) return cb(er);\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nvar unlinkFileSync = function unlinkFileSync(path) {\n  if (process.platform !== 'win32') return fs.unlinkSync(path);\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nvar uint32 = function uint32(a, b, c) {\n  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n};\n\nvar Unpack = /*#__PURE__*/function (_Parser) {\n  _inherits(Unpack, _Parser);\n\n  function Unpack(opt) {\n    var _this;\n\n    _classCallCheck(this, Unpack);\n\n    if (!opt) opt = {};\n\n    opt.ondone = function (_) {\n      _this[ENDED] = true;\n\n      _this[MAYBECLOSE]();\n    };\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Unpack).call(this, opt));\n    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    _this.writable = true;\n    _this.readable = false;\n    _this[PENDING] = 0;\n    _this[ENDED] = false;\n    _this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');\n      if (opt.preserveOwner) throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      _this.uid = opt.uid;\n      _this.gid = opt.gid;\n      _this.setOwner = true;\n    } else {\n      _this.uid = null;\n      _this.gid = null;\n      _this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') _this.preserveOwner = process.getuid && process.getuid() === 0;else _this.preserveOwner = !!opt.preserveOwner;\n    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;\n    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    _this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    _this.win32 = !!opt.win32 || process.platform === 'win32'; // do not unpack over files that are newer than what's in the archive\n\n    _this.newer = !!opt.newer; // do not unpack over ANY files\n\n    _this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    _this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    _this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    _this.unlink = !!opt.unlink;\n    _this.cwd = path.resolve(opt.cwd || process.cwd());\n    _this.strip = +opt.strip || 0;\n    _this.processUmask = process.umask();\n    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask; // default mode for dirs created as parents\n\n    _this.dmode = opt.dmode || 511 & ~_this.umask;\n    _this.fmode = opt.fmode || 438 & ~_this.umask;\n\n    _this.on('entry', function (entry) {\n      return _this[ONENTRY](entry);\n    });\n\n    return _this;\n  }\n\n  _createClass(Unpack, [{\n    key: MAYBECLOSE,\n    value: function value() {\n      if (this[ENDED] && this[PENDING] === 0) {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n        this.emit('close');\n      }\n    }\n  }, {\n    key: CHECKPATH,\n    value: function value(entry) {\n      if (this.strip) {\n        var parts = entry.path.split(/\\/|\\\\/);\n        if (parts.length < this.strip) return false;\n        entry.path = parts.slice(this.strip).join('/');\n\n        if (entry.type === 'Link') {\n          var linkparts = entry.linkpath.split(/\\/|\\\\/);\n          if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');\n        }\n      }\n\n      if (!this.preservePaths) {\n        var p = entry.path;\n\n        if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n          this.warn('path contains \\'..\\'', p);\n          return false;\n        } // absolutes on posix are also absolutes on win32\n        // so we only need to test this one to get both\n\n\n        if (path.win32.isAbsolute(p)) {\n          var parsed = path.win32.parse(p);\n          this.warn('stripping ' + parsed.root + ' from absolute path', p);\n          entry.path = p.substr(parsed.root.length);\n        }\n      } // only encode : chars that aren't drive letter indicators\n\n\n      if (this.win32) {\n        var _parsed = path.win32.parse(entry.path);\n\n        entry.path = _parsed.root === '' ? wc.encode(entry.path) : _parsed.root + wc.encode(entry.path.substr(_parsed.root.length));\n      }\n\n      if (path.isAbsolute(entry.path)) entry.absolute = entry.path;else entry.absolute = path.resolve(this.cwd, entry.path);\n      return true;\n    }\n  }, {\n    key: ONENTRY,\n    value: function value(entry) {\n      if (!this[CHECKPATH](entry)) return entry.resume();\n      assert.equal(typeof entry.absolute, 'string');\n\n      switch (entry.type) {\n        case 'Directory':\n        case 'GNUDumpDir':\n          if (entry.mode) entry.mode = entry.mode | 448;\n\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n        case 'Link':\n        case 'SymbolicLink':\n          return this[CHECKFS](entry);\n\n        case 'CharacterDevice':\n        case 'BlockDevice':\n        case 'FIFO':\n          return this[UNSUPPORTED](entry);\n      }\n    }\n  }, {\n    key: ONERROR,\n    value: function value(er, entry) {\n      // Cwd has to exist, or else nothing works. That's serious.\n      // Other errors are warnings, which raise the error in strict\n      // mode, but otherwise continue on.\n      if (er.name === 'CwdError') this.emit('error', er);else {\n        this.warn(er.message, er);\n        this[UNPEND]();\n        entry.resume();\n      }\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode, cb) {\n      mkdir(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      }, cb);\n    }\n  }, {\n    key: DOCHOWN,\n    value: function value(entry) {\n      // in preserve owner mode, chown if the entry doesn't match process\n      // in set owner mode, chown if setting doesn't match process\n      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n    }\n  }, {\n    key: UID,\n    value: function value(entry) {\n      return uint32(this.uid, entry.uid, this.processUid);\n    }\n  }, {\n    key: GID,\n    value: function value(entry) {\n      return uint32(this.gid, entry.gid, this.processGid);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry) {\n      var _this2 = this;\n\n      var mode = entry.mode & 4095 || this.fmode;\n      var stream = new fsm.WriteStream(entry.absolute, {\n        mode: mode,\n        autoClose: false\n      });\n      stream.on('error', function (er) {\n        return _this2[ONERROR](er, entry);\n      });\n      var actions = 1;\n\n      var done = function done(er) {\n        if (er) return _this2[ONERROR](er, entry);\n        if (--actions === 0) fs.close(stream.fd, function (_) {\n          return _this2[UNPEND]();\n        });\n      };\n\n      stream.on('finish', function (_) {\n        // if futimes fails, try utimes\n        // if utimes fails, fail with the original error\n        // same for fchown/chown\n        var abs = entry.absolute;\n        var fd = stream.fd;\n\n        if (entry.mtime && !_this2.noMtime) {\n          actions++;\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          fs.futimes(fd, atime, mtime, function (er) {\n            return er ? fs.utimes(abs, atime, mtime, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n\n        if (_this2[DOCHOWN](entry)) {\n          actions++;\n\n          var uid = _this2[UID](entry);\n\n          var gid = _this2[GID](entry);\n\n          fs.fchown(fd, uid, gid, function (er) {\n            return er ? fs.chown(abs, uid, gid, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n\n        done();\n      });\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this2[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n\n      tx.pipe(stream);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry) {\n      var _this3 = this;\n\n      var mode = entry.mode & 4095 || this.dmode;\n      this[MKDIR](entry.absolute, mode, function (er) {\n        if (er) return _this3[ONERROR](er, entry);\n        var actions = 1;\n\n        var done = function done(_) {\n          if (--actions === 0) {\n            _this3[UNPEND]();\n\n            entry.resume();\n          }\n        };\n\n        if (entry.mtime && !_this3.noMtime) {\n          actions++;\n          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n        }\n\n        if (_this3[DOCHOWN](entry)) {\n          actions++;\n          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);\n        }\n\n        done();\n      });\n    }\n  }, {\n    key: UNSUPPORTED,\n    value: function value(entry) {\n      this.warn('unsupported entry type: ' + entry.type, entry);\n      entry.resume();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value(entry) {\n      this[LINK](entry, entry.linkpath, 'symlink');\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(entry) {\n      this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link');\n    }\n  }, {\n    key: PEND,\n    value: function value() {\n      this[PENDING]++;\n    }\n  }, {\n    key: UNPEND,\n    value: function value() {\n      this[PENDING]--;\n      this[MAYBECLOSE]();\n    }\n  }, {\n    key: SKIP,\n    value: function value(entry) {\n      this[UNPEND]();\n      entry.resume();\n    } // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n\n  }, {\n    key: ISREUSABLE,\n    value: function value(entry, st) {\n      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== 'win32';\n    } // check if a thing is there, and if so, try to clobber it\n\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      var _this4 = this;\n\n      this[PEND]();\n      this[MKDIR](path.dirname(entry.absolute), this.dmode, function (er) {\n        if (er) return _this4[ONERROR](er, entry);\n        fs.lstat(entry.absolute, function (er, st) {\n          if (st && (_this4.keep || _this4.newer && st.mtime > entry.mtime)) _this4[SKIP](entry);else if (er || _this4[ISREUSABLE](entry, st)) _this4[MAKEFS](null, entry);else if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (!entry.mode || (st.mode & 4095) === entry.mode) _this4[MAKEFS](null, entry);else fs.chmod(entry.absolute, entry.mode, function (er) {\n                return _this4[MAKEFS](er, entry);\n              });\n            } else fs.rmdir(entry.absolute, function (er) {\n              return _this4[MAKEFS](er, entry);\n            });\n          } else unlinkFile(entry.absolute, function (er) {\n            return _this4[MAKEFS](er, entry);\n          });\n        });\n      });\n    }\n  }, {\n    key: MAKEFS,\n    value: function value(er, entry) {\n      if (er) return this[ONERROR](er, entry);\n\n      switch (entry.type) {\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n          return this[FILE](entry);\n\n        case 'Link':\n          return this[HARDLINK](entry);\n\n        case 'SymbolicLink':\n          return this[SYMLINK](entry);\n\n        case 'Directory':\n        case 'GNUDumpDir':\n          return this[DIRECTORY](entry);\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link) {\n      var _this5 = this;\n\n      // XXX: get the type ('file' or 'dir') for windows\n      fs[link](linkpath, entry.absolute, function (er) {\n        if (er) return _this5[ONERROR](er, entry);\n\n        _this5[UNPEND]();\n\n        entry.resume();\n      });\n    }\n  }]);\n\n  return Unpack;\n}(Parser);\n\nvar UnpackSync = /*#__PURE__*/function (_Unpack) {\n  _inherits(UnpackSync, _Unpack);\n\n  function UnpackSync(opt) {\n    _classCallCheck(this, UnpackSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnpackSync).call(this, opt));\n  }\n\n  _createClass(UnpackSync, [{\n    key: CHECKFS,\n    value: function value(entry) {\n      var er = this[MKDIR](path.dirname(entry.absolute), this.dmode);\n      if (er) return this[ONERROR](er, entry);\n\n      try {\n        var st = fs.lstatSync(entry.absolute);\n        if (this.keep || this.newer && st.mtime > entry.mtime) return this[SKIP](entry);else if (this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry);else {\n          try {\n            if (st.isDirectory()) {\n              if (entry.type === 'Directory') {\n                if (entry.mode && (st.mode & 4095) !== entry.mode) fs.chmodSync(entry.absolute, entry.mode);\n              } else fs.rmdirSync(entry.absolute);\n            } else unlinkFileSync(entry.absolute);\n\n            return this[MAKEFS](null, entry);\n          } catch (er) {\n            return this[ONERROR](er, entry);\n          }\n        }\n      } catch (er) {\n        return this[MAKEFS](null, entry);\n      }\n    }\n  }, {\n    key: FILE,\n    value: function value(entry) {\n      var _this6 = this;\n\n      var mode = entry.mode & 4095 || this.fmode;\n\n      var oner = function oner(er) {\n        try {\n          fs.closeSync(fd);\n        } catch (_) {}\n\n        if (er) _this6[ONERROR](er, entry);\n      };\n\n      var stream;\n      var fd;\n\n      try {\n        fd = fs.openSync(entry.absolute, 'w', mode);\n      } catch (er) {\n        return oner(er);\n      }\n\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this6[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n\n      tx.on('data', function (chunk) {\n        try {\n          fs.writeSync(fd, chunk, 0, chunk.length);\n        } catch (er) {\n          oner(er);\n        }\n      });\n      tx.on('end', function (_) {\n        var er = null; // try both, falling futimes back to utimes\n        // if either fails, handle the first error\n\n        if (entry.mtime && !_this6.noMtime) {\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n\n          try {\n            fs.futimesSync(fd, atime, mtime);\n          } catch (futimeser) {\n            try {\n              fs.utimesSync(entry.absolute, atime, mtime);\n            } catch (utimeser) {\n              er = futimeser;\n            }\n          }\n        }\n\n        if (_this6[DOCHOWN](entry)) {\n          var uid = _this6[UID](entry);\n\n          var gid = _this6[GID](entry);\n\n          try {\n            fs.fchownSync(fd, uid, gid);\n          } catch (fchowner) {\n            try {\n              fs.chownSync(entry.absolute, uid, gid);\n            } catch (chowner) {\n              er = er || fchowner;\n            }\n          }\n        }\n\n        oner(er);\n      });\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry) {\n      var mode = entry.mode & 4095 || this.dmode;\n      var er = this[MKDIR](entry.absolute, mode);\n      if (er) return this[ONERROR](er, entry);\n\n      if (entry.mtime && !this.noMtime) {\n        try {\n          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n        } catch (er) {}\n      }\n\n      if (this[DOCHOWN](entry)) {\n        try {\n          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n        } catch (er) {}\n      }\n\n      entry.resume();\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode) {\n      try {\n        return mkdir.sync(dir, {\n          uid: this.uid,\n          gid: this.gid,\n          processUid: this.processUid,\n          processGid: this.processGid,\n          umask: this.processUmask,\n          preserve: this.preservePaths,\n          unlink: this.unlink,\n          cache: this.dirCache,\n          cwd: this.cwd,\n          mode: mode\n        });\n      } catch (er) {\n        return er;\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link) {\n      try {\n        fs[link + 'Sync'](linkpath, entry.absolute);\n        entry.resume();\n      } catch (er) {\n        return this[ONERROR](er, entry);\n      }\n    }\n  }]);\n\n  return UnpackSync;\n}(Unpack);\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":null,"metadata":{},"sourceType":"script"}