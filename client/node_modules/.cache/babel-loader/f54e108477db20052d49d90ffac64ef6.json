{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isTensor3D, isTensor4D } from '../utils';\nimport { awaitMediaLoaded } from './awaitMediaLoaded';\nimport { isMediaElement } from './isMediaElement';\nimport { NetInput } from './NetInput';\nimport { resolveInput } from './resolveInput';\n/**\r\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\r\n * to be finished loading.\r\n *\r\n * @param input The input, which can be a media element or an array of different media elements.\r\n * @returns A NetInput instance, which can be passed into one of the neural networks.\r\n */\n\nexport function toNetInput(inputs) {\n  return __awaiter(this, void 0, void 0, function () {\n    var inputArgArray, getIdxHint, inputArray;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (inputs instanceof NetInput) {\n            return [2\n            /*return*/\n            , inputs];\n          }\n\n          inputArgArray = Array.isArray(inputs) ? inputs : [inputs];\n\n          if (!inputArgArray.length) {\n            throw new Error('toNetInput - empty array passed as input');\n          }\n\n          getIdxHint = function getIdxHint(idx) {\n            return Array.isArray(inputs) ? \" at input index \" + idx + \":\" : '';\n          };\n\n          inputArray = inputArgArray.map(resolveInput);\n          inputArray.forEach(function (input, i) {\n            if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\n              if (typeof inputArgArray[i] === 'string') {\n                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" string passed, but could not resolve HTMLElement for element id \" + inputArgArray[i]);\n              }\n\n              throw new Error(\"toNetInput -\" + getIdxHint(i) + \" expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id\");\n            }\n\n            if (isTensor4D(input)) {\n              // if tf.Tensor4D is passed in the input array, the batch size has to be 1\n              var batchSize = input.shape[0];\n\n              if (batchSize !== 1) {\n                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n              }\n            }\n          }); // wait for all media elements being loaded\n\n          return [4\n          /*yield*/\n          , Promise.all(inputArray.map(function (input) {\n            return isMediaElement(input) && awaitMediaLoaded(input);\n          }))];\n\n        case 1:\n          // wait for all media elements being loaded\n          _a.sent();\n\n          return [2\n          /*return*/\n          , new NetInput(inputArray, Array.isArray(inputs))];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/dom/toNetInput.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,EAAqB,UAArB,QAAuC,UAAvC;AACA,SAAS,gBAAT,QAAiC,oBAAjC;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,QAAT,QAAyB,YAAzB;AACA,SAAS,YAAT,QAA6B,gBAA7B;AAGA;;;;;;AAMG;;AACH,OAAM,SAAgB,UAAhB,CAA2B,MAA3B,EAA4C;;;;;;AAChD,cAAI,MAAM,YAAY,QAAtB,EAAgC;AAC9B,mBAAA,CAAA;AAAA;AAAA,cAAO,MAAP,CAAA;AACD;;AAEG,UAAA,aAAa,GAAG,KAAK,CAAC,OAAN,CAAc,MAAd,IACd,MADc,GAEd,CAAC,MAAD,CAFF;;AAIJ,cAAI,CAAC,aAAa,CAAC,MAAnB,EAA2B;AACzB,kBAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAEK,UAAA,UAAU,GAAG,oBAAC,GAAD,EAAY;AAAK,mBAAA,KAAK,CAAC,OAAN,CAAc,MAAd,IAAwB,qBAAmB,GAAnB,GAAsB,GAA9C,GAAA,EAAA;AAAsD,WAApF;;AAEA,UAAA,UAAU,GAAG,aAAa,CAAC,GAAd,CAAkB,YAAlB,CAAb;AAEN,UAAA,UAAU,CAAC,OAAX,CAAmB,UAAC,KAAD,EAAQ,CAAR,EAAS;AAC1B,gBAAI,CAAC,cAAc,CAAC,KAAD,CAAf,IAA0B,CAAC,UAAU,CAAC,KAAD,CAArC,IAAgD,CAAC,UAAU,CAAC,KAAD,CAA/D,EAAwE;AAEtE,kBAAI,OAAO,aAAa,CAAC,CAAD,CAApB,KAA4B,QAAhC,EAA0C;AACxC,sBAAM,IAAI,KAAJ,CAAU,iBAAe,UAAU,CAAC,CAAD,CAAzB,GAA4B,mEAA5B,GAAgG,aAAa,CAAC,CAAD,CAAvH,CAAN;AACD;;AAED,oBAAM,IAAI,KAAJ,CAAU,iBAAe,UAAU,CAAC,CAAD,CAAzB,GAA4B,6HAAtC,CAAN;AACD;;AAED,gBAAI,UAAU,CAAC,KAAD,CAAd,EAAuB;AACrB;AACA,kBAAM,SAAS,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAlB;;AACA,kBAAI,SAAS,KAAK,CAAlB,EAAqB;AACnB,sBAAM,IAAI,KAAJ,CAAU,iBAAe,UAAU,CAAC,CAAD,CAAzB,GAA4B,8BAA5B,GAA2D,SAA3D,GAAoE,2CAA9E,CAAN;AACD;AACF;AACF,WAjBD,E,CAmBA;;AACA,iBAAA,CAAA;AAAA;AAAA,YAAM,OAAO,CAAC,GAAR,CACJ,UAAU,CAAC,GAAX,CAAe,UAAA,KAAA,EAAK;AAAI,mBAAA,cAAc,CAAC,KAAD,CAAd,IAAyB,gBAAgB,CAAzC,KAAyC,CAAzC;AAAgD,WAAxE,CADI,CAAN,CAAA;;;AADA;AACA,UAAA,EAAA,CAAA,IAAA;;AAIA,iBAAA,CAAA;AAAA;AAAA,YAAO,IAAI,QAAJ,CAAa,UAAb,EAAyB,KAAK,CAAC,OAAN,CAAc,MAAd,CAAzB,CAAP,CAAA;;;;AACD","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\r\nimport { isTensor3D, isTensor4D } from '../utils';\r\nimport { awaitMediaLoaded } from './awaitMediaLoaded';\r\nimport { isMediaElement } from './isMediaElement';\r\nimport { NetInput } from './NetInput';\r\nimport { resolveInput } from './resolveInput';\r\n/**\r\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\r\n * to be finished loading.\r\n *\r\n * @param input The input, which can be a media element or an array of different media elements.\r\n * @returns A NetInput instance, which can be passed into one of the neural networks.\r\n */\r\nexport function toNetInput(inputs) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var inputArgArray, getIdxHint, inputArray;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (inputs instanceof NetInput) {\r\n                        return [2 /*return*/, inputs];\r\n                    }\r\n                    inputArgArray = Array.isArray(inputs)\r\n                        ? inputs\r\n                        : [inputs];\r\n                    if (!inputArgArray.length) {\r\n                        throw new Error('toNetInput - empty array passed as input');\r\n                    }\r\n                    getIdxHint = function (idx) { return Array.isArray(inputs) ? \" at input index \" + idx + \":\" : ''; };\r\n                    inputArray = inputArgArray.map(resolveInput);\r\n                    inputArray.forEach(function (input, i) {\r\n                        if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\r\n                            if (typeof inputArgArray[i] === 'string') {\r\n                                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" string passed, but could not resolve HTMLElement for element id \" + inputArgArray[i]);\r\n                            }\r\n                            throw new Error(\"toNetInput -\" + getIdxHint(i) + \" expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id\");\r\n                        }\r\n                        if (isTensor4D(input)) {\r\n                            // if tf.Tensor4D is passed in the input array, the batch size has to be 1\r\n                            var batchSize = input.shape[0];\r\n                            if (batchSize !== 1) {\r\n                                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\r\n                            }\r\n                        }\r\n                    });\r\n                    // wait for all media elements being loaded\r\n                    return [4 /*yield*/, Promise.all(inputArray.map(function (input) { return isMediaElement(input) && awaitMediaLoaded(input); }))];\r\n                case 1:\r\n                    // wait for all media elements being loaded\r\n                    _a.sent();\r\n                    return [2 /*return*/, new NetInput(inputArray, Array.isArray(inputs))];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=toNetInput.js.map"]},"metadata":{},"sourceType":"module"}