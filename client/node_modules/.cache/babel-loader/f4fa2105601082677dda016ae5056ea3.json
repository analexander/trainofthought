{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', function () {\n    return \"The dtype for rfft() must be real value but got \".concat(input.dtype);\n  });\n  var innerDimensionSize = input.shape[input.shape.length - 1];\n  var batch = input.size / innerDimensionSize;\n  var adjustedInput;\n\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    var begin = input.shape.map(function (v) {\n      return 0;\n    });\n    var size = input.shape.map(function (v) {\n      return v;\n    });\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    var zerosShape = input.shape.map(function (v) {\n      return v;\n    });\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  } // Complement the input with zero imaginary numbers.\n\n\n  var zerosInput = zerosLike(adjustedInput);\n  var complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n  var ret = fft(complexInput); // Exclude complex conjugations. These conjugations are put symmetrically.\n\n  var half = Math.floor(innerDimensionSize / 2) + 1;\n  var realValues = real(ret);\n  var imagValues = imag(ret);\n  var realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n  var imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n  var outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport var rfft = op({\n  rfft_: rfft_\n});","map":null,"metadata":{},"sourceType":"module"}