{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { inferShape } from './tensor_util_env';\nimport { arraysEqual, flatten, isString, isTypedArray } from './util';\nvar TEST_EPSILON_FLOAT32 = 1e-3;\nexport var TEST_EPSILON_FLOAT16 = 1e-1;\nexport function expectArraysClose(actual, expected, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  return expectArraysPredicate(actual, expected, function (a, b) {\n    return areClose(a, b, epsilon);\n  });\n}\nexport function testEpsilon() {\n  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;\n}\n\nfunction expectArraysPredicate(actual, expected, predicate) {\n  var checkClassType = true;\n\n  if (isTypedArray(actual) || isTypedArray(expected)) {\n    checkClassType = false;\n  }\n\n  if (isTypedArray(actual) && isTypedArray(expected)) {\n    checkClassType = true;\n  }\n\n  if (checkClassType) {\n    var aType = actual.constructor.name;\n    var bType = expected.constructor.name;\n\n    if (aType !== bType) {\n      throw new Error(\"Arrays are of different type. Actual: \".concat(aType, \". \") + \"Expected: \".concat(bType));\n    }\n  }\n\n  if (Array.isArray(actual) && Array.isArray(expected)) {\n    var actualShape = inferShape(actual);\n    var expectedShape = inferShape(expected);\n\n    if (!arraysEqual(actualShape, expectedShape)) {\n      throw new Error(\"Arrays have different shapes. \" + \"Actual: [\".concat(actualShape, \"]. Expected: [\").concat(expectedShape, \"]\"));\n    }\n  }\n\n  var actualFlat = isTypedArray(actual) ? actual : flatten(actual);\n  var expectedFlat = isTypedArray(expected) ? expected : flatten(expected);\n\n  if (actualFlat.length !== expectedFlat.length) {\n    throw new Error(\"Arrays have different lengths actual: \".concat(actualFlat.length, \" vs \") + \"expected: \".concat(expectedFlat.length, \".\\n\") + \"Actual:   \".concat(actualFlat, \".\\n\") + \"Expected: \".concat(expectedFlat, \".\"));\n  }\n\n  for (var i = 0; i < expectedFlat.length; ++i) {\n    var a = actualFlat[i];\n    var e = expectedFlat[i];\n\n    if (!predicate(a, e)) {\n      throw new Error(\"Arrays differ: actual[\".concat(i, \"] = \").concat(a, \", expected[\").concat(i, \"] = \").concat(e, \".\\n\") + \"Actual:   \".concat(actualFlat, \".\\n\") + \"Expected: \".concat(expectedFlat, \".\"));\n    }\n  }\n}\n\nexport function expectPromiseToFail(fn, done) {\n  fn().then(function () {\n    return done.fail();\n  }, function () {\n    return done();\n  });\n}\nexport function expectArraysEqual(actual, expected) {\n  var exp = typeof expected === 'string' || typeof expected === 'number' || typeof expected === 'boolean' ? [expected] : expected;\n\n  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {\n    // tslint:disable-next-line: triple-equals\n    return expectArraysPredicate(actual, exp, function (a, b) {\n      return a == b;\n    });\n  }\n\n  return expectArraysPredicate(actual, expected, function (a, b) {\n    return areClose(a, b, 0);\n  });\n}\nexport function expectNumbersClose(a, e, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  if (!areClose(a, e, epsilon)) {\n    throw new Error(\"Numbers differ: actual === \".concat(a, \", expected === \").concat(e));\n  }\n}\n\nfunction areClose(a, e, epsilon) {\n  if (!isFinite(a) && !isFinite(e)) {\n    return true;\n  }\n\n  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function expectValuesInRange(actual, low, high) {\n  for (var i = 0; i < actual.length; i++) {\n    if (actual[i] < low || actual[i] > high) {\n      throw new Error(\"Value out of range:\".concat(actual[i], \" low: \").concat(low, \", high: \").concat(high));\n    }\n  }\n}\nexport function expectArrayBuffersEqual(actual, expected) {\n  // Safari & Jasmine don't like comparing ArrayBuffers directly. Wrapping in\n  // a Float32Array solves this issue.\n  expect(new Float32Array(actual)).toEqual(new Float32Array(expected));\n}","map":null,"metadata":{},"sourceType":"module"}