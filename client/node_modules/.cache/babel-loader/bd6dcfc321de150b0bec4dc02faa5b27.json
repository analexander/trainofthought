{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getPadding, getParamValue } from './utils';\n\nfunction fusedConvAndDepthWiseParams(node, tensorMap, context) {\n  var _getParamValue = getParamValue('fusedOps', node, tensorMap, context),\n      _getParamValue2 = _slicedToArray(_getParamValue, 2),\n      extraOp = _getParamValue2[0],\n      activationFunc = _getParamValue2[1];\n\n  var isBiasAdd = extraOp === 'biasadd';\n  var isPrelu = activationFunc === 'prelu';\n  var isBatchNorm = extraOp === 'fusedbatchnorm';\n  var numArgs = getParamValue('numArgs', node, tensorMap, context);\n\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' + 'must have two extra arguments: bias and alpha.');\n    }\n\n    if (!isPrelu && numArgs !== 1) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd must have ' + 'one extra argument: bias.');\n    }\n  }\n\n  if (isBatchNorm) {\n    throw new Error('FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.');\n  }\n\n  var stride = getParamValue('strides', node, tensorMap, context);\n  var pad = getPadding(node, tensorMap, context);\n  var dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n  var dilations = getParamValue('dilations', node, tensorMap, context);\n\n  var _getParamValue3 = getParamValue('args', node, tensorMap, context),\n      _getParamValue4 = _slicedToArray(_getParamValue3, 2),\n      biasArg = _getParamValue4[0],\n      preluArg = _getParamValue4[1];\n\n  return {\n    stride: stride,\n    pad: pad,\n    dataFormat: dataFormat,\n    dilations: dilations,\n    biasArg: biasArg,\n    preluArg: preluArg,\n    activationFunc: activationFunc\n  };\n}\n\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  switch (node.op) {\n    case 'Conv1D':\n      {\n        var stride = getParamValue('stride', node, tensorMap, context);\n        var pad = getParamValue('pad', node, tensorMap, context);\n        var dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        var dilation = getParamValue('dilation', node, tensorMap, context);\n        return [tfOps.conv1d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n      }\n\n    case 'Conv2D':\n      {\n        var _stride = getParamValue('strides', node, tensorMap, context);\n\n        var _pad = getPadding(node, tensorMap, context);\n\n        var _dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n\n        var dilations = getParamValue('dilations', node, tensorMap, context);\n        return [tfOps.conv2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride[1], _stride[2]], _pad, _dataFormat, [dilations[1], dilations[2]])];\n      }\n\n    case '_FusedConv2D':\n      {\n        var _fusedConvAndDepthWis = fusedConvAndDepthWiseParams(node, tensorMap, context),\n            _stride2 = _fusedConvAndDepthWis.stride,\n            _pad2 = _fusedConvAndDepthWis.pad,\n            _dataFormat2 = _fusedConvAndDepthWis.dataFormat,\n            _dilations = _fusedConvAndDepthWis.dilations,\n            biasArg = _fusedConvAndDepthWis.biasArg,\n            preluArg = _fusedConvAndDepthWis.preluArg,\n            activationFunc = _fusedConvAndDepthWis.activationFunc;\n\n        return [tfOps.fused.conv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [_stride2[1], _stride2[2]],\n          pad: _pad2,\n          dataFormat: _dataFormat2,\n          dilations: [_dilations[1], _dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg\n        })];\n      }\n\n    case 'FusedDepthwiseConv2dNative':\n      {\n        var _fusedConvAndDepthWis2 = fusedConvAndDepthWiseParams(node, tensorMap, context),\n            _stride3 = _fusedConvAndDepthWis2.stride,\n            _pad3 = _fusedConvAndDepthWis2.pad,\n            _dataFormat3 = _fusedConvAndDepthWis2.dataFormat,\n            _dilations2 = _fusedConvAndDepthWis2.dilations,\n            _biasArg = _fusedConvAndDepthWis2.biasArg,\n            _preluArg = _fusedConvAndDepthWis2.preluArg,\n            _activationFunc = _fusedConvAndDepthWis2.activationFunc;\n\n        return [tfOps.fused.depthwiseConv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [_stride3[1], _stride3[2]],\n          pad: _pad3,\n          dataFormat: _dataFormat3,\n          dilations: [_dilations2[1], _dilations2[2]],\n          bias: _biasArg,\n          activation: _activationFunc,\n          preluActivationWeights: _preluArg\n        })];\n      }\n\n    case 'Conv2DBackpropInput':\n    case 'Conv2dTranspose':\n      {\n        var shape = getParamValue('outputShape', node, tensorMap, context);\n\n        var _stride4 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad4 = getPadding(node, tensorMap, context);\n\n        return [tfOps.conv2dTranspose(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), shape, [_stride4[1], _stride4[2]], _pad4)];\n      }\n\n    case 'DepthwiseConv2dNative':\n    case 'DepthwiseConv2d':\n      {\n        var _stride5 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad5 = getPadding(node, tensorMap, context);\n\n        var _dilations3 = getParamValue('dilations', node, tensorMap, context);\n\n        var _dataFormat4 = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n\n        return [tfOps.depthwiseConv2d(getParamValue('input', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride5[1], _stride5[2]], _pad5, _dataFormat4, [_dilations3[1], _dilations3[2]])];\n      }\n\n    case 'Conv3D':\n      {\n        var _stride6 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad6 = getParamValue('pad', node, tensorMap, context);\n\n        var _dataFormat5 = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n\n        var _dilations4 = getParamValue('dilations', node, tensorMap, context);\n\n        return [tfOps.conv3d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride6[1], _stride6[2], _stride6[3]], _pad6, _dataFormat5, [_dilations4[1], _dilations4[2], _dilations4[3]])];\n      }\n\n    case 'AvgPool':\n      {\n        var _stride7 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad7 = getParamValue('pad', node, tensorMap, context);\n\n        var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [tfOps.avgPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [_stride7[1], _stride7[2]], _pad7)];\n      }\n\n    case 'MaxPool':\n      {\n        var _stride8 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad8 = getParamValue('pad', node, tensorMap, context);\n\n        var _kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n\n        return [tfOps.maxPool(getParamValue('x', node, tensorMap, context), [_kernelSize[1], _kernelSize[2]], [_stride8[1], _stride8[2]], _pad8)];\n      }\n\n    case 'MaxPoolWithArgmax':\n      {\n        var _stride9 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad9 = getParamValue('pad', node, tensorMap, context);\n\n        var _kernelSize2 = getParamValue('kernelSize', node, tensorMap, context);\n\n        var includeBatchInIndex = getParamValue('includeBatchInIndex', node, tensorMap, context);\n\n        var _tfOps$maxPoolWithArg = tfOps.maxPoolWithArgmax(getParamValue('x', node, tensorMap, context), [_kernelSize2[1], _kernelSize2[2]], [_stride9[1], _stride9[2]], _pad9, includeBatchInIndex),\n            result = _tfOps$maxPoolWithArg.result,\n            indexes = _tfOps$maxPoolWithArg.indexes;\n\n        return [result, indexes];\n      }\n\n    case 'AvgPool3D':\n      {\n        var _stride10 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad10 = getParamValue('pad', node, tensorMap, context);\n\n        var _kernelSize3 = getParamValue('kernelSize', node, tensorMap, context);\n\n        return [tfOps.avgPool3d(getParamValue('x', node, tensorMap, context), [_kernelSize3[1], _kernelSize3[2], _kernelSize3[3]], [_stride10[1], _stride10[2], _stride10[3]], _pad10)];\n      }\n\n    case 'MaxPool3D':\n      {\n        var _stride11 = getParamValue('strides', node, tensorMap, context);\n\n        var _pad11 = getParamValue('pad', node, tensorMap, context);\n\n        var _kernelSize4 = getParamValue('kernelSize', node, tensorMap, context);\n\n        return [tfOps.maxPool3d(getParamValue('x', node, tensorMap, context), [_kernelSize4[1], _kernelSize4[2], _kernelSize4[3]], [_stride11[1], _stride11[2], _stride11[3]], _pad11)];\n      }\n\n    case 'Dilation2D':\n      {\n        var strides = getParamValue('strides', node, tensorMap, context);\n\n        var _pad12 = getParamValue('pad', node, tensorMap, context);\n\n        var _dilations5 = getParamValue('dilations', node, tensorMap, context); // strides: [1, stride_height, stride_width, 1].\n\n\n        var strideHeight = strides[1];\n        var strideWidth = strides[2]; // dilations: [1, dilation_height, dilation_width, 1].\n\n        var dilationHeight = _dilations5[1];\n        var dilationWidth = _dilations5[2];\n        return [tfOps.dilation2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [strideHeight, strideWidth], _pad12, [dilationHeight, dilationWidth], 'NHWC'\n        /* dataFormat */\n        )];\n      }\n\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'convolution';","map":null,"metadata":{},"sourceType":"module"}