{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Point, Rect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks5 } from '../classes/FaceLandmarks5';\nimport { toNetInput } from '../dom';\nimport { extendWithFaceDetection, extendWithFaceLandmarks } from '../factories';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { bgrToRgbTensor } from './bgrToRgbTensor';\nimport { CELL_SIZE } from './config';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { getSizesForScale } from './getSizesForScale';\nimport { MtcnnOptions } from './MtcnnOptions';\nimport { pyramidDown } from './pyramidDown';\nimport { stage1 } from './stage1';\nimport { stage2 } from './stage2';\nimport { stage3 } from './stage3';\n\nvar Mtcnn =\n/** @class */\nfunction (_super) {\n  __extends(Mtcnn, _super);\n\n  function Mtcnn() {\n    return _super.call(this, 'Mtcnn') || this;\n  }\n\n  Mtcnn.prototype.load = function (weightsOrUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2\n        /*return*/\n        , _super.prototype.load.call(this, weightsOrUrl)];\n      });\n    });\n  };\n\n  Mtcnn.prototype.loadFromDisk = function (filePath) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2\n        /*return*/\n        , _super.prototype.loadFromDisk.call(this, filePath)];\n      });\n    });\n  };\n\n  Mtcnn.prototype.forwardInput = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            params = this.params;\n\n            if (!params) {\n              throw new Error('Mtcnn - load model before inference');\n            }\n\n            inputCanvas = input.canvases[0];\n\n            if (!inputCanvas) {\n              throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');\n            }\n\n            stats = {};\n            tsTotal = Date.now();\n            imgTensor = tf.tidy(function () {\n              return bgrToRgbTensor(tf.expandDims(tf.browser.fromPixels(inputCanvas)).toFloat());\n            });\n\n            onReturn = function onReturn(results) {\n              // dispose tensors on return\n              imgTensor.dispose();\n              stats.total = Date.now() - tsTotal;\n              return results;\n            };\n\n            _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\n            _b = new MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\n            scales = (scaleSteps || pyramidDown(minFaceSize, scaleFactor, [height, width])).filter(function (scale) {\n              var sizes = getSizesForScale(scale, [height, width]);\n              return Math.min(sizes.width, sizes.height) > CELL_SIZE;\n            }).slice(0, maxNumScales);\n            stats.scales = scales;\n            stats.pyramid = scales.map(function (scale) {\n              return getSizesForScale(scale, [height, width]);\n            });\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];\n\n          case 1:\n            out1 = _c.sent();\n            stats.total_stage1 = Date.now() - ts;\n\n            if (!out1.boxes.length) {\n              return [2\n              /*return*/\n              , onReturn({\n                results: [],\n                stats: stats\n              })];\n            }\n\n            stats.stage2_numInputBoxes = out1.boxes.length; // using the inputCanvas to extract and resize the image patches, since it is faster\n            // than doing this on the gpu\n\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];\n\n          case 2:\n            out2 = _c.sent();\n            stats.total_stage2 = Date.now() - ts;\n\n            if (!out2.boxes.length) {\n              return [2\n              /*return*/\n              , onReturn({\n                results: [],\n                stats: stats\n              })];\n            }\n\n            stats.stage3_numInputBoxes = out2.boxes.length;\n            ts = Date.now();\n            return [4\n            /*yield*/\n            , stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];\n\n          case 3:\n            out3 = _c.sent();\n            stats.total_stage3 = Date.now() - ts;\n            results = out3.boxes.map(function (box, idx) {\n              return extendWithFaceLandmarks(extendWithFaceDetection({}, new FaceDetection(out3.scores[idx], new Rect(box.left / width, box.top / height, box.width / width, box.height / height), {\n                height: height,\n                width: width\n              })), new FaceLandmarks5(out3.points[idx].map(function (pt) {\n                return pt.sub(new Point(box.left, box.top)).div(new Point(box.width, box.height));\n              }), {\n                width: box.width,\n                height: box.height\n              }));\n            });\n            return [2\n            /*return*/\n            , onReturn({\n              results: results,\n              stats: stats\n            })];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.forward = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_b.sent(), forwardParams])];\n\n          case 2:\n            return [2\n            /*return*/\n            , _b.sent().results];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent(), forwardParams])];\n        }\n      });\n    });\n  };\n\n  Mtcnn.prototype.getDefaultModelName = function () {\n    return 'mtcnn_model';\n  };\n\n  Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  };\n\n  Mtcnn.prototype.extractParams = function (weights) {\n    return extractParams(weights);\n  };\n\n  return Mtcnn;\n}(NeuralNetwork);\n\nexport { Mtcnn };","map":null,"metadata":{},"sourceType":"module"}