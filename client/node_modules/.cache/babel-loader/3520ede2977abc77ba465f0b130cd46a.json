{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv3DBackpropFilterV2, TensorBuffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function conv3DBackpropFilterV2(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      dy = inputs.dy;\n  var strides = attrs.strides,\n      pad = attrs.pad,\n      filterShape = attrs.filterShape;\n  assertNotComplex([x, dy], 'conv3dBackpropFilterV2');\n  var xStrides = util.computeStrides(x.shape);\n  var dyStrides = util.computeStrides(dy.shape);\n  var convInfo = backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1\n  /* dilations */\n  , pad);\n  var strideDepth = convInfo.strideDepth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var filterDepth = convInfo.filterDepth;\n  var filterHeight = convInfo.filterHeight;\n  var filterWidth = convInfo.filterWidth;\n  var dw = new TensorBuffer(convInfo.filterShape, 'float32');\n  var dwValues = dw.values;\n\n  var _dw$strides = _slicedToArray(dw.strides, 4),\n      dwS0 = _dw$strides[0],\n      dwS1 = _dw$strides[1],\n      dwS2 = _dw$strides[2],\n      dwS3 = _dw$strides[3];\n\n  var dyValues = backend.data.get(dy.dataId).values;\n\n  var _dyStrides = _slicedToArray(dyStrides, 4),\n      dyS0 = _dyStrides[0],\n      dyS1 = _dyStrides[1],\n      dyS2 = _dyStrides[2],\n      dyS3 = _dyStrides[3];\n\n  var xValues = backend.data.get(x.dataId).values;\n\n  var _xStrides = _slicedToArray(xStrides, 4),\n      xS0 = _xStrides[0],\n      xS1 = _xStrides[1],\n      xS2 = _xStrides[2],\n      xS3 = _xStrides[3];\n\n  var frontPad = convInfo.padInfo.front;\n  var leftPad = convInfo.padInfo.left;\n  var topPad = convInfo.padInfo.top;\n\n  for (var wF = 0; wF < filterDepth; ++wF) {\n    var yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));\n    var yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);\n    var wOffset1 = wF * dwS0;\n\n    for (var wR = 0; wR < filterHeight; ++wR) {\n      var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n      var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n      var wOffset2 = wR * dwS1 + wOffset1;\n\n      for (var wC = 0; wC < filterWidth; ++wC) {\n        var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n        var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n        var wOffset3 = wC * dwS2 + wOffset2;\n\n        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n          var wOffset4 = d1 * dwS3 + wOffset3;\n\n          for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n            var dotProd = 0;\n\n            for (var b = 0; b < convInfo.batchSize; ++b) {\n              var xOffset1 = b * xS0;\n              var yOffset1 = b * dyS0;\n\n              for (var yF = yFMin; yF < yFMax; ++yF) {\n                var xF = wF + yF * strideDepth - frontPad;\n                var xOffset2 = xF * xS1 + xOffset1;\n                var yOffset2 = yF * dyS1 + yOffset1;\n\n                for (var yR = yRMin; yR < yRMax; ++yR) {\n                  var xR = wR + yR * strideHeight - topPad;\n                  var xOffset3 = xR * xS2 + xOffset2;\n                  var yOffset3 = yR * dyS2 + yOffset2;\n\n                  for (var yC = yCMin; yC < yCMax; ++yC) {\n                    var xC = wC + yC * strideWidth - leftPad;\n                    var xOffset4 = xC * xS3 + xOffset3;\n                    var yOffset4 = yC * dyS3 + yOffset3;\n                    dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];\n                  }\n                }\n              }\n            }\n\n            dwValues[wOffset4 + d2] = dotProd;\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(dw.shape, dw.dtype, dw.values);\n}\nexport var conv3DBackpropFilterV2Config = {\n  kernelName: Conv3DBackpropFilterV2,\n  backendName: 'cpu',\n  kernelFunc: conv3DBackpropFilterV2\n};","map":null,"metadata":{},"sourceType":"module"}