{"ast":null,"code":"\"use strict\";\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar log = require('npmlog');\n\nvar existsAsync = fs.exists || path.exists;\n\nvar versioning = require('./util/versioning.js');\n\nvar napi = require('./util/napi.js');\n\nvar mkdirp = require('mkdirp');\n\nvar npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {}\n\nvar http_get = {\n  impl: undefined,\n  type: undefined\n};\n\ntry {\n  http_get.impl = require('request');\n  http_get.type = 'request';\n  log.warn(\"Using request for node-pre-gyp https download\");\n} catch (e) {\n  http_get.impl = require('needle');\n  http_get.type = 'needle';\n  log.warn(\"Using needle for node-pre-gyp https download\");\n}\n\nfunction download(uri, opts, callback) {\n  log.http('GET', uri);\n  var req = null; // Try getting version info from the currently running npm.\n\n  var envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  var requestOpts = {\n    uri: uri.replace('+', '%2B'),\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  var proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  try {\n    req = http_get.impl.get(requestOpts.uri, requestOpts);\n  } catch (e) {\n    return callback(e);\n  }\n\n  if (req) {\n    req.on('response', function (res) {\n      log.http(res.statusCode, uri);\n    });\n  }\n\n  return callback(null, req);\n}\n\nfunction place_binary(from, to, opts, callback) {\n  download(from, opts, function (err, req) {\n    if (err) return callback(err);\n    if (!req) return callback(new Error(\"empty req\"));\n    var badDownload = false;\n    var hasResponse = false;\n\n    function afterExtract(err, extractCount) {\n      if (err) return callback(err);\n      if (badDownload) return callback(new Error(\"bad download\"));\n\n      if (extractCount === 0) {\n        return callback(new Error('There was a fatal problem while downloading/extracting the tarball'));\n      }\n\n      log.info('tarball', 'done parsing tarball');\n      callback();\n    } // for request compatibility\n\n\n    req.on('error', function (err) {\n      badDownload = true;\n\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(err);\n      }\n    }); // for needle compatibility\n\n    req.on('err', function (err) {\n      badDownload = true;\n\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(err);\n      }\n    });\n    req.on('close', function () {\n      if (!hasResponse) {\n        hasResponse = true;\n        return callback(new Error('Connection closed while downloading tarball file'));\n      }\n    });\n    req.on('response', function (res) {\n      // ignore redirects, needle handles these automatically.\n      if (http_get.type === 'needle' && res.headers.hasOwnProperty('location') && res.headers.location !== '') {\n        return;\n      }\n\n      if (hasResponse) {\n        return;\n      }\n\n      hasResponse = true;\n\n      if (res.statusCode !== 200) {\n        badDownload = true;\n        var err = new Error(res.statusCode + ' status code downloading tarball ' + from);\n        err.statusCode = res.statusCode;\n        return callback(err);\n      } // start unzipping and untaring\n\n\n      req.pipe(extract(to, afterExtract));\n    });\n  });\n}\n\nfunction extract_from_local(from, to, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from);\n\n  function afterExtract(err, extractCount) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(to, afterExtract));\n}\n\nfunction extract(to, callback) {\n  var extractCount = 0;\n\n  function filter_func(entry) {\n    log.info('install', 'unpacking ' + entry.path);\n    extractCount++;\n  }\n\n  function afterTarball(err) {\n    callback(err, extractCount);\n  }\n\n  var tar = require('tar');\n\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry: filter_func\n  }).on('close', afterTarball).on('error', callback);\n}\n\nfunction do_build(gyp, argv, callback) {\n  var args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  var fallback_message = ' (falling back to source compile with node-gyp)';\n  var full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = \"Pre-built binaries not found for \" + package_json.name + \"@\" + package_json.version;\n    full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n    full_message += fallback_message;\n    log.warn(\"Tried to download(\" + err.statusCode + \"): \" + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = \"Pre-built binaries not installable for \" + package_json.name + \"@\" + package_json.version;\n    full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI, \" + opts.libc + \")\";\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn(\"Hit error \" + err.message);\n  }\n}\n\nfunction install(gyp, argv, callback) {\n  var package_json = JSON.parse(fs.readFileSync('./package.json'));\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  var should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    var should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      var match = cooked.indexOf(\"--fallback-to-build\");\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] == \"false\") {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    var opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    var from = opts.hosted_tarball;\n    var to = opts.module_path;\n    var binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, function (found) {\n      if (found && !update_binary) {\n        console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n        console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n        return callback();\n      } else {\n        if (!update_binary) log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n        mkdirp(to, function (err) {\n          if (err) {\n            after_place(err);\n          } else {\n            var fileName = from.startsWith('file://') && from.replace(/^file:\\/\\//, '');\n\n            if (fileName) {\n              extract_from_local(fileName, to, after_place);\n            } else {\n              place_binary(from, to, opts, after_place);\n            }\n          }\n        });\n      }\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}