{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  var inputParam = node.inputParams[paramName];\n\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    var start = inputParam.inputIndexStart;\n    var end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n    }\n\n    if (inputParam.type === 'tensors') {\n      var inputs = node.inputNames.slice(start, end);\n      return inputs.map(function (name) {\n        return getTensor(name, tensorMap, context, resourceManager);\n      });\n    }\n\n    var tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    var data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n\n  var attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\n\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  var _parseNodeName = parseNodeName(name),\n      _parseNodeName2 = _slicedToArray(_parseNodeName, 2),\n      nodeName = _parseNodeName2[0],\n      index = _parseNodeName2[1];\n\n  if (resourceManager != null) {\n    var tensor = resourceManager.getHashTableHandleByName(nodeName);\n\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n\n  var contextId = context.currentContextIds.find(function (contextId) {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\n\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\n\nexport function getNodeNameAndIndex(inputName, context) {\n  var _parseNodeName3 = parseNodeName(inputName),\n      _parseNodeName4 = _slicedToArray(_parseNodeName3, 2),\n      nodeName = _parseNodeName4[0],\n      index = _parseNodeName4[1];\n\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index];\n}\n\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? \"\".concat(name, \"-\").concat(contextId) : name;\n}\n\nexport function parseNodeName(name) {\n  var parts = name.split(':');\n\n  if (parts.length === 1) {\n    return [name, 0];\n  }\n\n  var nodeName = parts[0];\n  return [nodeName, Number(parts[parts.length - 1])];\n}\nexport function split(arr, size) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  var pad = getParamValue('pad', node, tensorMap, context);\n\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    var explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n\n    for (var i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n\n    return explicitPadding;\n  }\n\n  return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\n\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":null,"metadata":{},"sourceType":"module"}