{"ast":null,"code":"var readFile = require('fs').readFile,\n    basename = require('path').basename;\n\nexports.build = function (data, boundary, callback) {\n  if (typeof data != 'object' || typeof data.pipe == 'function') return callback(new Error('Multipart builder expects data as key/val object.'));\n  var body = '',\n      object = flatten(data),\n      count = Object.keys(object).length;\n  if (count === 0) return callback(new Error('Empty multipart body. Invalid data.'));\n\n  function done(err, section) {\n    if (err) return callback(err);\n    if (section) body += section;\n    --count || callback(null, body + '--' + boundary + '--');\n  }\n\n  ;\n\n  for (var key in object) {\n    var value = object[key];\n\n    if (value === null || typeof value == 'undefined') {\n      done();\n    } else if (Buffer.isBuffer(value)) {\n      var part = {\n        buffer: value,\n        content_type: 'application/octet-stream'\n      };\n      generate_part(key, part, boundary, done);\n    } else {\n      var part = value.buffer || value.file || value.content_type ? value : {\n        value: value\n      };\n      generate_part(key, part, boundary, done);\n    }\n  }\n};\n\nfunction generate_part(name, part, boundary, callback) {\n  var return_part = '--' + boundary + '\\r\\n';\n  return_part += 'Content-Disposition: form-data; name=\"' + name + '\"';\n\n  function append(data, filename) {\n    if (data) {\n      var binary = part.content_type.indexOf('text') == -1;\n      return_part += '; filename=\"' + encodeURIComponent(filename) + '\"\\r\\n';\n      if (binary) return_part += 'Content-Transfer-Encoding: binary\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type + '\\r\\n\\r\\n';\n      return_part += binary ? data.toString('binary') : data.toString('utf8');\n    }\n\n    callback(null, return_part + '\\r\\n');\n  }\n\n  ;\n\n  if ((part.file || part.buffer) && part.content_type) {\n    var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;\n    if (part.buffer) return append(part.buffer, filename);\n    readFile(part.file, function (err, data) {\n      if (err) return callback(err);\n      append(data, filename);\n    });\n  } else {\n    if (typeof part.value == 'object') return callback(new Error('Object received for ' + name + ', expected string.'));\n\n    if (part.content_type) {\n      return_part += '\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type;\n    }\n\n    return_part += '\\r\\n\\r\\n';\n    return_part += Buffer.from(String(part.value), 'utf8').toString('binary');\n    append();\n  }\n} // flattens nested objects for multipart body\n\n\nfunction flatten(object, into, prefix) {\n  into = into || {};\n\n  for (var key in object) {\n    var prefix_key = prefix ? prefix + '[' + key + ']' : key;\n    var prop = object[key];\n    if (prop && typeof prop === 'object' && !(prop.buffer || prop.file || prop.content_type)) flatten(prop, into, prefix_key);else into[prefix_key] = prop;\n  }\n\n  return into;\n}","map":null,"metadata":{},"sourceType":"script"}