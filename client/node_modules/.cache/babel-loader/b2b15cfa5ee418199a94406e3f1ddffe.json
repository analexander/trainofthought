{"ast":null,"code":"import _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\n\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(function () {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n\n\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n\n    var y;\n    var paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool( // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\n\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(function () {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // x is NDHWC after preprocessing.\n\n\n    x = preprocessConv3DInput(x, dataFormat);\n    var y;\n    var paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\n\nexport var Pooling1D = /*#__PURE__*/function (_Layer) {\n  _inherits(Pooling1D, _Layer);\n\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  function Pooling1D(args) {\n    var _this;\n\n    _classCallCheck(this, Pooling1D);\n\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pooling1D).call(this, args));\n\n    if (typeof args.poolSize === 'number') {\n      _this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      _this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\"poolSize for 1D convolutional layer must be a number or an \" + \"Array of a single number, but received \" + \"\".concat(JSON.stringify(args.poolSize)));\n    }\n\n    assertPositiveInteger(_this.poolSize, 'poolSize');\n\n    if (args.strides == null) {\n      _this.strides = _this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        _this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        _this.strides = args.strides;\n      } else {\n        throw new ValueError(\"strides for 1D convolutional layer must be a number or an \" + \"Array of a single number, but received \" + \"\".concat(JSON.stringify(args.strides)));\n      }\n    }\n\n    assertPositiveInteger(_this.strides, 'strides');\n    _this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(_this.padding);\n    _this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n    return _this;\n  }\n\n  _createClass(Pooling1D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n      return [inputShape[0], length, inputShape[2]];\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this2 = this;\n\n      return tidy(function () {\n        _this2.invokeCallHook(inputs, kwargs); // Add dummy last dimension.\n\n\n        inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n\n        var output = _this2.poolingFunction(getExactlyOneTensor(inputs), [_this2.poolSize[0], 1], [_this2.strides[0], 1], _this2.padding, 'channelsLast'); // Remove dummy last dimension.\n\n\n        return tfc.squeeze(output, [2]);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides\n      };\n\n      var baseConfig = _get(_getPrototypeOf(Pooling1D.prototype), \"getConfig\", this).call(this);\n\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n\n  return Pooling1D;\n}(Layer);\nexport var MaxPooling1D = /*#__PURE__*/function (_Pooling1D) {\n  _inherits(MaxPooling1D, _Pooling1D);\n\n  function MaxPooling1D(args) {\n    _classCallCheck(this, MaxPooling1D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaxPooling1D).call(this, args));\n  }\n\n  _createClass(MaxPooling1D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n\n  return MaxPooling1D;\n}(Pooling1D);\n/** @nocollapse */\n\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport var AveragePooling1D = /*#__PURE__*/function (_Pooling1D2) {\n  _inherits(AveragePooling1D, _Pooling1D2);\n\n  function AveragePooling1D(args) {\n    _classCallCheck(this, AveragePooling1D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AveragePooling1D).call(this, args));\n  }\n\n  _createClass(AveragePooling1D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n\n  return AveragePooling1D;\n}(Pooling1D);\n/** @nocollapse */\n\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\n\nexport var Pooling2D = /*#__PURE__*/function (_Layer2) {\n  _inherits(Pooling2D, _Layer2);\n\n  function Pooling2D(args) {\n    var _this3;\n\n    _classCallCheck(this, Pooling2D);\n\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Pooling2D).call(this, args));\n    _this3.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      _this3.strides = _this3.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\"If the strides property of a 2D pooling layer is an Array, \" + \"it is expected to have a length of 2, but received length \" + \"\".concat(args.strides.length, \".\"));\n      }\n\n      _this3.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      _this3.strides = [args.strides, args.strides];\n    }\n\n    assertPositiveInteger(_this3.poolSize, 'poolSize');\n    assertPositiveInteger(_this3.strides, 'strides');\n    _this3.padding = args.padding == null ? 'valid' : args.padding;\n    _this3.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this3.dataFormat);\n    checkPaddingMode(_this3.padding);\n    _this3.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n    return _this3;\n  }\n\n  _createClass(Pooling2D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n      var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n      rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n      cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n\n      if (this.dataFormat === 'channelsFirst') {\n        return [inputShape[0], inputShape[1], rows, cols];\n      } else {\n        return [inputShape[0], rows, cols, inputShape[3]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this4 = this;\n\n      return tidy(function () {\n        _this4.invokeCallHook(inputs, kwargs);\n\n        return _this4.poolingFunction(getExactlyOneTensor(inputs), _this4.poolSize, _this4.strides, _this4.padding, _this4.dataFormat);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides,\n        dataFormat: this.dataFormat\n      };\n\n      var baseConfig = _get(_getPrototypeOf(Pooling2D.prototype), \"getConfig\", this).call(this);\n\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n\n  return Pooling2D;\n}(Layer);\nexport var MaxPooling2D = /*#__PURE__*/function (_Pooling2D) {\n  _inherits(MaxPooling2D, _Pooling2D);\n\n  function MaxPooling2D(args) {\n    _classCallCheck(this, MaxPooling2D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaxPooling2D).call(this, args));\n  }\n\n  _createClass(MaxPooling2D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n\n  return MaxPooling2D;\n}(Pooling2D);\n/** @nocollapse */\n\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport var AveragePooling2D = /*#__PURE__*/function (_Pooling2D2) {\n  _inherits(AveragePooling2D, _Pooling2D2);\n\n  function AveragePooling2D(args) {\n    _classCallCheck(this, AveragePooling2D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AveragePooling2D).call(this, args));\n  }\n\n  _createClass(AveragePooling2D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n\n  return AveragePooling2D;\n}(Pooling2D);\n/** @nocollapse */\n\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\n\nexport var Pooling3D = /*#__PURE__*/function (_Layer3) {\n  _inherits(Pooling3D, _Layer3);\n\n  function Pooling3D(args) {\n    var _this5;\n\n    _classCallCheck(this, Pooling3D);\n\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Pooling3D).call(this, args));\n    _this5.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      _this5.strides = _this5.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\"If the strides property of a 3D pooling layer is an Array, \" + \"it is expected to have a length of 3, but received length \" + \"\".concat(args.strides.length, \".\"));\n      }\n\n      _this5.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      _this5.strides = [args.strides, args.strides, args.strides];\n    }\n\n    assertPositiveInteger(_this5.poolSize, 'poolSize');\n    assertPositiveInteger(_this5.strides, 'strides');\n    _this5.padding = args.padding == null ? 'valid' : args.padding;\n    _this5.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this5.dataFormat);\n    checkPaddingMode(_this5.padding);\n    _this5.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n    return _this5;\n  }\n\n  _createClass(Pooling3D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n      var rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n      var cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n      depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n      rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n      cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n\n      if (this.dataFormat === 'channelsFirst') {\n        return [inputShape[0], inputShape[1], depths, rows, cols];\n      } else {\n        return [inputShape[0], depths, rows, cols, inputShape[4]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this6 = this;\n\n      return tidy(function () {\n        _this6.invokeCallHook(inputs, kwargs);\n\n        return _this6.poolingFunction(getExactlyOneTensor(inputs), _this6.poolSize, _this6.strides, _this6.padding, _this6.dataFormat);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides,\n        dataFormat: this.dataFormat\n      };\n\n      var baseConfig = _get(_getPrototypeOf(Pooling3D.prototype), \"getConfig\", this).call(this);\n\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n\n  return Pooling3D;\n}(Layer);\nexport var MaxPooling3D = /*#__PURE__*/function (_Pooling3D) {\n  _inherits(MaxPooling3D, _Pooling3D);\n\n  function MaxPooling3D(args) {\n    _classCallCheck(this, MaxPooling3D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaxPooling3D).call(this, args));\n  }\n\n  _createClass(MaxPooling3D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n\n  return MaxPooling3D;\n}(Pooling3D);\n/** @nocollapse */\n\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport var AveragePooling3D = /*#__PURE__*/function (_Pooling3D2) {\n  _inherits(AveragePooling3D, _Pooling3D2);\n\n  function AveragePooling3D(args) {\n    _classCallCheck(this, AveragePooling3D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AveragePooling3D).call(this, args));\n  }\n\n  _createClass(AveragePooling3D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n\n  return AveragePooling3D;\n}(Pooling3D);\n/** @nocollapse */\n\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\n\nexport var GlobalPooling1D = /*#__PURE__*/function (_Layer4) {\n  _inherits(GlobalPooling1D, _Layer4);\n\n  function GlobalPooling1D(args) {\n    var _this7;\n\n    _classCallCheck(this, GlobalPooling1D);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(GlobalPooling1D).call(this, args));\n    _this7.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n    return _this7;\n  }\n\n  _createClass(GlobalPooling1D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      return [inputShape[0], inputShape[2]];\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      throw new NotImplementedError();\n    }\n  }]);\n\n  return GlobalPooling1D;\n}(Layer);\nexport var GlobalAveragePooling1D = /*#__PURE__*/function (_GlobalPooling1D) {\n  _inherits(GlobalAveragePooling1D, _GlobalPooling1D);\n\n  function GlobalAveragePooling1D(args) {\n    _classCallCheck(this, GlobalAveragePooling1D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GlobalAveragePooling1D).call(this, args || {}));\n  }\n\n  _createClass(GlobalAveragePooling1D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        return tfc.mean(input, 1);\n      });\n    }\n  }]);\n\n  return GlobalAveragePooling1D;\n}(GlobalPooling1D);\n/** @nocollapse */\n\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport var GlobalMaxPooling1D = /*#__PURE__*/function (_GlobalPooling1D2) {\n  _inherits(GlobalMaxPooling1D, _GlobalPooling1D2);\n\n  function GlobalMaxPooling1D(args) {\n    _classCallCheck(this, GlobalMaxPooling1D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GlobalMaxPooling1D).call(this, args || {}));\n  }\n\n  _createClass(GlobalMaxPooling1D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        return tfc.max(input, 1);\n      });\n    }\n  }]);\n\n  return GlobalMaxPooling1D;\n}(GlobalPooling1D);\n/** @nocollapse */\n\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\n\nexport var GlobalPooling2D = /*#__PURE__*/function (_Layer5) {\n  _inherits(GlobalPooling2D, _Layer5);\n\n  function GlobalPooling2D(args) {\n    var _this8;\n\n    _classCallCheck(this, GlobalPooling2D);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(GlobalPooling2D).call(this, args));\n    _this8.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this8.dataFormat);\n    _this8.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n    return _this8;\n  }\n\n  _createClass(GlobalPooling2D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = inputShape;\n\n      if (this.dataFormat === 'channelsLast') {\n        return [inputShape[0], inputShape[3]];\n      } else {\n        return [inputShape[0], inputShape[1]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      throw new NotImplementedError();\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        dataFormat: this.dataFormat\n      };\n\n      var baseConfig = _get(_getPrototypeOf(GlobalPooling2D.prototype), \"getConfig\", this).call(this);\n\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n\n  return GlobalPooling2D;\n}(Layer);\nexport var GlobalAveragePooling2D = /*#__PURE__*/function (_GlobalPooling2D) {\n  _inherits(GlobalAveragePooling2D, _GlobalPooling2D);\n\n  function GlobalAveragePooling2D() {\n    _classCallCheck(this, GlobalAveragePooling2D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GlobalAveragePooling2D).apply(this, arguments));\n  }\n\n  _createClass(GlobalAveragePooling2D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this9 = this;\n\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n\n        if (_this9.dataFormat === 'channelsLast') {\n          return tfc.mean(input, [1, 2]);\n        } else {\n          return tfc.mean(input, [2, 3]);\n        }\n      });\n    }\n  }]);\n\n  return GlobalAveragePooling2D;\n}(GlobalPooling2D);\n/** @nocollapse */\n\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport var GlobalMaxPooling2D = /*#__PURE__*/function (_GlobalPooling2D2) {\n  _inherits(GlobalMaxPooling2D, _GlobalPooling2D2);\n\n  function GlobalMaxPooling2D() {\n    _classCallCheck(this, GlobalMaxPooling2D);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GlobalMaxPooling2D).apply(this, arguments));\n  }\n\n  _createClass(GlobalMaxPooling2D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this10 = this;\n\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n\n        if (_this10.dataFormat === 'channelsLast') {\n          return tfc.max(input, [1, 2]);\n        } else {\n          return tfc.max(input, [2, 3]);\n        }\n      });\n    }\n  }]);\n\n  return GlobalMaxPooling2D;\n}(GlobalPooling2D);\n/** @nocollapse */\n\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":null,"metadata":{},"sourceType":"module"}