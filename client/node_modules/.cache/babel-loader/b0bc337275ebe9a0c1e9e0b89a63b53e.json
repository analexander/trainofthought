{"ast":null,"code":"\"use strict\";\n\nmodule.exports = exports = handle_gyp_opts;\n\nvar fs = require('fs');\n\nvar versioning = require('./versioning.js');\n\nvar napi = require('./napi.js');\n/*\n\nHere we gather node-pre-gyp generated options (from versioning) and pass them along to node-gyp.\n\nWe massage the args and options slightly to account for differences in what commands mean between\nnode-pre-gyp and node-gyp (e.g. see the difference between \"build\" and \"rebuild\" below)\n\nKeep in mind: the values inside `argv` and `gyp.opts` below are different depending on whether\nnode-pre-gyp is called directory, or if it is called in a `run-script` phase of npm.\n\nWe also try to preserve any command line options that might have been passed to npm or node-pre-gyp.\nBut this is fairly difficult without passing way to much through. For example `gyp.opts` contains all\nthe process.env and npm pushes a lot of variables into process.env which node-pre-gyp inherits. So we have\nto be very selective about what we pass through.\n\nFor example:\n\n`npm install --build-from-source` will give:\n\nargv == [ 'rebuild' ]\ngyp.opts.argv == { remain: [ 'install' ],\n  cooked: [ 'install', '--fallback-to-build' ],\n  original: [ 'install', '--fallback-to-build' ] }\n\n`./bin/node-pre-gyp build` will give:\n\nargv == []\ngyp.opts.argv == { remain: [ 'build' ],\n  cooked: [ 'build' ],\n  original: [ '-C', 'test/app1', 'build' ] }\n\n*/\n// select set of node-pre-gyp versioning info\n// to share with node-gyp\n\n\nvar share_with_node_gyp = ['module', 'module_name', 'module_path', 'napi_version', 'node_abi_napi', 'napi_build_version', 'node_napi_label'];\n\nfunction handle_gyp_opts(gyp, argv, callback) {\n  // Collect node-pre-gyp specific variables to pass to node-gyp\n  var node_pre_gyp_options = []; // generate custom node-pre-gyp versioning info\n\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var opts = versioning.evaluate(JSON.parse(fs.readFileSync('./package.json')), gyp.opts, napi_build_version);\n  share_with_node_gyp.forEach(function (key) {\n    var val = opts[key];\n\n    if (val) {\n      node_pre_gyp_options.push('--' + key + '=' + val);\n    } else if (key === 'napi_build_version') {\n      node_pre_gyp_options.push('--' + key + '=0');\n    } else {\n      if (key !== 'napi_version' && key !== 'node_abi_napi') return callback(new Error(\"Option \" + key + \" required but not found by node-pre-gyp\"));\n    }\n  }); // Collect options that follow the special -- which disables nopt parsing\n\n  var unparsed_options = [];\n  var double_hyphen_found = false;\n  gyp.opts.argv.original.forEach(function (opt) {\n    if (double_hyphen_found) {\n      unparsed_options.push(opt);\n    }\n\n    if (opt == '--') {\n      double_hyphen_found = true;\n    }\n  }); // We try respect and pass through remaining command\n  // line options (like --foo=bar) to node-gyp\n\n  var cooked = gyp.opts.argv.cooked;\n  var node_gyp_options = [];\n  cooked.forEach(function (value) {\n    if (value.length > 2 && value.slice(0, 2) == '--') {\n      var key = value.slice(2);\n      var val = cooked[cooked.indexOf(value) + 1];\n\n      if (val && val.indexOf('--') === -1) {\n        // handle '--foo=bar' or ['--foo','bar']\n        node_gyp_options.push('--' + key + '=' + val);\n      } else {\n        // pass through --foo\n        node_gyp_options.push(value);\n      }\n    }\n  });\n  var result = {\n    'opts': opts,\n    'gyp': node_gyp_options,\n    'pre': node_pre_gyp_options,\n    'unparsed': unparsed_options\n  };\n  return callback(null, result);\n}","map":null,"metadata":{},"sourceType":"script"}