{"ast":null,"code":"// info about each config option.\nvar debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG ? function () {\n  console.error.apply(console, arguments);\n} : function () {};\n\nvar url = require(\"url\"),\n    path = require(\"path\"),\n    Stream = require(\"stream\").Stream,\n    abbrev = require(\"abbrev\"),\n    osenv = require(\"osenv\");\n\nmodule.exports = exports = nopt;\nexports.clean = clean;\nexports.typeDefs = {\n  String: {\n    type: String,\n    validate: validateString\n  },\n  Boolean: {\n    type: Boolean,\n    validate: validateBoolean\n  },\n  url: {\n    type: url,\n    validate: validateUrl\n  },\n  Number: {\n    type: Number,\n    validate: validateNumber\n  },\n  path: {\n    type: path,\n    validate: validatePath\n  },\n  Stream: {\n    type: Stream,\n    validate: validateStream\n  },\n  Date: {\n    type: Date,\n    validate: validateDate\n  }\n};\n\nfunction nopt(types, shorthands, args, slice) {\n  args = args || process.argv;\n  types = types || {};\n  shorthands = shorthands || {};\n  if (typeof slice !== \"number\") slice = 2;\n  debug(types, shorthands, args, slice);\n  args = args.slice(slice);\n  var data = {},\n      key,\n      argv = {\n    remain: [],\n    cooked: args,\n    original: args.slice(0)\n  };\n  parse(args, data, argv.remain, types, shorthands); // now data is full\n\n  clean(data, types, exports.typeDefs);\n  data.argv = argv;\n  Object.defineProperty(data.argv, 'toString', {\n    value: function value() {\n      return this.original.map(JSON.stringify).join(\" \");\n    },\n    enumerable: false\n  });\n  return data;\n}\n\nfunction clean(data, types, typeDefs) {\n  typeDefs = typeDefs || exports.typeDefs;\n  var remove = {},\n      typeDefault = [false, true, null, String, Array];\n  Object.keys(data).forEach(function (k) {\n    if (k === \"argv\") return;\n    var val = data[k],\n        isArray = Array.isArray(val),\n        type = types[k];\n    if (!isArray) val = [val];\n    if (!type) type = typeDefault;\n    if (type === Array) type = typeDefault.concat(Array);\n    if (!Array.isArray(type)) type = [type];\n    debug(\"val=%j\", val);\n    debug(\"types=\", type);\n    val = val.map(function (val) {\n      // if it's an unknown value, then parse false/true/null/numbers/dates\n      if (typeof val === \"string\") {\n        debug(\"string %j\", val);\n        val = val.trim();\n\n        if (val === \"null\" && ~type.indexOf(null) || val === \"true\" && (~type.indexOf(true) || ~type.indexOf(Boolean)) || val === \"false\" && (~type.indexOf(false) || ~type.indexOf(Boolean))) {\n          val = JSON.parse(val);\n          debug(\"jsonable %j\", val);\n        } else if (~type.indexOf(Number) && !isNaN(val)) {\n          debug(\"convert to number\", val);\n          val = +val;\n        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {\n          debug(\"convert to date\", val);\n          val = new Date(val);\n        }\n      }\n\n      if (!types.hasOwnProperty(k)) {\n        return val;\n      } // allow `--no-blah` to set 'blah' to null if null is allowed\n\n\n      if (val === false && ~type.indexOf(null) && !(~type.indexOf(false) || ~type.indexOf(Boolean))) {\n        val = null;\n      }\n\n      var d = {};\n      d[k] = val;\n      debug(\"prevalidated val\", d, val, types[k]);\n\n      if (!validate(d, k, val, types[k], typeDefs)) {\n        if (exports.invalidHandler) {\n          exports.invalidHandler(k, val, types[k], data);\n        } else if (exports.invalidHandler !== false) {\n          debug(\"invalid: \" + k + \"=\" + val, types[k]);\n        }\n\n        return remove;\n      }\n\n      debug(\"validated val\", d, val, types[k]);\n      return d[k];\n    }).filter(function (val) {\n      return val !== remove;\n    }); // if we allow Array specifically, then an empty array is how we\n    // express 'no value here', not null.  Allow it.\n\n    if (!val.length && type.indexOf(Array) === -1) {\n      debug('VAL HAS NO LENGTH, DELETE IT', val, k, type.indexOf(Array));\n      delete data[k];\n    } else if (isArray) {\n      debug(isArray, data[k], val);\n      data[k] = val;\n    } else data[k] = val[0];\n\n    debug(\"k=%s val=%j\", k, val, data[k]);\n  });\n}\n\nfunction validateString(data, k, val) {\n  data[k] = String(val);\n}\n\nfunction validatePath(data, k, val) {\n  if (val === true) return false;\n  if (val === null) return true;\n  val = String(val);\n  var isWin = process.platform === 'win32',\n      homePattern = isWin ? /^~(\\/|\\\\)/ : /^~\\//,\n      home = osenv.home();\n\n  if (home && val.match(homePattern)) {\n    data[k] = path.resolve(home, val.substr(2));\n  } else {\n    data[k] = path.resolve(val);\n  }\n\n  return true;\n}\n\nfunction validateNumber(data, k, val) {\n  debug(\"validate Number %j %j %j\", k, val, isNaN(val));\n  if (isNaN(val)) return false;\n  data[k] = +val;\n}\n\nfunction validateDate(data, k, val) {\n  var s = Date.parse(val);\n  debug(\"validate Date %j %j %j\", k, val, s);\n  if (isNaN(s)) return false;\n  data[k] = new Date(val);\n}\n\nfunction validateBoolean(data, k, val) {\n  if (val instanceof Boolean) val = val.valueOf();else if (typeof val === \"string\") {\n    if (!isNaN(val)) val = !!+val;else if (val === \"null\" || val === \"false\") val = false;else val = true;\n  } else val = !!val;\n  data[k] = val;\n}\n\nfunction validateUrl(data, k, val) {\n  val = url.parse(String(val));\n  if (!val.host) return false;\n  data[k] = val.href;\n}\n\nfunction validateStream(data, k, val) {\n  if (!(val instanceof Stream)) return false;\n  data[k] = val;\n}\n\nfunction validate(data, k, val, type, typeDefs) {\n  // arrays are lists of types.\n  if (Array.isArray(type)) {\n    for (var i = 0, l = type.length; i < l; i++) {\n      if (type[i] === Array) continue;\n      if (validate(data, k, val, type[i], typeDefs)) return true;\n    }\n\n    delete data[k];\n    return false;\n  } // an array of anything?\n\n\n  if (type === Array) return true; // NaN is poisonous.  Means that something is not allowed.\n\n  if (type !== type) {\n    debug(\"Poison NaN\", k, val, type);\n    delete data[k];\n    return false;\n  } // explicit list of values\n\n\n  if (val === type) {\n    debug(\"Explicitly allowed %j\", val); // if (isArray) (data[k] = data[k] || []).push(val)\n    // else data[k] = val\n\n    data[k] = val;\n    return true;\n  } // now go through the list of typeDefs, validate against each one.\n\n\n  var ok = false,\n      types = Object.keys(typeDefs);\n\n  for (var i = 0, l = types.length; i < l; i++) {\n    debug(\"test type %j %j %j\", k, val, types[i]);\n    var t = typeDefs[types[i]];\n\n    if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {\n      var d = {};\n      ok = false !== t.validate(d, k, val);\n      val = d[k];\n\n      if (ok) {\n        // if (isArray) (data[k] = data[k] || []).push(val)\n        // else data[k] = val\n        data[k] = val;\n        break;\n      }\n    }\n  }\n\n  debug(\"OK? %j (%j %j %j)\", ok, k, val, types[i]);\n  if (!ok) delete data[k];\n  return ok;\n}\n\nfunction parse(args, data, remain, types, shorthands) {\n  debug(\"parse\", args, data, remain);\n  var key = null,\n      abbrevs = abbrev(Object.keys(types)),\n      shortAbbr = abbrev(Object.keys(shorthands));\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    debug(\"arg\", arg);\n\n    if (arg.match(/^-{2,}$/)) {\n      // done with keys.\n      // the rest are args.\n      remain.push.apply(remain, args.slice(i + 1));\n      args[i] = \"--\";\n      break;\n    }\n\n    var hadEq = false;\n\n    if (arg.charAt(0) === \"-\" && arg.length > 1) {\n      var at = arg.indexOf('=');\n\n      if (at > -1) {\n        hadEq = true;\n        var v = arg.substr(at + 1);\n        arg = arg.substr(0, at);\n        args.splice(i, 1, arg, v);\n      } // see if it's a shorthand\n      // if so, splice and back up to re-parse it.\n\n\n      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);\n      debug(\"arg=%j shRes=%j\", arg, shRes);\n\n      if (shRes) {\n        debug(arg, shRes);\n        args.splice.apply(args, [i, 1].concat(shRes));\n\n        if (arg !== shRes[0]) {\n          i--;\n          continue;\n        }\n      }\n\n      arg = arg.replace(/^-+/, \"\");\n      var no = null;\n\n      while (arg.toLowerCase().indexOf(\"no-\") === 0) {\n        no = !no;\n        arg = arg.substr(3);\n      }\n\n      if (abbrevs[arg]) arg = abbrevs[arg];\n      var argType = types[arg];\n      var isTypeArray = Array.isArray(argType);\n\n      if (isTypeArray && argType.length === 1) {\n        isTypeArray = false;\n        argType = argType[0];\n      }\n\n      var isArray = argType === Array || isTypeArray && argType.indexOf(Array) !== -1; // allow unknown things to be arrays if specified multiple times.\n\n      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {\n        if (!Array.isArray(data[arg])) data[arg] = [data[arg]];\n        isArray = true;\n      }\n\n      var val,\n          la = args[i + 1];\n      var isBool = typeof no === 'boolean' || argType === Boolean || isTypeArray && argType.indexOf(Boolean) !== -1 || typeof argType === 'undefined' && !hadEq || la === \"false\" && (argType === null || isTypeArray && ~argType.indexOf(null));\n\n      if (isBool) {\n        // just set and move along\n        val = !no; // however, also support --bool true or --bool false\n\n        if (la === \"true\" || la === \"false\") {\n          val = JSON.parse(la);\n          la = null;\n          if (no) val = !val;\n          i++;\n        } // also support \"foo\":[Boolean, \"bar\"] and \"--foo bar\"\n\n\n        if (isTypeArray && la) {\n          if (~argType.indexOf(la)) {\n            // an explicit type\n            val = la;\n            i++;\n          } else if (la === \"null\" && ~argType.indexOf(null)) {\n            // null allowed\n            val = null;\n            i++;\n          } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~argType.indexOf(Number)) {\n            // number\n            val = +la;\n            i++;\n          } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {\n            // string\n            val = la;\n            i++;\n          }\n        }\n\n        if (isArray) (data[arg] = data[arg] || []).push(val);else data[arg] = val;\n        continue;\n      }\n\n      if (argType === String) {\n        if (la === undefined) {\n          la = \"\";\n        } else if (la.match(/^-{1,2}[^-]+/)) {\n          la = \"\";\n          i--;\n        }\n      }\n\n      if (la && la.match(/^-{2,}$/)) {\n        la = undefined;\n        i--;\n      }\n\n      val = la === undefined ? true : la;\n      if (isArray) (data[arg] = data[arg] || []).push(val);else data[arg] = val;\n      i++;\n      continue;\n    }\n\n    remain.push(arg);\n  }\n}\n\nfunction resolveShort(arg, shorthands, shortAbbr, abbrevs) {\n  // handle single-char shorthands glommed together, like\n  // npm ls -glp, but only if there is one dash, and only if\n  // all of the chars are single-char shorthands, and it's\n  // not a match to some other abbrev.\n  arg = arg.replace(/^-+/, ''); // if it's an exact known option, then don't go any further\n\n  if (abbrevs[arg] === arg) return null; // if it's an exact known shortopt, same deal\n\n  if (shorthands[arg]) {\n    // make it an array, if it's a list of words\n    if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\\s+/);\n    return shorthands[arg];\n  } // first check to see if this arg is a set of single-char shorthands\n\n\n  var singles = shorthands.___singles;\n\n  if (!singles) {\n    singles = Object.keys(shorthands).filter(function (s) {\n      return s.length === 1;\n    }).reduce(function (l, r) {\n      l[r] = true;\n      return l;\n    }, {});\n    shorthands.___singles = singles;\n    debug('shorthand singles', singles);\n  }\n\n  var chrs = arg.split(\"\").filter(function (c) {\n    return singles[c];\n  });\n  if (chrs.join(\"\") === arg) return chrs.map(function (c) {\n    return shorthands[c];\n  }).reduce(function (l, r) {\n    return l.concat(r);\n  }, []); // if it's an arg abbrev, and not a literal shorthand, then prefer the arg\n\n  if (abbrevs[arg] && !shorthands[arg]) return null; // if it's an abbr for a shorthand, then use that\n\n  if (shortAbbr[arg]) arg = shortAbbr[arg]; // make it an array, if it's a list of words\n\n  if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\\s+/);\n  return shorthands[arg];\n}","map":null,"metadata":{},"sourceType":"script"}