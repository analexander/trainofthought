{"ast":null,"code":"import _regeneratorRuntime from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { FileChunkIterator } from './file_chunk_iterator';\n/**\n * Provide a stream of chunks from a URL.\n *\n * Note this class first downloads the entire file into memory before providing\n * the first element from the stream.  This is because the Fetch API does not\n * yet reliably provide a reader stream for the response body.\n */\n\nexport function urlChunkIterator(_x) {\n  return _urlChunkIterator.apply(this, arguments);\n} // Generate RequestInit from Request to match tf.util.fetch signature.\n\nfunction _urlChunkIterator() {\n  _urlChunkIterator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n    var options,\n        urlString,\n        requestInit,\n        response,\n        uint8Array,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n            if (typeof url === 'string') {\n              urlString = url;\n            } else {\n              urlString = url.url;\n              requestInit = getRequestInitFromRequest(url);\n            }\n\n            _context.next = 4;\n            return util.fetch(urlString, requestInit);\n\n          case 4:\n            response = _context.sent;\n\n            if (!response.ok) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.t0 = Uint8Array;\n            _context.next = 9;\n            return response.arrayBuffer();\n\n          case 9:\n            _context.t1 = _context.sent;\n            uint8Array = new _context.t0(_context.t1);\n            return _context.abrupt(\"return\", new FileChunkIterator(uint8Array, options));\n\n          case 14:\n            throw new Error(response.statusText);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _urlChunkIterator.apply(this, arguments);\n}\n\nvar getRequestInitFromRequest = function getRequestInitFromRequest(request) {\n  var init = {\n    method: request.method,\n    headers: request.headers,\n    body: request.body,\n    mode: request.mode,\n    credentials: request.credentials,\n    cache: request.cache,\n    redirect: request.redirect,\n    referrer: request.referrer,\n    integrity: request.integrity\n  };\n  return init;\n};","map":null,"metadata":{},"sourceType":"module"}