{"ast":null,"code":"import * as tf from '@tensorflow/tfjs-core';\n/**\r\n * Pads the smaller dimension of an image tensor with zeros, such that width === height.\r\n *\r\n * @param imgTensor The image tensor.\r\n * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n * both sides of the minor dimension oof the image.\r\n * @returns The padded tensor with width === height.\r\n */\n\nexport function padToSquare(imgTensor, isCenterImage) {\n  if (isCenterImage === void 0) {\n    isCenterImage = false;\n  }\n\n  return tf.tidy(function () {\n    var _a = imgTensor.shape.slice(1),\n        height = _a[0],\n        width = _a[1];\n\n    if (height === width) {\n      return imgTensor;\n    }\n\n    var dimDiff = Math.abs(height - width);\n    var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));\n    var paddingAxis = height > width ? 2 : 1;\n\n    var createPaddingTensor = function createPaddingTensor(paddingAmount) {\n      var paddingTensorShape = imgTensor.shape.slice();\n      paddingTensorShape[paddingAxis] = paddingAmount;\n      return tf.fill(paddingTensorShape, 0);\n    };\n\n    var paddingTensorAppend = createPaddingTensor(paddingAmount);\n    var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];\n    var paddingTensorPrepend = isCenterImage && remainingPaddingAmount ? createPaddingTensor(remainingPaddingAmount) : null;\n    var tensorsToStack = [paddingTensorPrepend, imgTensor, paddingTensorAppend].filter(function (t) {\n      return !!t;\n    }).map(function (t) {\n      return t.toFloat();\n    });\n    return tf.concat(tensorsToStack, paddingAxis);\n  });\n}","map":{"version":3,"sources":["../../../src/ops/padToSquare.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAZ,MAAoB,uBAApB;AAEA;;;;;;;AAOG;;AACH,OAAM,SAAU,WAAV,CACJ,SADI,EAEJ,aAFI,EAE0B;AAA9B,MAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,aAAA,GAAA,KAAA;AAA8B;;AAE9B,SAAO,EAAE,CAAC,IAAH,CAAQ,YAAA;AAEP,QAAA,EAAA,GAAA,SAAA,CAAA,KAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAC,MAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,QAAS,KAAA,GAAA,EAAA,CAAA,CAAA,CAAT;;AACN,QAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,aAAO,SAAP;AACD;;AAED,QAAM,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,GAAG,KAAlB,CAAhB;AACA,QAAM,aAAa,GAAG,IAAI,CAAC,KAAL,CAAW,OAAO,IAAI,aAAa,GAAG,GAAH,GAAS,CAA1B,CAAlB,CAAtB;AACA,QAAM,WAAW,GAAG,MAAM,GAAG,KAAT,GAAiB,CAAjB,GAAqB,CAAzC;;AAEA,QAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,aAAD,EAAsB;AAChD,UAAM,kBAAkB,GAAG,SAAS,CAAC,KAAV,CAAgB,KAAhB,EAA3B;AACA,MAAA,kBAAkB,CAAC,WAAD,CAAlB,GAAkC,aAAlC;AACA,aAAO,EAAE,CAAC,IAAH,CAAQ,kBAAR,EAA4B,CAA5B,CAAP;AACD,KAJD;;AAMA,QAAM,mBAAmB,GAAG,mBAAmB,CAAC,aAAD,CAA/C;AACA,QAAM,sBAAsB,GAAG,OAAO,GAAI,mBAAmB,CAAC,KAApB,CAA0B,WAA1B,CAA1C;AAEA,QAAM,oBAAoB,GAAG,aAAa,IAAI,sBAAjB,GACzB,mBAAmB,CAAC,sBAAD,CADM,GAEzB,IAFJ;AAIA,QAAM,cAAc,GAAG,CACrB,oBADqB,EAErB,SAFqB,EAGrB,mBAHqB,EAKpB,MALoB,CAKb,UAAA,CAAA,EAAC;AAAI,aAAA,CAAC,CAAD,CAAA;AAAG,KALK,EAMpB,GANoB,CAMhB,UAAC,CAAD,EAAa;AAAK,aAAA,CAAC,CAAD,OAAA,EAAA;AAAW,KANb,CAAvB;AAOA,WAAO,EAAE,CAAC,MAAH,CAAU,cAAV,EAA0B,WAA1B,CAAP;AACD,GAhCM,CAAP;AAiCD","sourceRoot":"","sourcesContent":["import * as tf from '@tensorflow/tfjs-core';\r\n/**\r\n * Pads the smaller dimension of an image tensor with zeros, such that width === height.\r\n *\r\n * @param imgTensor The image tensor.\r\n * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n * both sides of the minor dimension oof the image.\r\n * @returns The padded tensor with width === height.\r\n */\r\nexport function padToSquare(imgTensor, isCenterImage) {\r\n    if (isCenterImage === void 0) { isCenterImage = false; }\r\n    return tf.tidy(function () {\r\n        var _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\r\n        if (height === width) {\r\n            return imgTensor;\r\n        }\r\n        var dimDiff = Math.abs(height - width);\r\n        var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));\r\n        var paddingAxis = height > width ? 2 : 1;\r\n        var createPaddingTensor = function (paddingAmount) {\r\n            var paddingTensorShape = imgTensor.shape.slice();\r\n            paddingTensorShape[paddingAxis] = paddingAmount;\r\n            return tf.fill(paddingTensorShape, 0);\r\n        };\r\n        var paddingTensorAppend = createPaddingTensor(paddingAmount);\r\n        var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];\r\n        var paddingTensorPrepend = isCenterImage && remainingPaddingAmount\r\n            ? createPaddingTensor(remainingPaddingAmount)\r\n            : null;\r\n        var tensorsToStack = [\r\n            paddingTensorPrepend,\r\n            imgTensor,\r\n            paddingTensorAppend\r\n        ]\r\n            .filter(function (t) { return !!t; })\r\n            .map(function (t) { return t.toFloat(); });\r\n        return tf.concat(tensorsToStack, paddingAxis);\r\n    });\r\n}\r\n//# sourceMappingURL=padToSquare.js.map"]},"metadata":{},"sourceType":"module"}