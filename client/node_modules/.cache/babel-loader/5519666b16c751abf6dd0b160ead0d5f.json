{"ast":null,"code":"import _toConsumableArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat as _concat, keep, reshape, scalar, slice, stack, tensor, tidy, unstack } from '@tensorflow/tfjs-core';\nimport { assertShapesMatchAllowUndefinedSize } from './tensor_utils';\n/**\n * The TensorArray object keeps an array of Tensors.  It\n * allows reading from the array and writing to the array.\n */\n\nexport var TensorArray = /*#__PURE__*/function () {\n  function TensorArray(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {\n    _classCallCheck(this, TensorArray);\n\n    this.name = name;\n    this.dtype = dtype;\n    this.maxSize = maxSize;\n    this.elementShape = elementShape;\n    this.identicalElementShapes = identicalElementShapes;\n    this.dynamicSize = dynamicSize;\n    this.clearAfterRead = clearAfterRead;\n    this.tensors = [];\n    this.closed_ = false;\n    this.idTensor = scalar(0);\n    keep(this.idTensor);\n  }\n\n  _createClass(TensorArray, [{\n    key: \"clearAndClose\",\n\n    /**\n     * Dispose the tensors and idTensor and mark the TensoryArray as closed.\n     */\n    value: function clearAndClose(keepIds) {\n      this.tensors.forEach(function (tensor) {\n        if (keepIds == null || !keepIds.has(tensor.tensor.id)) {\n          tensor.tensor.dispose();\n        }\n      });\n      this.tensors = [];\n      this.closed_ = true;\n      this.idTensor.dispose();\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.tensors.length;\n    }\n    /**\n     * Read the value at location index in the TensorArray.\n     * @param index Number the index to read from.\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(index) {\n      if (this.closed_) {\n        throw new Error(\"TensorArray \".concat(this.name, \" has already been closed.\"));\n      }\n\n      if (index < 0 || index >= this.size()) {\n        throw new Error(\"Tried to read from index \".concat(index, \", but array size is: \").concat(this.size()));\n      }\n\n      var tensorWithState = this.tensors[index];\n\n      if (tensorWithState.cleared) {\n        throw new Error(\"TensorArray \".concat(this.name, \": Could not read index \").concat(index, \" twice because it was cleared after a previous read \") + \"(perhaps try setting clear_after_read = false?).\");\n      }\n\n      if (this.clearAfterRead) {\n        tensorWithState.cleared = true;\n      }\n\n      tensorWithState.read = true;\n      return tensorWithState.tensor;\n    }\n    /**\n     * Helper method to read multiple tensors from the specified indices.\n     */\n\n  }, {\n    key: \"readMany\",\n    value: function readMany(indices) {\n      var _this = this;\n\n      return indices.map(function (index) {\n        return _this.read(index);\n      });\n    }\n    /**\n     * Write value into the index of the TensorArray.\n     * @param index number the index to write to.\n     * @param tensor\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(index, tensor) {\n      if (this.closed_) {\n        throw new Error(\"TensorArray \".concat(this.name, \" has already been closed.\"));\n      }\n\n      if (index < 0 || !this.dynamicSize && index >= this.maxSize) {\n        throw new Error(\"Tried to write to index \".concat(index, \", but array is not resizeable and size is: \").concat(this.maxSize));\n      }\n\n      var t = this.tensors[index] || {};\n\n      if (tensor.dtype !== this.dtype) {\n        throw new Error(\"TensorArray \".concat(this.name, \": Could not write to TensorArray index \").concat(index, \",\\n          because the value dtype is \").concat(tensor.dtype, \", but TensorArray dtype is \").concat(this.dtype, \".\"));\n      } // Set the shape for the first time write to unknow shape tensor array\n\n\n      if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {\n        this.elementShape = tensor.shape;\n      }\n\n      assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, \"TensorArray \".concat(this.name, \": Could not write to TensorArray index \").concat(index, \".\"));\n\n      if (t.read) {\n        throw new Error(\"TensorArray \".concat(this.name, \": Could not write to TensorArray index \").concat(index, \", because it has already been read.\"));\n      }\n\n      if (t.written) {\n        throw new Error(\"TensorArray \".concat(this.name, \": Could not write to TensorArray index \").concat(index, \", because it has already been written.\"));\n      }\n\n      t.tensor = tensor;\n      keep(tensor);\n      t.written = true;\n      this.tensors[index] = t;\n    }\n    /**\n     * Helper method to write multiple tensors to the specified indices.\n     */\n\n  }, {\n    key: \"writeMany\",\n    value: function writeMany(indices, tensors) {\n      var _this2 = this;\n\n      if (indices.length !== tensors.length) {\n        throw new Error(\"TensorArray \".concat(this.name, \": could not write multiple tensors,\") + \"because the index size: \".concat(indices.length, \" is not the same as tensors size: \").concat(tensors.length, \".\"));\n      }\n\n      indices.forEach(function (i, index) {\n        return _this2.write(i, tensors[index]);\n      });\n    }\n    /**\n     * Return selected values in the TensorArray as a packed Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param [indices] number[] Optional. Taking values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size(). If not specified returns\n     *    all tensors in the original order.\n     * @param [dtype]\n     */\n\n  }, {\n    key: \"gather\",\n    value: function gather(indices, dtype) {\n      if (!!dtype && dtype !== this.dtype) {\n        throw new Error(\"TensorArray dtype is \".concat(this.dtype, \" but gather requested dtype \").concat(dtype));\n      }\n\n      if (!indices) {\n        indices = [];\n\n        for (var i = 0; i < this.size(); i++) {\n          indices.push(i);\n        }\n      } else {\n        indices = indices.slice(0, this.size());\n      }\n\n      if (indices.length === 0) {\n        return tensor([], [0].concat(this.elementShape));\n      } // Read all the PersistentTensors into a vector to keep track of\n      // their memory.\n\n\n      var tensors = this.readMany(indices);\n      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, 'TensorArray shape mismatch: ');\n      return stack(tensors, 0);\n    }\n    /**\n     * Return the values in the TensorArray as a concatenated Tensor.\n     */\n\n  }, {\n    key: \"concat\",\n    value: function concat(dtype) {\n      if (!!dtype && dtype !== this.dtype) {\n        throw new Error(\"TensorArray dtype is \".concat(this.dtype, \" but concat requested dtype \").concat(dtype));\n      }\n\n      if (this.size() === 0) {\n        return tensor([], [0].concat(this.elementShape));\n      }\n\n      var indices = [];\n\n      for (var i = 0; i < this.size(); i++) {\n        indices.push(i);\n      } // Collect all the tensors from the tensors array.\n\n\n      var tensors = this.readMany(indices);\n      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, \"TensorArray shape mismatch: tensor array shape (\".concat(this.elementShape, \") vs first tensor shape (\").concat(tensors[0].shape, \")\"));\n      return _concat(tensors, 0);\n    }\n    /**\n     * Scatter the values of a Tensor in specific indices of a TensorArray.\n     * @param indices nummber[] values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size().\n     * @param tensor Tensor input tensor.\n     */\n\n  }, {\n    key: \"scatter\",\n    value: function scatter(indices, tensor) {\n      if (tensor.dtype !== this.dtype) {\n        throw new Error(\"TensorArray dtype is \".concat(this.dtype, \" but tensor has dtype \").concat(tensor.dtype));\n      }\n\n      if (indices.length !== tensor.shape[0]) {\n        throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \".concat(indices.length, \" vs. \").concat(tensor.shape[0]));\n      }\n\n      var maxIndex = Math.max.apply(Math, _toConsumableArray(indices));\n\n      if (!this.dynamicSize && maxIndex >= this.maxSize) {\n        throw new Error(\"Max index must be < array size (\".concat(maxIndex, \"  vs. \").concat(this.maxSize, \")\"));\n      }\n\n      this.writeMany(indices, unstack(tensor, 0));\n    }\n    /**\n     * Split the values of a Tensor into the TensorArray.\n     * @param length number[] with the lengths to use when splitting value along\n     *    its first dimension.\n     * @param tensor Tensor, the tensor to split.\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(length, tensor) {\n      var _this3 = this;\n\n      if (tensor.dtype !== this.dtype) {\n        throw new Error(\"TensorArray dtype is \".concat(this.dtype, \" but tensor has dtype \").concat(tensor.dtype));\n      }\n\n      var totalLength = 0;\n      var cumulativeLengths = length.map(function (len) {\n        totalLength += len;\n        return totalLength;\n      });\n\n      if (totalLength !== tensor.shape[0]) {\n        throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \".concat(totalLength, \", and tensor's shape is: \").concat(tensor.shape));\n      }\n\n      if (!this.dynamicSize && length.length !== this.maxSize) {\n        throw new Error(\"TensorArray's size is not equal to the size of lengths (\".concat(this.maxSize, \" vs. \").concat(length.length, \"), \") + 'and the TensorArray is not marked as dynamically resizeable');\n      }\n\n      var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n      var tensors = [];\n      tidy(function () {\n        tensor = reshape(tensor, [1, totalLength, elementPerRow]);\n\n        for (var i = 0; i < length.length; ++i) {\n          var previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];\n          var _indices = [0, previousLength, 0];\n          var sizes = [1, length[i], elementPerRow];\n          tensors[i] = reshape(slice(tensor, _indices, sizes), _this3.elementShape);\n        }\n\n        return tensors;\n      });\n      var indices = [];\n\n      for (var i = 0; i < length.length; i++) {\n        indices[i] = i;\n      }\n\n      this.writeMany(indices, tensors);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.idTensor.id;\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this.closed_;\n    }\n  }]);\n\n  return TensorArray;\n}();","map":null,"metadata":{},"sourceType":"module"}