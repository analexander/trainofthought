{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar EE = require('events').EventEmitter;\n\nvar Minimatch = require('minimatch').Minimatch;\n\nvar Walker = /*#__PURE__*/function (_EE) {\n  _inherits(Walker, _EE);\n\n  function Walker(opts) {\n    var _this;\n\n    _classCallCheck(this, Walker);\n\n    opts = opts || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Walker).call(this, opts));\n    _this.path = opts.path || process.cwd();\n    _this.basename = path.basename(_this.path);\n    _this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    _this.ignoreRules = {};\n    _this.parent = opts.parent || null;\n    _this.includeEmpty = !!opts.includeEmpty;\n    _this.root = _this.parent ? _this.parent.root : _this.path;\n    _this.follow = !!opts.follow;\n    _this.result = _this.parent ? _this.parent.result : new Set();\n    _this.entries = null;\n    _this.sawError = false;\n    return _this;\n  }\n\n  _createClass(Walker, [{\n    key: \"sort\",\n    value: function sort(a, b) {\n      return a.localeCompare(b);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      var ret = false;\n\n      if (!(this.sawError && ev === 'error')) {\n        if (ev === 'error') this.sawError = true;else if (ev === 'done' && !this.parent) {\n          data = Array.from(data).map(function (e) {\n            return /^@/.test(e) ? \"./\".concat(e) : e;\n          }).sort(this.sort);\n          this.result = data;\n        }\n        if (ev === 'error' && this.parent) ret = this.parent.emit('error', data);else ret = _get(_getPrototypeOf(Walker.prototype), \"emit\", this).call(this, ev, data);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      fs.readdir(this.path, function (er, entries) {\n        return er ? _this2.emit('error', er) : _this2.onReaddir(entries);\n      });\n      return this;\n    }\n  }, {\n    key: \"isIgnoreFile\",\n    value: function isIgnoreFile(e) {\n      return e !== \".\" && e !== \"..\" && -1 !== this.ignoreFiles.indexOf(e);\n    }\n  }, {\n    key: \"onReaddir\",\n    value: function onReaddir(entries) {\n      var _this3 = this;\n\n      this.entries = entries;\n\n      if (entries.length === 0) {\n        if (this.includeEmpty) this.result.add(this.path.substr(this.root.length + 1));\n        this.emit('done', this.result);\n      } else {\n        var hasIg = this.entries.some(function (e) {\n          return _this3.isIgnoreFile(e);\n        });\n        if (hasIg) this.addIgnoreFiles();else this.filterEntries();\n      }\n    }\n  }, {\n    key: \"addIgnoreFiles\",\n    value: function addIgnoreFiles() {\n      var _this4 = this;\n\n      var newIg = this.entries.filter(function (e) {\n        return _this4.isIgnoreFile(e);\n      });\n      var igCount = newIg.length;\n\n      var then = function then(_) {\n        if (--igCount === 0) _this4.filterEntries();\n      };\n\n      newIg.forEach(function (e) {\n        return _this4.addIgnoreFile(e, then);\n      });\n    }\n  }, {\n    key: \"addIgnoreFile\",\n    value: function addIgnoreFile(file, then) {\n      var _this5 = this;\n\n      var ig = path.resolve(this.path, file);\n      fs.readFile(ig, 'utf8', function (er, data) {\n        return er ? _this5.emit('error', er) : _this5.onReadIgnoreFile(file, data, then);\n      });\n    }\n  }, {\n    key: \"onReadIgnoreFile\",\n    value: function onReadIgnoreFile(file, data, then) {\n      var mmopt = {\n        matchBase: true,\n        dot: true,\n        flipNegate: true,\n        nocase: true\n      };\n      var rules = data.split(/\\r?\\n/).filter(function (line) {\n        return !/^#|^$/.test(line.trim());\n      }).map(function (r) {\n        return new Minimatch(r, mmopt);\n      });\n      this.ignoreRules[file] = rules;\n      then();\n    }\n  }, {\n    key: \"filterEntries\",\n    value: function filterEntries() {\n      var _this6 = this;\n\n      // at this point we either have ignore rules, or just inheriting\n      // this exclusion is at the point where we know the list of\n      // entries in the dir, but don't know what they are.  since\n      // some of them *might* be directories, we have to run the\n      // match in dir-mode as well, so that we'll pick up partials\n      // of files that will be included later.  Anything included\n      // at this point will be checked again later once we know\n      // what it is.\n      var filtered = this.entries.map(function (entry) {\n        // at this point, we don't know if it's a dir or not.\n        var passFile = _this6.filterEntry(entry);\n\n        var passDir = _this6.filterEntry(entry, true);\n\n        return passFile || passDir ? [entry, passFile, passDir] : false;\n      }).filter(function (e) {\n        return e;\n      }); // now we stat them all\n      // if it's a dir, and passes as a dir, then recurse\n      // if it's not a dir, but passes as a file, add to set\n\n      var entryCount = filtered.length;\n\n      if (entryCount === 0) {\n        this.emit('done', this.result);\n      } else {\n        var then = function then(_) {\n          if (--entryCount === 0) _this6.emit('done', _this6.result);\n        };\n\n        filtered.forEach(function (filt) {\n          var entry = filt[0];\n          var file = filt[1];\n          var dir = filt[2];\n\n          _this6.stat(entry, file, dir, then);\n        });\n      }\n    }\n  }, {\n    key: \"onstat\",\n    value: function onstat(st, entry, file, dir, then) {\n      var abs = this.path + '/' + entry;\n\n      if (!st.isDirectory()) {\n        if (file) this.result.add(abs.substr(this.root.length + 1));\n        then();\n      } else {\n        // is a directory\n        if (dir) this.walker(entry, then);else then();\n      }\n    }\n  }, {\n    key: \"stat\",\n    value: function stat(entry, file, dir, then) {\n      var _this7 = this;\n\n      var abs = this.path + '/' + entry;\n      fs[this.follow ? 'stat' : 'lstat'](abs, function (er, st) {\n        if (er) _this7.emit('error', er);else _this7.onstat(st, entry, file, dir, then);\n      });\n    }\n  }, {\n    key: \"walkerOpt\",\n    value: function walkerOpt(entry) {\n      return {\n        path: this.path + '/' + entry,\n        parent: this,\n        ignoreFiles: this.ignoreFiles,\n        follow: this.follow,\n        includeEmpty: this.includeEmpty\n      };\n    }\n  }, {\n    key: \"walker\",\n    value: function walker(entry, then) {\n      new Walker(this.walkerOpt(entry)).on('done', then).start();\n    }\n  }, {\n    key: \"filterEntry\",\n    value: function filterEntry(entry, partial) {\n      var _this8 = this;\n\n      var included = true; // this = /a/b/c\n      // entry = d\n      // parent /a/b sees c/d\n\n      if (this.parent && this.parent.filterEntry) {\n        var pt = this.basename + \"/\" + entry;\n        included = this.parent.filterEntry(pt, partial);\n      }\n\n      this.ignoreFiles.forEach(function (f) {\n        if (_this8.ignoreRules[f]) {\n          _this8.ignoreRules[f].forEach(function (rule) {\n            // negation means inclusion\n            // so if it's negated, and already included, no need to check\n            // likewise if it's neither negated nor included\n            if (rule.negate !== included) {\n              // first, match against /foo/bar\n              // then, against foo/bar\n              // then, in the case of partials, match with a /\n              var match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n              if (match) included = rule.negate;\n            }\n          });\n        }\n      });\n      return included;\n    }\n  }]);\n\n  return Walker;\n}(EE);\n\nvar WalkerSync = /*#__PURE__*/function (_Walker) {\n  _inherits(WalkerSync, _Walker);\n\n  function WalkerSync(opt) {\n    _classCallCheck(this, WalkerSync);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WalkerSync).call(this, opt));\n  }\n\n  _createClass(WalkerSync, [{\n    key: \"start\",\n    value: function start() {\n      this.onReaddir(fs.readdirSync(this.path));\n      return this;\n    }\n  }, {\n    key: \"addIgnoreFile\",\n    value: function addIgnoreFile(file, then) {\n      var ig = path.resolve(this.path, file);\n      this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n    }\n  }, {\n    key: \"stat\",\n    value: function stat(entry, file, dir, then) {\n      var abs = this.path + '/' + entry;\n      var st = fs[this.follow ? 'statSync' : 'lstatSync'](abs);\n      this.onstat(st, entry, file, dir, then);\n    }\n  }, {\n    key: \"walker\",\n    value: function walker(entry, then) {\n      new WalkerSync(this.walkerOpt(entry)).start();\n      then();\n    }\n  }]);\n\n  return WalkerSync;\n}(Walker);\n\nvar walk = function walk(options, callback) {\n  var p = new Promise(function (resolve, reject) {\n    new Walker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(function (res) {\n    return callback(null, res);\n  }, callback) : p;\n};\n\nvar walkSync = function walkSync(options) {\n  return new WalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":null,"metadata":{},"sourceType":"script"}