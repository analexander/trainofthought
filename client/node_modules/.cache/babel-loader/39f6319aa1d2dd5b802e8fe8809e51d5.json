{"ast":null,"code":"import _slicedToArray from \"/Users/angeldiscopanda/Trilogy-2020/Projects/trainofthought/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n  var glsl = getGlslDifferences();\n  var vertexShaderSource = \"\".concat(glsl.version, \"\\n    precision highp float;\\n    \").concat(glsl.attribute, \" vec3 clipSpacePos;\\n    \").concat(glsl.attribute, \" vec2 uv;\\n    \").concat(glsl.varyingVs, \" vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n  webgl_util.validateTextureSize(width, height);\n  var texture = webgl_util.createTexture(gl);\n  var tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(tex2d, texture);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n  return texture;\n}\n\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n  return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getUnpacked = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getUnpacked2 = _slicedToArray(_tex_util$getUnpacked, 2),\n      width = _tex_util$getUnpacked2[0],\n      height = _tex_util$getUnpacked2[1];\n\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n  return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getUnpacked3 = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getUnpacked4 = _slicedToArray(_tex_util$getUnpacked3, 2),\n      width = _tex_util$getUnpacked4[0],\n      height = _tex_util$getUnpacked4[1];\n\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n  return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getUnpacked5 = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getUnpacked6 = _slicedToArray(_tex_util$getUnpacked5, 2),\n      width = _tex_util$getUnpacked6[0],\n      height = _tex_util$getUnpacked6[1];\n\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n  return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2),\n      width = _tex_util$getPackedMa2[0],\n      height = _tex_util$getPackedMa2[1];\n\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n  return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getPackedMa3 = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getPackedMa4 = _slicedToArray(_tex_util$getPackedMa3, 2),\n      width = _tex_util$getPackedMa4[0],\n      height = _tex_util$getPackedMa4[1];\n\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n  var posOffset = 0; // x is the first buffer element\n\n  var uvOffset = 3 * 4; // uv comes after [x y z]\n\n  var stride = 3 * 4 + 2 * 4; // xyz + uv, each entry is 4-byte float.\n\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  });\n  var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success && webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, texture);\n  });\n  var dataForUpload, texelDataType, internalFormat;\n\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, texture);\n  });\n\n  if (pixels.data instanceof Uint8Array) {\n    webgl_util.callAndCheck(gl, function () {\n      return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data);\n    });\n  } else {\n    webgl_util.callAndCheck(gl, function () {\n      return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    });\n  }\n\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n  // Create and bind the buffer.\n  var buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(gl2, function () {\n    return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  }); // Initialize the buffer to the size of the texture in bytes.\n\n  var bytesPerFloat = 4;\n  var valuesPerTexel = 4;\n  var bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n  webgl_util.callAndCheck(gl2, function () {\n    return gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ);\n  }); // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n\n  webgl_util.callAndCheck(gl2, function () {\n    return gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0);\n  });\n  webgl_util.callAndCheck(gl2, function () {\n    return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  });\n  return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n  var gl2 = gl;\n  var downloadTarget = new Float32Array(size);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n  var _tex_util$getUnpacked7 = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      _tex_util$getUnpacked8 = _slicedToArray(_tex_util$getUnpacked7, 2),\n      w = _tex_util$getUnpacked8[0],\n      h = _tex_util$getUnpacked8[1];\n\n  var numChannels = 4;\n  var downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n  webgl_util.callAndCheck(gl, function () {\n    return gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget);\n  }); // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n\n  return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n  var gl2 = gl;\n  var downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n  var packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA);\n  });\n  return packedRGBA;\n}","map":null,"metadata":{},"sourceType":"module"}